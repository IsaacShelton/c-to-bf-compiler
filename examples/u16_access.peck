
u0 main(){
    u16 value = 64553;
    printu16(value);
    print("\n");

    value = 1234;
    printu16(value);
    print("\n");

    value = 732;
    printu16(value);
    print("\n");

    value = 13;
    printu16(value);
    print("\n");

    value = 7;
    printu16(value);
    print("\n");

    value = 0;
    printu16(value);
    print("\n");
}

u16 u16_add_u8s(u8 a, u8 b){
    u16 result;
    u8 lower = a + b;
    result._0 = lower;
    result._1 = (u8) (lower < a || lower < b); // overflow bit
    return result;
}

u16 u16_add(u16 a, u16 b){
    u16 result = u16_add_u8s(a._0, b._0);
    result._1 += a._1 + b._1;
    return result;
}

u16 u16_sub(u16 a, u16 b){
    u16 negative_b = u16_add(u16_bit_negate(b), 1);
    return u16_add(a, negative_b);
}

u16 u16_bit_negate(u16 value){
    value._0 = ~value._0;
    value._1 = ~value._1;
    return value;
}

u16 u16_sll(u16 value, u8 amount){
    u16 result;

    // Assumes 8-bit cells and wrapping of course
    if(amount < 8){
        // 0..=7
        u8 between = (value._0 >> (8 - amount)); // Ok, as wrap around will work
        result._1 = (value._1 << amount) + between;
        result._0 = value._0 << amount;
    } else if(amount < 16){
        // 8..=15
        u8 count = amount - 8;
        result._1 = value._0 << count;
        result._0 = 0;
    } else {
        result._1 = 0;
        result._0 = 0;
    }

    return result;
}

u16 u16_mul(u16 a, u16 b){
    u1 a_bits[16];
    for(u8 i = 0; i < 8; i++){
        a_bits[16 - (8 + i) - 1] = (u1)( (a._1 >> i) & 1 );
    }

    for(u8 i = 0; i < 8; i++){
        a_bits[16 - i - 1] = (u1)( (a._0 >> i) & 1 );
    }

    u16 r = 0;

    for(u8 i = 0; i < 16; i++){
        if(a_bits[i]){
            r = u16_add(r, u16_sll(b, 15 - i));
        }
    }

    return r;
}

u1 u16_eq(u16 a, u16 b){
    return a._0 == b._0 && a._1 == b._1;
}

u16 u16_div(u16 a, u16 b){
    u16 r = 0;

    if(u16_eq(b, 0)){
        r = 0;
        a = 0;
    }

    if(u16_eq(b, 1)){
        r = a;
        a = 0;
    }

    if(u16_lte(b, 3)){
        u16 x16384 = u16_mul(16384, b);

        if(u16_gte(a, x16384)){
            a = u16_sub(a, x16384);
            r = u16_add(r, 16384);
        }
    }

    if(u16_lte(b, 7)){
        u16 x8192 = u16_mul(8192, b);

        if(u16_gte(a, x8192)){
            a = u16_sub(a, x8192);
            r = u16_add(r, 8192);
        }
    }

    if(u16_lte(b, 15)){
        u16 x4096 = u16_mul(4096, b);

        if(u16_gte(a, x4096)){
            a = u16_sub(a, x4096);
            r = u16_add(r, 4096);
        }
    }

    if(u16_lte(b, 31)){
        u16 x2048 = u16_mul(2048, b);

        if(u16_gte(a, x2048)){
            a = u16_sub(a, x2048);
            r = u16_add(r, 2048);
        }
    }

    if(u16_lte(b, 63)){
        u16 x1024 = u16_mul(1024, b);

        if(u16_gte(a, x1024)){
            a = u16_sub(a, x1024);
            r = u16_add(r, 1024);
        }
    }

    if(u16_lte(b, 127)){
        u16 x512 = u16_mul(512, b);

        if(u16_gte(a, x512)){
            a = u16_sub(a, x512);
            r = u16_add(r, 512);
        }
    }

    if(u16_lte(b, 255)){
        u16 x256;
        x256._1 = b._0;
        x256._0 = 0;

        if(u16_gte(a, x256)){
            a = u16_sub(a, x256);
            r = u16_add(r, 256);
        }
    }

    if(u16_lte(b, 511)){
        u16 x128 = u16_mul(128, b);

        if(u16_gte(a, x128)){
            a = u16_sub(a, x128);
            r = u16_add(r, 128);
        }
    }

    if(u16_lte(b, 1023)){
        u16 x64 = u16_mul(64, b);

        if(u16_gte(a, x64)){
            a = u16_sub(a, x64);
            r = u16_add(r, 64);
        }
    }

    if(u16_lte(b, 2047)){
        u16 x32 = u16_mul(32, b);

        if(u16_gte(a, x32)){
            a = u16_sub(a, x32);
            r = u16_add(r, 32);
        }
    }

    if(u16_lte(b, 4095)){
        u16 x16 = u16_mul(16, b);

        if(u16_gte(a, x16)){
            a = u16_sub(a, x16);
            r = u16_add(r, 16);
        }
    }

    if(u16_lte(b, 8191)){
        u16 x8 = u16_mul(8, b);

        if(u16_gte(a, x8)){
            a = u16_sub(a, x8);
            r = u16_add(r, 8);
        }
    }

    while(u16_gte(a, b)){
        a = u16_sub(a, b);
        r = u16_add(r, 1);
    }

    return r;
}

u16 u16_mod(u16 a, u16 b){
    return u16_sub(a, u16_mul(u16_div(a, b), b));
}

u1 u16_gt(u16 a, u16 b){
    return a._1 > b._1 || (a._1 == b._1 && a._0 > b._0);
}

u1 u16_gte(u16 a, u16 b){
    return a._1 > b._1 || (a._1 == b._1 && a._0 >= b._0);
}

u1 u16_lt(u16 a, u16 b){
    return !u16_gte(a, b);
}

u1 u16_lte(u16 a, u16 b){
    return !u16_gt(a, b);
}

u0 printhexdigit(u8 digit){
    if(digit < 10){
        put('0' + digit);
    } else {
        put('A' + (digit - 10));
    }
}

u0 printu8hex(u8 value){
    printhexdigit((value / 16) % 16);
    printhexdigit(value % 16);
}

u0 printu16(u16 value){
    u8 digits[5];
    u16 r;

    r = u16_mod(value, 10);
    digits[4] = r._0;

    value = u16_div(value, 10);
    r = u16_mod(value, 10);
    digits[3] = r._0;

    value = u16_div(value, 10);
    r = u16_mod(value, 10);
    digits[2] = r._0;

    value = u16_div(value, 10);
    r = u16_mod(value, 10);
    digits[1] = r._0;

    value = u16_div(value, 10);
    r = u16_mod(value, 10);
    digits[0] = r._0;

    u8 first = 0;

    while(first < sizeof digits - 1 && digits[first] == 0){
        first++;
    }

    for(u8 i = first; i < sizeof digits; i++){
        put('0' + digits[i]);
    }
}

u0 printu16hex(u16 value){
    printu8hex(value._1);
    printu8hex(value._0);
}

