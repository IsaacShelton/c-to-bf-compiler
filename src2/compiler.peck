typedef u8 ErrorCode;
typedef u8 ExpressionGetTypeMode;



ErrorCode add_builtin_functions();






ErrorCode add_builtin_types();




ErrorCode compute_typedef_sizes();




#define MEMORY_MULTIPLIER 1

#define MEGABYTES 1024 * 1024

// These values should be enough for regular programs
#define CODE_BUFFER_CAPACITY         (u32)( MEMORY_MULTIPLIER * 256 )
#define TOKENS_CAPACITY              (u32)( MEMORY_MULTIPLIER * 2*MEGABYTES / 8 )
#define AUX_CAPACITY                 (u32)( MEMORY_MULTIPLIER * 2*MEGABYTES )
#define TYPES_CAPACITY               (u32)( MEMORY_MULTIPLIER * MEGABYTES / 10 / 8 )
#define UNIQUE_DIMENSIONS_CAPACITY   (u32)( MEMORY_MULTIPLIER * 1024 )
#define FUNCTIONS_CAPACITY           (u32)( MEMORY_MULTIPLIER * 2048 )
#define EXPRESSIONS_CAPACITY         (u32)( MEMORY_MULTIPLIER * 4*MEGABYTES / 8 )
#define STATEMENTS_CAPACITY          (u32)( MEMORY_MULTIPLIER * MEGABYTES / 4 )
#define OPERANDS_CAPACITY            (u32)( MEMORY_MULTIPLIER * 1*MEGABYTES / 4 )
#define GLOBALS_CAPACITY             (u32)( MEMORY_MULTIPLIER * 2048 )
#define TYPEDEFS_CAPACITY            (u32)( MEMORY_MULTIPLIER * 2048 )
#define TYPE_ALIASES_CAPACITY        (u32)( MEMORY_MULTIPLIER * 32 )
#define DEFINES_CAPACITY             (u32)( MEMORY_MULTIPLIER * 64 )
#define ARROWS_CAPACITY              (u32)( MEMORY_MULTIPLIER * MEGABYTES / 4 )
#define TYPE_DEPENDENCIES_CAPACITY   (u32)( MEMORY_MULTIPLIER * MEGABYTES / 8 )
#define ARITY_CAPACITY               32
#define CLOSES_NEEDED_CAPCAITY       (u32)( MEMORY_MULTIPLIER * 4096 )
#define MAX_INITIALIZER_LIST_LENGTH  (u32)( MEMORY_MULTIPLIER * 4096 )
#define DEFAULT_STACK_SIZE           (u32)( 256 )




typedef struct {
    u32 name;
    u32 expression;
} Define;




u0 define_print(Define def);





u0 dupe_cell();
u0 dupe_cell_offset(u32 amount);
u0 dupe_cells(u32 amount);
u0 emit_print_aux_cstr(u32 string);
u0 set_cell_to_value(u8 new_value, u8 old_value);

u0 copy_cell_static(u32 start_index);
u0 copy_cells_static(u32 start_index, u32 size);

u0 copy_cell_dynamic_u8(u32 start_index);
u0 copy_cell_dynamic_u16(u32 start_index);
u0 copy_cell_dynamic_u24(u32 start_index);
u0 copy_cell_dynamic_u32(u32 start_index);

u0 copy_cells_dynamic_u8(u32 start_index, u32 size);
u0 copy_cells_dynamic_u16(u32 start_index, u32 size);
u0 copy_cells_dynamic_u24(u32 start_index, u32 size);
u0 copy_cells_dynamic_u32(u32 start_index, u32 size);

u0 move_cell_static(u32 destination_index);
u0 move_cells_static(u32 destination_index, u32 size);

u0 move_cell_dynamic_u8(u32 destination_start_index);
u0 move_cell_dynamic_u16(u32 destination_start_index);
u0 move_cell_dynamic_u24(u32 destination_start_index);
u0 move_cell_dynamic_u32(u32 destination_start_index);

u0 move_cells_dynamic_u8(u32 destination_start_index, u32 size);
u0 move_cells_dynamic_u16(u32 destination_index, u32 size);
u0 move_cells_dynamic_u24(u32 destination_index, u32 size);
u0 move_cells_dynamic_u32(u32 destination_index, u32 size);

u0 print_cells_static(u32 start_index, u32 max_length);

u0 emit_u1(u1 value);
u0 emit_u8(u8 value);
u0 emit_u16(u16 value);
u0 emit_u24(u24 value);
u0 emit_u32(u32 value);

u0 emit_printu1();
u0 emit_printu8();
u0 emit_print_array_value(u32 max_length);

u0 emit_additive_u8(u1 is_plus);
u0 emit_additive_u16(u1 is_plus);
u0 emit_additive_u32(u1 is_plus);

u0 emit_multiply_u8();
u0 emit_multiply_u16();
u0 emit_multiply_u32();

u0 emit_divmod_u8();

u0 emit_divide_u8();
u0 emit_divide_u16();
u0 emit_divide_u32();

u0 emit_mod_u8();
u0 emit_mod_u16();
u0 emit_mod_u32();

u0 emit_lshift_u8();
u0 emit_lshift_u16();
u0 emit_lshift_u32();

u0 emit_rshift_u8();
u0 emit_rshift_u16();
u0 emit_rshift_u32();

u0 emit_eq_u8();
u0 emit_eq_u16();
u0 emit_eq_u32();

u0 emit_neq_u8();
u0 emit_neq_u16();
u0 emit_neq_u32();

u0 emit_lt_u8();
u0 emit_lt_u16();
u0 emit_lt_u32();

u0 emit_gt_u8();
u0 emit_gt_u16();
u0 emit_gt_u32();

u0 emit_lte_u8();
u0 emit_lte_u16();
u0 emit_lte_u32();

u0 emit_gte_u8();
u0 emit_gte_u16();
u0 emit_gte_u32();

u0 emit_bit_and_u8();
u0 emit_bit_and_u16();
u0 emit_bit_and_u32();

u0 emit_bit_or_u8();
u0 emit_bit_or_u16();
u0 emit_bit_or_u32();

u0 emit_bit_xor_u8();
u0 emit_bit_xor_u16();
u0 emit_bit_xor_u32();

u0 emit_not_u1();

u0 emit_negate_u8();
u0 emit_negate_u16();
u0 emit_negate_u32();

u0 emit_bit_complement_u8();
u0 emit_bit_complement_u16();
u0 emit_bit_complement_u32();

u0 emit_printu16();
u0 emit_printu32();

u0 emit_stdlib_function_call(u8 function_name[16], u32 return_size, u32 params_size);





typedef struct {
    u32 basicblock_id;
    u32 num_cells_input;
} JumpContext;

typedef struct {
    u32 num_cases;
    u1 has_default_case;
    u32 first_case_body_basicblock_id;
    u32 first_case_test_basicblock_id;
    u32 default_basicblock_id;
    u32 continuation_basicblock_id;
    u32 pushed;
    u32 next_case;
} SwitchContext;

typedef struct {
    u32 function;
    u32 function_cell_index;
    u32 current_cell_index;
    u32 current_statement;
    u1 in_recursive_function;
    u1 can_function_early_return;
    u32 incomplete_cell;
    u32 didnt_break_cell;
    u32 didnt_continue_cell;
    u32 switch_value_type;
    u32 switch_value_type_cached_size;
    u32 switch_start_cell_index;
    u32 fell_through_cell;
} EmitContext;

typedef struct {
    u1 enable_stack;
    u32 stack_pointer;
    u32 stack_begin;
    u32 stack_driver_position;
    u32 next_basicblock_id;
    u1 stack_overflow_checks;
    u32 stack_overflow_message;
    u32 stack_size;
    u1 in_basicblock;
    u1 can_break;
    u1 can_continue;
    JumpContext break_basicblock_context;
    JumpContext continue_basicblock_context;
    SwitchContext switch_basicblock_context;
    u32 main_function_index;
} EmitSettings;






typedef enum {
    EXPRESSION_NONE,
    EXPRESSION_RETURN, /* { expression } */
    EXPRESSION_DECLARE, /* { type, name } */
    EXPRESSION_PRINT_LITERAL, /* { string } */
    EXPRESSION_PRINT_ARRAY, /* { expression } */
    EXPRESSION_CALL, /* { name, arity, arg1, arg2, ..., argN } */
    EXPRESSION_IMPLEMENT_PUT,
    EXPRESSION_IMPLEMENT_PRINTU1,
    EXPRESSION_IMPLEMENT_PRINTU8,
    EXPRESSION_IMPLEMENT_GET,
    EXPRESSION_IMPLEMENT_READU8,
    EXPRESSION_U1, /* { value } */
    EXPRESSION_U8, /* { value } */
    EXPRESSION_U16, /* { value } */
    EXPRESSION_U24, /* { value } */
    EXPRESSION_U32, /* { value } */
    EXPRESSION_INT, /* { value } */
    EXPRESSION_VARIABLE, /* { name } */
    EXPRESSION_CAST, /* { type, expression } */
    EXPRESSION_ASSIGN, /* { a, b } */
    EXPRESSION_ADD, /* { a, b } */
    EXPRESSION_SUBTRACT, /* { a, b } */
    EXPRESSION_MULTIPLY, /* { a, b } */
    EXPRESSION_DIVIDE, /* { a, b } */
    EXPRESSION_MOD, /* { a, b } */
    EXPRESSION_EQUALS, /* { a, b } */
    EXPRESSION_NOT_EQUALS, /* { a, b } */
    EXPRESSION_LESS_THAN, /* { a, b } */
    EXPRESSION_GREATER_THAN, /* { a, b } */
    EXPRESSION_LESS_THAN_OR_EQUAL, /* { a, b } */
    EXPRESSION_GREATER_THAN_OR_EQUAL, /* { a, b } */
    EXPRESSION_LSHIFT, /* { a, b } */
    EXPRESSION_RSHIFT, /* { a, b } */
    EXPRESSION_AND, /* { a, b } */
    EXPRESSION_OR, /* { a, b } */
    EXPRESSION_BIT_AND, /* { a, b } */
    EXPRESSION_BIT_OR, /* { a, b } */
    EXPRESSION_BIT_XOR, /* { a, b } */
    EXPRESSION_NEGATE, /* { value } */
    EXPRESSION_NOT, /* { value } */
    EXPRESSION_BIT_COMPLEMENT, /* { value } */
    EXPRESSION_INDEX,  /* { a, b } */
    EXPRESSION_PRE_INCREMENT, /* { a } */
    EXPRESSION_PRE_DECREMENT, /* { a } */
    EXPRESSION_POST_INCREMENT, /* { a } */
    EXPRESSION_POST_DECREMENT, /* { a } */
    EXPRESSION_NO_RESULT_INCREMENT, /* { a } */
    EXPRESSION_NO_RESULT_DECREMENT, /* { a } */
    EXPRESSION_TERNARY, /* { condition, when_true, when_false } */
    EXPRESSION_IF, /* { condition, num_statements } */
    EXPRESSION_IF_ELSE, /* { condition, num_statements, num_else_statements } */
    EXPRESSION_WHILE, /* { condition, num_statements, computed_inner_variable_offset } */
    EXPRESSION_DO_WHILE, /* { condition, num_statements, computed_inner_variable_offset } */
    EXPRESSION_MEMBER, /* { subject, member_name } */
    EXPRESSION_STRING, /* { null_terminated_string } */
    EXPRESSION_BREAK,
    EXPRESSION_CONTINUE,
    EXPRESSION_FOR, /* { num_pre_statements, condition, pre_post_statements, num_statements, computed_inner_variable_offset } */
    EXPRESSION_CONDITIONLESS_BLOCK, /* { num_statements } */
    EXPRESSION_SIZEOF_TYPE, /* { type } */
    EXPRESSION_SIZEOF_TYPE_U8, /* { type } */
    EXPRESSION_SIZEOF_TYPE_U16, /* { type } */
    EXPRESSION_SIZEOF_TYPE_U24, /* { type } */
    EXPRESSION_SIZEOF_TYPE_U32, /* { type } */
    EXPRESSION_SIZEOF_VALUE, /* { value } */
    EXPRESSION_SIZEOF_VALUE_U8, /* { value } */
    EXPRESSION_SIZEOF_VALUE_U16, /* { value } */
    EXPRESSION_SIZEOF_VALUE_U24, /* { value } */
    EXPRESSION_SIZEOF_VALUE_U32, /* { value } */
    EXPRESSION_SWITCH, /* { condition, num_statements } */
    EXPRESSION_CASE, /* { numeric_expression, num_statements } */
    EXPRESSION_ARRAY_INITIALIZER, /* { num_expressions, expression1, expression2, expression3, ..., expressionN } */
    EXPRESSION_STRUCT_INITIALIZER, /* { type, num_expressions, field_initializer1, field_initializer2, ..., field_initializerN } */
    EXPRESSION_FIELD_INITIALIZER, /* { field_name, field_value } */
    EXPRESSION_ENUM_VARIANT, /* { name } */
    EXPRESSION_PANICLOOP, /* {} */
    EXPRESSION_PRINTF, /* <same as EXPRESSION_CALL> */
    EXPRESSION_MEMCMP, /* <same as EXPRESSION_CALL> */
    EXPRESSION_MEMCPY, /* <same as EXPRESSION_CALL> */
} ExpressionKind;

typedef struct {
    ExpressionKind kind;
    u24 line;
    u32 ops; // Start index in `operands` array (except if single operand, in which case ops itself is the value)
} Expression;

u0 expression_print_operator(ExpressionKind kind);
u0 expression_print_operation_name(ExpressionKind kind);
ExpressionKind expression_kind_unary_prefix_from_token_kind(TokenKind kind);
ExpressionKind expression_kind_unary_postfix_from_token_kind(TokenKind kind);
ExpressionKind expression_kind_binary_from_token_kind(TokenKind kind);
ExpressionKind expression_kind_binary_from_assignment_token_kind(TokenKind kind);

u0 expression_print_cannot_use_case_here_error(Expression expression);





typedef struct {
    u32 tape_location;
    u8 offset_size;
    u1 on_stack;
    u32 type; // If == TYPES_CAPACITY, then error occurred
} Destination;

u32 expression_emit(Expression expression);
Destination expression_get_destination(Expression expression, u32 tape_anchor);
u32 read_destination(Destination destination, u24 line_on_error);
u32 write_destination(u32 new_value_type, Destination destination, u24 error_line_number);
u32 write_destination_unsafe(u32 new_value_type, Destination destination, u24 error_line_number);
ErrorCode grow_type(u32 from_type_index, u32 to_type_index, u8 offset_size);





#define EXPRESSION_GET_TYPE_MODE_NONE 0
#define EXPRESSION_GET_TYPE_MODE_PRINT_ERROR 1
#define EXPRESSION_GET_TYPE_MODE_INFER 2


u32 expression_get_type(Expression expression, ExpressionGetTypeMode mode);
u32 get_item_type(Type type, u24 line_on_error, u1 show_error_message);
u32 expression_get_type_for_call(Expression expression);
u32 expression_get_type_for_string(Expression expression);
u32 expression_get_type_for_variable(Expression expression, ExpressionGetTypeMode mode);





ExpressionKind type_to_expression_kind(u32 type);
ExpressionKind expression_get_preferred_int_kind_or_none(u32 expression_index);
u0 expression_infer(u32 expression_index, ExpressionKind preferred_int_kind);





u0 expression_print(Expression expression);




typedef struct {
    // Name of function
    u32 name;
    
    // Number of parameters this function takes
    // NOTE: Exact parameters can be determined by looking at the first `arity` statements (which will be declaration statements)
    u8 arity;

    // Return type of function
    u32 return_type;

    // Beginning of function's statements
    u32 begin;

    // Number of statements in function
    u32 num_stmts;

    // Whether function is recursive
    u1 is_recursive;

    // What line number the function was declared on
    u24 line;
} Function;

u32 function_args_size(Function function);





ErrorCode function_emit(u32 function_index, u32 start_function_cell_index, u32 start_current_cell_index);





u0 function_infer(u32 function_index);





u0 function_print(Function function);





typedef struct {
    u32 name;
    u32 type;
    u24 line;
    u32 initializer;
} Global;





u0 global_print(Global global);





u32 infer();









u32 lex();





LexedToken lex_character_literal();










LexUnboundedResult lex_line_comment(u8 c);





LexUnboundedResult lex_multiline_comment(u8 c);





typedef struct {
    Token token;
    u32 consumed;
} LexedToken;

typedef struct {
    u1 error;
    u8 new_c;
} LexUnboundedResult;





LexUnboundedResult lex_string(u8 c);





LexedToken lex_character_literal();





ErrorCode mark_recursive_functions();





u32 parse();






u0 instead_got();
u0 stop_parsing();
u1 is_token(TokenKind kind);
u32 current_line();
u24 current_line_packed();
u32 eat_word();
u32 eat_int();
u32 eat_string();
u1 eat_token(TokenKind kind);





u32 parse_add_dimensions(u32 type_dimensions[4]);
u32 parse_dimensions(u32 start_type_dimensions[4]);




Expression parse_expression();





ErrorCode parse_macro();
Expression perform_compile_time_math(Expression expression);
u1 is_expression_kind_int_like(ExpressionKind kind);





ErrorCode parse_statement();
ErrorCode parse_declaration(u1 allow_assignment);





Type parse_type();
u1 is_type_followed_by(TokenKind followed_by);





ErrorCode parse_typedef();





u0 print_lexed_construction();





u0 emit_stack_driver_pre(u32 entry_basicblock_id);
u0 emit_stack_driver_post();
u32 emit_stack_driver_push_all();
u0 emit_stack_driver_pop_all();

u32 emit_recursive_functions();
u0 emit_stack_pointer();
u0 emit_set_stack_pointer();
u0 emit_stack_push_n(u32 num_cells);
u0 emit_stack_pop_n(u32 num_cells);
u0 emit_start_basicblock(u32 basicblock_id);
u0 emit_end_basicblock();
u32 basicblock_id_for_function(u32 function_id);

u0 emit_start_basicblock_landing(u32 basicblock_id, u32 num_cells_to_pop);
u32 emit_jump(u32 target_basicblock_id);
u32 emit_jump_compatible(u32 target_basicblock_id, u32 expected_pushed_cells);
u32 emit_end_basicblock_jump(u32 target_basicblock_id);
u0 emit_end_basicblock_jump_compatible(u32 target_basicblock_id, u32 expected_pushed_cells);
u32 emit_end_basicblock_jump_conditional(u32 then_basicblock_id, u32 else_basicblock_id);
u0 emit_end_basicblock_jump_to(JumpContext context);





u0 inject_standard_library();





typedef enum {
    CLOSE_NEEDED_FOR_EARLY_RETURN_CHECK,
    CLOSE_NEEDED_FOR_BREAK_CHECK,
    CLOSE_NEEDED_FOR_CONTINUE_CHECK,
} CloseNeeded;















u32 add_type(Type type);
u32 add_dimensions(u32 type_dimensions[4]);
u32 add_function(Function function);
u32 find_function(u32 name);
u32 find_function_return_type(u32 name);
u32 add_expression(Expression expression);
u32 add_statement_from_existing(u32 expression_index);
u32 add_statement_from_new(Expression expression);
u32 add_operand(u32 a);
u32 add_operands2(u32 a, u32 b);
u32 add_operands3(u32 a, u32 b, u32 c);
u32 add_operands5(u32 a, u32 b, u32 c, u32 d, u32 e);
u32 add_global(Global global);
u32 add_typedef(TypeDef def);
u32 find_typedef(u32 name);
u32 add_type_alias(TypeAlias alias);
u32 try_resolve_type_alias(u32 name);
u32 add_define(Define define);
u32 try_resolve_define(u32 name, u1 use_preferred_type);
u32 aux_cstr_alloc(u8 null_terminated_name[32]);
u1 aux_cstr_equals(u32 a, u32 b);
u1 aux_cstr_equals_string(u32 a, u8 string[32]);
u1 aux_cstr_equals_print(u32 a);
u1 aux_cstr_equals_main(u32 a);
u1 aux_cstr_equals_u1(u32 a);
u1 aux_cstr_equals_u0(u32 a);
u1 aux_cstr_equals_u8(u32 a);
u1 aux_cstr_equals_u16(u32 a);
u1 aux_cstr_equals_u32(u32 a);
u1 aux_cstr_equals_void(u32 a);
u1 aux_cstr_equals_bool(u32 a);
u1 aux_cstr_equals_char(u32 a);
u1 aux_cstr_equals_short(u32 a);
u1 aux_cstr_equals_int(u32 a);
u1 aux_cstr_equals_long(u32 a);
u1 aux_cstr_equals_panicloop(u32 a);
u1 aux_cstr_equals_define(u32 a);
u1 aux_cstr_equals_printf(u32 a);
u1 aux_cstr_equals_memcmp(u32 a);
u1 aux_cstr_equals_memcpy(u32 a);
u32 aux_cstr_len(u32 str);
u0 print_aux_cstr(u32 index);
u0 print_aux_cstr_escaped(u32 index);
u32 find_enum_from_type(u32 type_index);
u1 in_range_inclusive(u8 value, u8 min_inclusive, u8 max_inclusive);





typedef enum {
    TOKEN_NONE,
    TOKEN_DONE,
    TOKEN_ERROR,
    TOKEN_LINE_COMMENT,
    TOKEN_MULTILINE_COMMENT,
    TOKEN_WORD,
    TOKEN_BEGIN,
    TOKEN_END,
    TOKEN_OPEN,
    TOKEN_CLOSE,
    TOKEN_STRING,
    TOKEN_SEMICOLON,
    TOKEN_OPEN_BRACKET,
    TOKEN_CLOSE_BRACKET,
    TOKEN_TRUE,
    TOKEN_FALSE,
    TOKEN_INT,
    TOKEN_NEXT,
    TOKEN_ASSIGN,
    TOKEN_ADD,
    TOKEN_SUBTRACT,
    TOKEN_MULTIPLY,
    TOKEN_DIVIDE,
    TOKEN_MOD,
    TOKEN_EQUALS,
    TOKEN_NOT_EQUALS,
    TOKEN_LESS_THAN,
    TOKEN_GREATER_THAN,
    TOKEN_LESS_THAN_OR_EQUAL,
    TOKEN_GREATER_THAN_OR_EQUAL,
    TOKEN_LSHIFT,
    TOKEN_RSHIFT,
    TOKEN_AND,
    TOKEN_OR,
    TOKEN_BIT_AND,
    TOKEN_BIT_OR,
    TOKEN_BIT_XOR,
    TOKEN_NOT,
    TOKEN_BIT_COMPLEMENT,
    TOKEN_INCREMENT,
    TOKEN_DECREMENT,
    TOKEN_TERNARY,
    TOKEN_COLON,
    TOKEN_IF,
    TOKEN_ELSE,
    TOKEN_WHILE,
    TOKEN_DO,
    TOKEN_TYPEDEF,
    TOKEN_STRUCT,
    TOKEN_MEMBER,
    TOKEN_ADD_ASSIGN,
    TOKEN_SUBTRACT_ASSIGN,
    TOKEN_MULTIPLY_ASSIGN,
    TOKEN_DIVIDE_ASSIGN,
    TOKEN_MOD_ASSIGN,
    TOKEN_LSHIFT_ASSIGN,
    TOKEN_RSHIFT_ASSIGN,
    TOKEN_BIT_AND_ASSIGN,
    TOKEN_BIT_OR_ASSIGN,
    TOKEN_BIT_XOR_ASSIGN,
    TOKEN_RETURN,
    TOKEN_BREAK,
    TOKEN_CONTINUE,
    TOKEN_FOR,
    TOKEN_SIZEOF,
    TOKEN_SWITCH,
    TOKEN_CASE,
    TOKEN_DEFAULT,
    TOKEN_ENUM,
    TOKEN_HASH,
} TokenKind;

typedef struct {
    TokenKind kind;
    u24 line;
    u32 data;
} Token;





u0 token_print(Token token, u1 safe);




typedef struct {
    u32 name;
    u32 dimensions;
} Type;

u0 type_does_not_exist(Type type, u24 line);





u32 type_sizeof_or_max(u32 type_index, u24 line_on_error);





// NOTE: If using registered types (indices inside of global `types` array),
//       You should just check if two indicies are equal.
//       e.g. return_type == u0_type
// Determines if two `Type` values are equal.
u1 type_equals(Type a, Type b);





u0 type_print(Type type);





typedef enum {
    TYPEDEF_STRUCT,
    TYPEDEF_ENUM,
} TypeDefKind;

typedef struct {
    // Kind of typedef
    TypeDefKind kind;

    // Line
    u24 line;

    // Name of typedef
    u32 name;

    // Beginning of typedef's fields (stored as statements)
    u32 begin;

    // Number of fields
    u32 num_fields;

    // Computed size
    u32 computed_size;
} TypeDef;

typedef struct {
    u32 name;
    u32 rewritten_type;
} TypeAlias;





u0 typedef_print(TypeDef def);
u0 type_alias_print(TypeAlias alias);











// NOTE: `bytes` are in big endian
typedef struct { u8 bytes[3]; } u24;
u24 u24_pack(u32 value);
u32 u24_unpack(u24 value);






typedef enum {
    VARIABLE_LOCATION_ON_TAPE,
    VARIABLE_LOCATION_ON_STACK,
    VARIABLE_LOCATION_IMMUTABLE,
} VariableLocationKind;

typedef struct {
    VariableLocationKind kind;

    // Absolute location if on tape,
    // Relative location if on stack,
    // Value if immutable
    u32 location;
} VariableLocation;

typedef struct {
    u32 name; // name index in `aux`
    u32 type; // type index in `types`
    u32 depth; // scope depth, depth of 0 means global, anything else means in a scope
    u1 defined; // whether defined
    VariableLocation location;
} Variable;

// Tape layout:
// [global variables] [stack pointer] [stack] [working memory]

Variable variable_find(u32 name);




ErrorCode add_put_function(){
    u8 raw_function_name[16] = "put";

    u32 name = aux_cstr_alloc(raw_function_name);
    if(name >= AUX_CAPACITY) return 1;

    u8 raw_parameter_name[16] = "c";
    u32 parameter_name = aux_cstr_alloc(raw_parameter_name);

    u32 operands = add_operands2(u8_type, parameter_name);
    if(operands >= OPERANDS_CAPACITY) return 1;

    u32 argument = add_statement_from_new((Expression){
        .kind = EXPRESSION_DECLARE,
        .line = u24_pack(0),
        .ops = operands,
    });

    u32 implementation = add_statement_from_new((Expression){
        .kind = EXPRESSION_IMPLEMENT_PUT,
        .line = u24_pack(0),
        .ops = 0,
    });

    if(implementation >= STATEMENTS_CAPACITY) return 1;

    Function function = (Function){
        .name = name,
        .arity = 1,
        .return_type = u0_type,
        .begin = argument,
        .num_stmts = 2,
        .is_recursive = false,
        .line = u24_pack(0),
    };

    if(add_function(function) >= FUNCTIONS_CAPACITY) return 1;
    return 0;
}

ErrorCode add_printu1_function(){
    u8 raw_function_name[16] = "printu1";

    u32 name = aux_cstr_alloc(raw_function_name);
    if(name >= AUX_CAPACITY) return 1;

    u8 raw_parameter_name[16] = "value";
    u32 parameter_name = aux_cstr_alloc(raw_parameter_name);

    u32 operands = add_operands2(u1_type, parameter_name);
    if(operands >= OPERANDS_CAPACITY) return 1;

    u32 argument = add_statement_from_new((Expression){
        .kind = EXPRESSION_DECLARE,
        .line = u24_pack(0),
        .ops = operands,
    });

    u32 implementation = add_statement_from_new((Expression){
        .kind = EXPRESSION_IMPLEMENT_PRINTU1,
        .line = u24_pack(0),
        .ops = 0,
    });

    if(implementation >= STATEMENTS_CAPACITY) return 1;

    Function function = (Function){
        .name = name,
        .arity = 1,
        .return_type = u0_type,
        .begin = argument,
        .num_stmts = 2,
        .is_recursive = false,
        .line = u24_pack(0),
    };

    if(add_function(function) >= FUNCTIONS_CAPACITY) return 1;
    return 0;
}

ErrorCode add_printu8_function(){
    u8 raw_function_name[16] = "printu8";

    u32 name = aux_cstr_alloc(raw_function_name);
    if(name >= AUX_CAPACITY) return 1;

    u8 raw_parameter_name[16] = "value";
    u32 parameter_name = aux_cstr_alloc(raw_parameter_name);

    u32 operands = add_operands2(u8_type, parameter_name);
    if(operands >= OPERANDS_CAPACITY) return 1;

    u32 argument = add_statement_from_new((Expression){
        .kind = EXPRESSION_DECLARE,
        .line = u24_pack(0),
        .ops = operands,
    });

    u32 implementation = add_statement_from_new((Expression){
        .kind = EXPRESSION_IMPLEMENT_PRINTU8,
        .line = u24_pack(0),
        .ops = 0,
    });

    if(implementation >= STATEMENTS_CAPACITY) return 1;

    Function function = (Function){
        .name = name,
        .arity = 1,
        .return_type = u0_type,
        .begin = argument,
        .num_stmts = 2,
        .is_recursive = false,
        .line = u24_pack(0),
    };

    if(add_function(function) >= FUNCTIONS_CAPACITY) return 1;
    return 0;
}

ErrorCode add_get_function(){
    u8 raw_function_name[16] = "get";

    u32 name = aux_cstr_alloc(raw_function_name);
    if(name >= AUX_CAPACITY) return 1;

    u32 implementation = add_statement_from_new((Expression){
        .kind = EXPRESSION_IMPLEMENT_GET,
        .line = u24_pack(0),
        .ops = 0,
    });

    if(implementation >= STATEMENTS_CAPACITY) return 1;

    Function function = (Function){
        .name = name,
        .arity = 0,
        .return_type = u8_type,
        .begin = implementation,
        .num_stmts = 1,
        .is_recursive = false,
        .line = u24_pack(0),
    };

    if(add_function(function) >= FUNCTIONS_CAPACITY) return 1;
    return 0;
}

ErrorCode add_readu8_function(){
    u8 raw_function_name[16] = "readu8";

    u32 name = aux_cstr_alloc(raw_function_name);
    if(name >= AUX_CAPACITY) return 1;

    u32 implementation = add_statement_from_new((Expression){
        .kind = EXPRESSION_IMPLEMENT_READU8,
        .line = u24_pack(0),
        .ops = 0,
    });

    if(implementation >= STATEMENTS_CAPACITY) return 1;

    Function function = (Function){
        .name = name,
        .arity = 0,
        .return_type = u8_type,
        .begin = implementation,
        .num_stmts = 1,
        .is_recursive = false,
        .line = u24_pack(0),
    };

    if(add_function(function) >= FUNCTIONS_CAPACITY) return 1;
    return 0;
}

ErrorCode add_builtin_functions(){
    if(add_put_function()) return 1;
    if(add_printu1_function()) return 1;
    if(add_printu8_function()) return 1;
    if(add_get_function()) return 1;
    if(add_readu8_function()) return 1;
    return 0;
}



u32 u0_type;
u32 u1_type;
u32 u8_type;
u32 u16_type;
u32 u24_type;
u32 u32_type;

u32 make_simple_type(u8 raw_name[16]){
    // Alloc string
    u32 name = aux_cstr_alloc(raw_name);
    if(name >= AUX_CAPACITY) return TYPES_CAPACITY;

    // Create type
    return add_type((Type){
        .name = name,
        .dimensions = 0,
    });
}

ErrorCode add_builtin_types(){
    // Create u0 type
    u8 u0_name[16] = "u0";
    u0_type = make_simple_type(u0_name);
    if(u0_type == TYPES_CAPACITY) return 1;

    // Create u1 type
    u8 u1_name[16] = "u1";
    u1_type = make_simple_type(u1_name);
    if(u1_type == TYPES_CAPACITY) return 1;
    
    // Create u8 type
    u8 u8_name[16] = "u8";
    u8_type = make_simple_type(u8_name);
    if(u8_type == TYPES_CAPACITY) return 1;

    // Create u16 type
    u8 u16_name[16] = "u16";
    u16_type = make_simple_type(u16_name);
    if(u16_type == TYPES_CAPACITY) return 1;

    // Create u24 type
    u8 u24_name[16] = "u24";
    u24_type = make_simple_type(u24_name);
    if(u24_type == TYPES_CAPACITY) return 1;

    // Create u32 type
    u8 u32_name[16] = "u32";
    u32_type = make_simple_type(u32_name);
    if(u32_type == TYPES_CAPACITY) return 1;

    return 0;
}



typedef struct {
    u32 from;
    u32 to;
} TypeDependency;

ErrorCode compute_typedef_sizes(){
    TypeDependency dependencies[TYPE_DEPENDENCIES_CAPACITY];
    u32 num_dependencies = 0;

    u32 outgoing[TYPEDEFS_CAPACITY] = {0};

    // Construct type dependencies
    for(u32 i = 0; i < num_typedefs; i++){
        TypeDef def = typedefs[i];

        if(def.kind == TYPEDEF_ENUM){
            typedefs[i].computed_size = 1;
            continue;
        }

        for(u32 j = def.begin; j < def.begin + def.num_fields; j++){
            Expression expression = expressions[statements[j]];
            if(expression.kind != EXPRESSION_DECLARE) continue;

            Type type = types[operands[expression.ops]];

            if(!(
                aux_cstr_equals_u0(type.name)
             || aux_cstr_equals_u1(type.name)
             || aux_cstr_equals_u8(type.name)
             || aux_cstr_equals_u16(type.name)
             || aux_cstr_equals_u32(type.name)
            )){
                // Not trivial type
                
                u32 required = find_typedef(type.name);
                if(required >= TYPEDEFS_CAPACITY){
                    type_does_not_exist(type, expression.line);
                    return 1;
                }

                if(num_dependencies == TYPE_DEPENDENCIES_CAPACITY){
                    printf("\nOut of memory: Exceeded maximum number of typedef dependencies\n");
                    return 1;
                }

                if(typedefs[required].kind == TYPEDEF_ENUM){
                    continue;
                }

                u1 already_exists = false;

                for(u32 k = 0; k < num_dependencies; k++){
                    if(dependencies[k].from == i && dependencies[k].to == required){
                        already_exists = true;
                        break;
                    }
                }

                if(!already_exists){
                    dependencies[num_dependencies++] = (TypeDependency){
                        .from = i,
                        .to = required,
                    };

                    outgoing[i]++;
                }
            }
        }
    }

    u1 progress = true;

    // Compute types that have no remaining dependencies
    while(progress){
        progress = false;
        // Compute sizes for all trivial typedefs
        for(u32 i = 0; i < num_typedefs; i++){
            if(!(outgoing[i] == 0 && typedefs[i].computed_size == -1)) continue;

            TypeDef def = typedefs[i];
            u32 size = 0;

            for(u32 j = 0; j < def.num_fields; j++){
                Expression expression = expressions[statements[def.begin + j]];
                if(expression.kind != EXPRESSION_DECLARE) continue;

                u32 field_size = type_sizeof_or_max(operands[expression.ops], expression.line);
                if(field_size == -1) return 1;

                size += field_size;
            }

            typedefs[i].computed_size = size;

            for(u32 j = 0; j < num_dependencies; j++){
                if(dependencies[j].to == i){
                    outgoing[dependencies[j].from]--;
                    progress = true;
                }
            }
        }
    }

    u1 has_undetermined = false;

    // Ensure all typedefs were processed
    for(u32 i = 0; i < num_typedefs; i++){
        if(outgoing[i] != 0){
            printf("\nerror on line %d: Type '", u24_unpack(typedefs[i].line));
            print_aux_cstr(typedefs[i].name);
            printf("' has infinite size, %d dependencies remain\n", outgoing[i]);
            has_undetermined = true;
        }
    }

    return has_undetermined ? 1 : 0;
}



u0 define_print(Define define){
    printf("#define ");
    print_aux_cstr(define.name);
    printf(" ");
    expression_print(expressions[define.expression]);
}



u0 dupe_cell(){
    // a ?
    //   ^

    // Zero next two cells
    printf("[-]>[-]<<");

    // Dupe rightward
    printf("[>+>+<<-]");

    // Move second copy back into original
    printf(">>[<<+>>-]");

    // Remain pointing to next available cell
    // (nothing to do)

    emit_context.current_cell_index++;
}

u0 dupe_cell_offset(u32 offset){
    // a ?
    //   ^

    // Zero next two cells, and go to target read cell
    printf("[-]>[-]%d<", offset + 1);

    // Dupe into next available cell
    printf("[%d>+>+%d<-]", offset, offset + 1);

    // Move second copy back into original
    printf("%d>[%d<+%d>-]", offset + 1, offset + 1, offset + 1);

    // Remain pointing to next available cell
    // (nothing to do)

    emit_context.current_cell_index++;
}

u0 dupe_cells(u32 amount){
    for(u32 i = 0; i < amount; i++){
        dupe_cell_offset(amount);
    }
}

u0 emit_print_aux_cstr(u32 string){
    printf("[-]"); // zero character cell
    
    u8 previous_value = 0;

    for(u32 i = string; aux[i] != 0; i++){
        set_cell_to_value(aux[i], previous_value);
        printf(".");
        previous_value = aux[i];
    }
}

u0 set_cell_to_value(u8 new_value, u8 old_value){
    if(new_value == old_value){
        // nothing to do
    } else if(new_value > old_value){
        // increase by difference
        printf("%d+", new_value - old_value);
    } else {
        // decrease by difference
        printf("%d-", old_value - new_value);
    }
}

u0 copy_cell_static(u32 start_index){
    u32 current_cell_index = emit_context.current_cell_index;
    if(start_index >= current_cell_index) return;

    u32 offset = (current_cell_index - start_index);

    // Create two empty cells, one for result, one for retaining
    printf("[-]>[-]<");

    // Go back offset cells
    printf("%d<", offset);

    // While 'from' cell is non zero,
    printf("[");

    // Go forward to result and retain cells
    printf("%d>", offset);

    // Increment result and retain cells
    printf("+>+");
    
    // Go back offset to original cell
    printf("%d<", offset + 1);

    // Decrement original cell
    printf("-");

    // End while
    printf("]");

    // Go forward to result and retain cells
    printf("%d>", offset);

    // Move 'retain' cell back to original cell
    // --------------------------------------------

    // Point to 'retain' cell
    printf(">");

    // While 'retain' cell is non zero,
    printf("[");

    // Go back (offset + 1) cells
    printf("%d<", offset + 1);

    // Increment original cell
    printf("+");

    // Go forward to retain cell
    printf("%d>", (offset + 1));

    // Decrement retain cell
    printf("-");

    // End while
    printf("]");

    emit_context.current_cell_index++;
}

u0 copy_cells_static(u32 start_index, u32 size){
    for(u32 i = 0; i < size; i++){
        copy_cell_static(start_index + i);
    }
}

u0 emit_swap_u8(){
    // a b
    //     ^

    // Zero temporary cell
    printf("[-]");

    // Go to 'b' cell
    printf("<");

    // Move 'b' to temporary cell
    printf("[->+<]");

    // a 0 b
    //   ^
    
    // Go to 'a' cell
    printf("<");

    // Move 'a' cell to 'b' cell
    printf("[>+<-]");

    // Go to temporary cell
    printf(">>");

    // Move temporary cell to 'a' cell
    printf("[<<+>>-]");

    // Remain pointing at next available cell
}

u0 copy_cell_dynamic_u8_maintain(u32 start_index){
    // u8_dynamic_index
    //                  ^

    // value1 u8_dynamic_index 
    //                         ^

    dupe_cell();
    copy_cell_dynamic_u8(start_index);
    emit_swap_u8();
}

u0 copy_cell_dynamic_u16_maintain(u32 start_index){
    // minor_index major_index
    //                         ^

    // value1 minor_index major_index 
    //                                ^

    dupe_cells(2);
    copy_cell_dynamic_u16(start_index);

    // minor_index major_index value1
    //                                ^

    // Move value to be before duplicated index
    printf("[-]<[>+<-]<[>+<-]<[>+<-]3>[3<+3>-]");

    // value1 minor_index major_index 
    //                                ^
}

u0 copy_cell_dynamic_u24_maintain(u32 start_index){
    // minor_index major_index major_major_index
    //                                           ^

    // value1 minor_index major_index major_major_index
    //                                                  ^

    dupe_cells(3);
    copy_cell_dynamic_u24(start_index);

    // minor_index major_index major_major_index value1
    //                                                  ^

    // Move value to be before duplicated index
    printf("[-]<[>+<-]<[>+<-]<[>+<-]<[>+<-]4>[4<+4>-]");

    // value1 minor_index major_index major_major_index
    //                                                  ^
}

u0 copy_cell_dynamic_u32_maintain(u32 start_index){
    // minor_minor_index minor_major_index major_minor_index major_major_index
    //                                                                         ^

    // value1 minor_minor_index minor_major_index major_minor_index major_major_index
    //                                                                                ^

    dupe_cells(4);
    copy_cell_dynamic_u32(start_index);

    // minor_minor_index minor_major_index major_minor_index major_major_index value1
    //                                                                                ^

    // Move value to be before duplicated index
    printf("[-]<[>+<-]<[>+<-]<[>+<-]<[>+<-]<[>+<-]5>[5<+5>-]");

    // value1 minor_minor_index minor_major_index major_minor_index major_major_index
    //                                                                                ^
}

u0 copy_cells_dynamic_u8(u32 start_index, u32 size){
    // u8_dynamic_index
    //                  ^

    // value1 value2 value3 valueN
    //                             ^

    if(size == 0) return;

    for(u32 i = 0; i < size - 1; i++){
        copy_cell_dynamic_u8_maintain(start_index + i);
    }

    copy_cell_dynamic_u8(start_index + size - 1);
}

u0 copy_cells_dynamic_u16(u32 start_index, u32 size){
    // minor_index major_index
    //                         ^

    // value1 value2 value3 valueN
    //                             ^

    if(size == 0) return;

    for(u32 i = 0; i < size - 1; i++){
        copy_cell_dynamic_u16_maintain(start_index + i);
    }

    copy_cell_dynamic_u16(start_index + size - 1);
}

u0 copy_cells_dynamic_u24(u32 start_index, u32 size){
    // minor_index major_index major_major_index
    //                                           ^

    // value1 value2 value3 valueN
    //                             ^

    if(size == 0) return;

    for(u32 i = 0; i < size - 1; i++){
        copy_cell_dynamic_u24_maintain(start_index + i);
    }

    copy_cell_dynamic_u24(start_index + size - 1);
}

u0 copy_cells_dynamic_u32(u32 start_index, u32 size){
    // mm_index mM_index Mm_index MM_index
    //                                     ^

    // value1 value2 value3 valueN
    //                             ^

    if(size == 0) return;

    for(u32 i = 0; i < size - 1; i++){
        copy_cell_dynamic_u32_maintain(start_index + i);
    }

    copy_cell_dynamic_u32(start_index + size - 1);
}

u0 copy_cell_dynamic_u8(u32 start_index){
    if(start_index >= emit_context.current_cell_index){
        printf("\nwarning: copy_cell_dynamic_u8 failed, can only copy backwards\n");
        return;
    }

    // index
    //        ^

    // value
    //        ^

    // Go to 'index' cell
    printf("<");
    emit_context.current_cell_index--;

    u32 back_offset = emit_context.current_cell_index - start_index;

    /* Example:
        ++++++++++ +>
        ++++++++++ ++>
        ++++++++++ +++>
        ++++++++++ ++++>
        ++++++++++ +++++>
        ++++++++++ ++++++> # Memory (array of 6 cells)

        ++++ # Index (0 is leftmost and 5 is rightmost)

        # Corrupt forward memory
        >+>+>+>+>+>+>+>+>+
        <<<<<<<<<

        >[-]>[-]<< # Initialize moving window memory

        [>+>+<<-] # Create two copies of index
        >>[<<+>>-]<<

        [
          - # Decrement index
          # Move two index values forward
          >>[-] # Zero next cell
          <[>+<-] # Move second cell to right
          <[>+<-] # Move first cell to right
          >
        ]

        # Copy
        [-]>>[-]<<
        <<<<<<
        [>>>>>> + >>+<<  <<<<<<-]
        >>>>>>

        # Move second copy back into original
        >>
        [<<<<<< <<+>> >>>>>>-]

        # Go back to where index was
        <

        # While index
        [
          - # Decrement
          <
          [<+>-] # Copy left
          >
          [<+>-] # Copy left
          <
        ]
    */

    printf(">[-]>[-]<<"); // Initialize moving window memory

    printf("[>+>+<<-]"); // Create two copies of index
    printf(">>[<<+>>-]<<");

    printf("[");
      printf("-"); // Decrement index
      // Move two index values forward
      printf(">>[-]"); // Zero next cell
      printf("<[>+<-]"); // Move second cell to right
      printf("<[>+<-]"); // Move first cell to right
      printf(">");
    printf("]");

    // Copy
    printf("[-]>>[-]<<");
    printf("%d<", back_offset);
    printf("[%d>+>>+<<%d<-]", back_offset, back_offset);
    printf("%d>", back_offset);

    // Move second copy back into original
    printf(">>");
    printf("[%d<<<+>>%d>-]", back_offset, back_offset);

    // Go back to where index was
    printf("<");

    // While index
    printf("[");
      printf("-"); // Decrement
      printf("<");
      printf("[<+>-]"); // Copy left
      printf(">");
      printf("[<+>-]"); // Copy left
      printf("<");
    printf("]");

    emit_context.current_cell_index++;
}

u0 copy_cell_dynamic_u16(u32 start_index){
    if(start_index >= emit_context.current_cell_index){
        printf("\nwarning: copy_cell_dynamic_u16 failed, can only copy backwards\n");
        return;
    }

    // minor_index major_index
    //                         ^

    // value
    //       ^
    
    /*
    EXAMPLE:
        # Memory (array of 20 cells)
		++++++++++ +>
        ++++++++++ ++>
        ++++++++++ +++>
        ++++++++++ ++++>
        ++++++++++ +++++>
        ++++++++++ ++++++>
        ++++++++++ +++++++>
        ++++++++++ ++++++++>
        ++++++++++ +++++++++>
        ++++++++++ ++++++++++>
        ++++++++++ ++++++++++ +>
        ++++++++++ ++++++++++ ++>
        ++++++++++ ++++++++++ +++>
        ++++++++++ ++++++++++ ++++>
        ++++++++++ ++++++++++ +++++>
        ++++++++++ ++++++++++ ++++++>
        ++++++++++ ++++++++++ +++++++>
        ++++++++++ ++++++++++ ++++++++>
        ++++++++++ ++++++++++ +++++++++>
        ++++++++++ ++++++++++ ++++++++++>


		# Minor index
        [-]++++>
        # Major index
        [-]+>
        <

        # Corrupt forward memory
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        
        # Create copy of index
        >[-]>[-]>[-]>[-]
        <<<<
        [>>+>>+<<<<-]
        <
        [>>+>>+<<<<-]
        >>>>
        [<<<<+>>>>-]
        >
        [<<<<+>>>>-]
        
        # Go to major index of first index pair
        <<<<
        
        [
        	-
            
            # Go to minor index of first pair
            <
            
            # Copy forward
            >>>>>>>>>>
            [-]>[-]>[-]>[-]>
            <<<<<<<<<<
            <[>>>>>>>>>>+<<<<<<<<<<-]
            <[>>>>>>>>>>+<<<<<<<<<<-]
            <[>>>>>>>>>>+<<<<<<<<<<-]
            <[>>>>>>>>>>+<<<<<<<<<<-]
            >
            >>>>>>>>>>
        ]
        
        # Go to minor index
        <
        
        # Go forward by minor index
        [
        	-
            >>>>[-]
            <[>+<-]
            <[>+<-]
            <[>+<-]
            <[>+<-]
            >
        ]
        
        # Move data to make two copies
        <<<<<<<<<<
        <<<<<<<<<<
        [
        	>>>>>>>>>>
            >>>>>>>>>>
            +>+<
            <<<<<<<<<<
            <<<<<<<<<<
            -
        ]
        >>>>>>>>>>
        >>>>>>>>>>
        
        >
        
        # Move second data copy back
        [
        	<
        	<<<<<<<<<<
            <<<<<<<<<<
            +
            >>>>>>>>>>
            >>>>>>>>>>
            >
            -
        ]
        
        # Go to minor index
        >
        
        # Go backwards by minor index
        [
        	-
            <<
            [<+>-]>
            >
            [<+>-]>
            [<+>-]
            <<
        ]
        
        # Go to major index
        >
        
        # Go backwards by 256 (10 in example) times minor index
        [
        	-
        	[<<<<<<<<<<+>>>>>>>>>>-]
            <<<
            [<<<<<<<<<<+>>>>>>>>>>-]
            >>>
            <<<<<<<<<<
        ]
        
        # Point to next cell
        <<
        */

    // Go to 'index' cell
    printf("<");
    emit_context.current_cell_index--;

    u32 back_offset = emit_context.current_cell_index - start_index - 1;

    // Create copy of index
    printf(">[-]>[-]>[-]>[-]");
    printf("<<<<");
    printf("[>>+>>+<<<<-]");
    printf("<");
    printf("[>>+>>+<<<<-]");
    printf(">>>>");
    printf("[<<<<+>>>>-]");
    printf(">");
    printf("[<<<<+>>>>-]");
    
    // Go to major index of first index pair
    printf("<<<<");
    
    printf("[");
        printf("-");
        
        // Go to minor index of first pair
        printf("<");
        
        // Copy forward
        printf("256>");
        printf("[-]>[-]>[-]>[-]>");
        printf("256<");
        printf("<[256>+256<-]");
        printf("<[256>+256<-]");
        printf("<[256>+256<-]");
        printf("<[256>+256<-]");
        printf(">");
        printf("256>");
    printf("]");
    
    // Go to minor index
    printf("<");
    
    // Go forward by minor index
    printf("[");
        printf("-");
        printf(">>>>[-]");
        printf("<[>+<-]");
        printf("<[>+<-]");
        printf("<[>+<-]");
        printf("<[>+<-]");
        printf(">");
    printf("]");
    
    // Move data to make two copies
    printf("%d<", back_offset);
    printf("[");
        printf("%d>", back_offset);
        printf("+>+<");
        printf("%d<", back_offset);
        printf("-");
    printf("]");
    printf("%d>", back_offset);
    
    printf(">");
    
    // Move second data copy back
    printf("[");
        printf("<");
        printf("%d<", back_offset);
        printf("+");
        printf("%d>", back_offset);
        printf(">");
        printf("-");
    printf("]");
    
    // Go to minor index
    printf(">");
    
    printf("[");
        printf("-");
        printf("<<");
        printf("[<+>-]>");
        printf(">");
        printf("[<+>-]>");
        printf("[<+>-]");
        printf("<<");
    printf("]");
    
    // Go to major index
    printf(">");
    
    // Go backwards by 256 times minor index
    printf("[");
        printf("-");
        printf("[256<+256>-]");
        printf("<<<");
        printf("[256<+256>-]");
        printf(">>>");
        printf("256<");
    printf("]");
    
    // Point to next cell
    printf("<<");

    // No further changes to `emit_context.current_cell_index`
}

u0 copy_cell_dynamic_u24(u32 start_index){
    if(start_index >= emit_context.current_cell_index){
        printf("\nwarning: copy_cell_dynamic_u24 failed, can only copy backwards\n");
        return;
    }
    
    // minor_index major_index major_major_index
    //                                           ^

    // value
    //       ^
    
    // Extend to u32
    printf("[-]>");
    emit_context.current_cell_index++;

    // Perform u32 version
    copy_cell_dynamic_u32(start_index);
}

u0 copy_cell_dynamic_u32(u32 start_index){
    if(start_index >= emit_context.current_cell_index){
        printf("\nwarning: copy_cell_dynamic_u32 failed, can only copy backwards\n");
        return;
    }
    
    // minor_minor_index minor_major_index major_minor_index major_major_index
    //                                                                         ^
    
    // value
    //       ^

    /*
        EXAMPLE:
        
        # Memory (array of 40 cells)
        ++++++++++ +>
        ++++++++++ ++>
        ++++++++++ +++>
        ++++++++++ ++++>
        ++++++++++ +++++>
        ++++++++++ ++++++>
        ++++++++++ +++++++>
        ++++++++++ ++++++++>
        ++++++++++ +++++++++>
        ++++++++++ ++++++++++>
        ++++++++++ ++++++++++ +>
        ++++++++++ ++++++++++ ++>
        ++++++++++ ++++++++++ +++>
        ++++++++++ ++++++++++ ++++>
        ++++++++++ ++++++++++ +++++>
        ++++++++++ ++++++++++ ++++++>
        ++++++++++ ++++++++++ +++++++>
        ++++++++++ ++++++++++ ++++++++>
        ++++++++++ ++++++++++ +++++++++>
        ++++++++++ ++++++++++ ++++++++++>
        ++++++++++ ++++++++++ ++++++++++ +>
        ++++++++++ ++++++++++ ++++++++++ ++>
        ++++++++++ ++++++++++ ++++++++++ +++>
        ++++++++++ ++++++++++ ++++++++++ ++++>
        ++++++++++ ++++++++++ ++++++++++ +++++>
        ++++++++++ ++++++++++ ++++++++++ ++++++>
        ++++++++++ ++++++++++ ++++++++++ +++++++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++>
        ++++++++++ ++++++++++ ++++++++++ +++++++++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++ +>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++ ++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++ +++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++>
        +++++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++ +++++++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++ +++++++++>
        ++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++>

        # minor minor index
        [-]++++>
        # minor major index
        [-]+>
        # major minor index
        [-]+>
        # major major index
        [-]+>
        <

        # Corrupt forward memory
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        >+>+>+>+>+>+>+>+>+
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<
        <<<<<<<<<

        # Create copy of index
        >[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>
        <<<<<<<< <<<<

        [>>>>+>>>>+<<<<<<<<-]>
        [>>>>+>>>>+<<<<<<<<-]>
        [>>>>+>>>>+<<<<<<<<-]>
        [>>>>+>>>>+<<<<<<<<-]>
        >>>>
        [<<<<<<<<+>>>>>>>>-]>
        [<<<<<<<<+>>>>>>>>-]>
        [<<<<<<<<+>>>>>>>>-]>
        [<<<<<<<<+>>>>>>>>-]>
        <<<<<<<<<<<<

        # Go to major major index
        >>>

        [
          -
          <<<
          
          >>>>>>>>>>
          [-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>
          <<<<<<<<
          <<<<<<<<<<
          
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          <<<<<<<<
          >>>>>>>>>>
          >>>
        ]

        # Go to major minor index
        <

        [
          -
          <<
          
          >>>>>>>>>>
          [-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>
          <<<<<<<<
          <<<<<<<<<<
          
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          <<<<<<<<
          >>>>>>>>>>
          >>
        ]

        # Go to minor major index
        <

        [
          -
          <
          
          >>>>>>>>>>
          [-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>
          <<<<<<<<
          <<<<<<<<<<
          
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          [>>>>>>>>>>+<<<<<<<<<<-]>
          <<<<<<<<
          >>>>>>>>>>
          >
        ]

        # Go to minor minor index
        <

        [
          -
          >>>>>>>>[-]
          <[>+<-]
          <[>+<-]
          <[>+<-]
          <[>+<-]
          <[>+<-]
          <[>+<-]
          <[>+<-]
          <[>+<-]
          >
        ]

        # Move dupe from location
        <<<<<<<<<< <<<<<<<<<< <<<<<<<<<< <<<<<<<<<<
        [
        -
        >>>>>>>>>> >>>>>>>>>> >>>>>>>>>> >>>>>>>>>>
        +>+<
        <<<<<<<<<< <<<<<<<<<< <<<<<<<<<< <<<<<<<<<<
        ]
        >>>>>>>>>> >>>>>>>>>> >>>>>>>>>> >>>>>>>>>>

        # Go to second copy
        >

        # Move second copy back to original location
        [
          -<
          <<<<<<<<<< <<<<<<<<<< <<<<<<<<<< <<<<<<<<<<
          +>
          >>>>>>>>>> >>>>>>>>>> >>>>>>>>>> >>>>>>>>>>
        ]

        # Go to index copy
        >>>


        [<<<+>>>-]>
        [<<<+>>>-]>
        [<<<+>>>-]>
        [<<<+>>>-]>
        <<<<<<<

        # Reverse minor minor index
        [
          -
          <
          [<+>-]>
          [<+>-]>
          [<+>-]>
          [<+>-]>
          [<+>-]>
          <<<<<
        ]

        # Go to minor major index
        >

        # Reverse minor major index
        [
          -
          <<
          [<<<<<<<<<<+>>>>>>>>>>-]>
          >
          [<<<<<<<<<<+>>>>>>>>>>-]>
          [<<<<<<<<<<+>>>>>>>>>>-]>
          [<<<<<<<<<<+>>>>>>>>>>-]>
          <<<<<
          <<<<<<<<<<
          >>
        ]

        # Go to major minor index
        >

        # Reverse major minor index
        [
          -
          <<<
          [<<<<<<<<<<+>>>>>>>>>>-]>
          >
          >
          [<<<<<<<<<<+>>>>>>>>>>-]>
          [<<<<<<<<<<+>>>>>>>>>>-]>
          <<<<<
          <<<<<<<<<<
          >>>
        ]

        # Go to major major index
        >

        # Reverse major major index
        [
          -
          <<<<
          [<<<<<<<<<<+>>>>>>>>>>-]>
          >
          >
          >
          [<<<<<<<<<<+>>>>>>>>>>-]>
          <<<<<
          <<<<<<<<<<
          >>>>
        ]

        <<<
    */

    u32 back_offset = emit_context.current_cell_index - start_index - 4;

    // Create copy of index
    printf("[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>");
    printf("12<");

    printf("[4>+4>+8<-]>");
    printf("[4>+4>+8<-]>");
    printf("[4>+4>+8<-]>");
    printf("[4>+4>+8<-]>");
    printf("4>");
    printf("[8<+8>-]>");
    printf("[8<+8>-]>");
    printf("[8<+8>-]>");
    printf("[8<+8>-]>");
    printf("12<");

    // Go to major major index
    printf("3>");

    printf("[");
      printf("-");
      printf("3<");
      
      printf("16777216>");
      printf("[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>");
      printf("8<");
      printf("16777216<");
      
      printf("[16777216>+16777216<-]>");
      printf("[16777216>+16777216<-]>");
      printf("[16777216>+16777216<-]>");
      printf("[16777216>+16777216<-]>");
      printf("[16777216>+16777216<-]>");
      printf("[16777216>+16777216<-]>");
      printf("[16777216>+16777216<-]>");
      printf("[16777216>+16777216<-]>");
      printf("8<");
      printf("16777216>");
      printf("3>");
    printf("]");

    // Go to major minor index
    printf("<");

    printf("[");
      printf("-");
      printf("2<");
      
      printf("65536>");
      printf("[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>");
      printf("8<");
      printf("65536<");
      
      printf("[65536>+65536<-]>");
      printf("[65536>+65536<-]>");
      printf("[65536>+65536<-]>");
      printf("[65536>+65536<-]>");
      printf("[65536>+65536<-]>");
      printf("[65536>+65536<-]>");
      printf("[65536>+65536<-]>");
      printf("[65536>+65536<-]>");
      printf("8<");
      printf("65536>");
      printf("2>");
    printf("]");

    // Go to minor major index
    printf("<");

    printf("[");
      printf("-");
      printf("<");
      
      printf("256>");
      printf("[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>");
      printf("8<");
      printf("256<");
      
      printf("[256>+256<-]>");
      printf("[256>+256<-]>");
      printf("[256>+256<-]>");
      printf("[256>+256<-]>");
      printf("[256>+256<-]>");
      printf("[256>+256<-]>");
      printf("[256>+256<-]>");
      printf("[256>+256<-]>");
      printf("8<");
      printf("256>");
      printf(">");
    printf("]");

    // Go to minor minor index
    printf("<");

    printf("[");
      printf("-");
      printf("8>[-]");
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf(">");
    printf("]");

    // Move dupe from location
    printf("%d<", back_offset);
    printf("[");
        printf("-");
        printf("%d>", back_offset);
        printf("+>+<");
        printf("%d<", back_offset);
    printf("]");
    printf("%d>", back_offset);

    // Go to second copy
    printf(">");

    // Move second copy back to original location
    printf("[");
      printf("-<");
      printf("%d<", back_offset);
      printf("+>");
      printf("%d>", back_offset);
    printf("]");

    // Go to index copy
    printf("3>");

    printf("[3<+3>-]>");
    printf("[3<+3>-]>");
    printf("[3<+3>-]>");
    printf("[3<+3>-]>");
    printf("7<");

    // Reverse minor minor index
    printf("[");
      printf("-");
      printf("<");
      printf("[<+>-]>");
      printf("[<+>-]>");
      printf("[<+>-]>");
      printf("[<+>-]>");
      printf("[<+>-]>");
      printf("5<");
    printf("]");

    // Go to minor major index
    printf(">");

    // Reverse minor major index
    printf("[");
      printf("-");
      printf("2<");
      printf("[256<+256>-]>");
      printf(">");
      printf("[256<+256>-]>");
      printf("[256<+256>-]>");
      printf("[256<+256>-]>");
      printf("5<");
      printf("256<");
      printf("2>");
    printf("]");

    // Go to major minor index
    printf(">");

    // Reverse major minor index
    printf("[");
      printf("-");
      printf("3<");
      printf("[65536<+65536>-]>");
      printf("2>");
      printf("[65536<+65536>-]>");
      printf("[65536<+65536>-]>");
      printf("5<");
      printf("65536<");
      printf("3>");
    printf("]");

    // Go to major major index
    printf(">");

    // Reverse major major index
    printf("[");
      printf("-");
      printf("4<");
      printf("[16777216<+16777216>-]>");
      printf("3>");
      printf("[16777216<+16777216>-]>");
      printf("5<");
      printf("16777216<");
      printf("4>");
    printf("]");

    printf("3<");
    emit_context.current_cell_index -= 3;
}

u0 move_cell_static(u32 destination_index){
    u32 current_cell_index = emit_context.current_cell_index;
    u32 offset;
    u8 towards;
    u8 backwards;

    if(destination_index <= current_cell_index){
        offset = current_cell_index - destination_index;
        towards = '<';
        backwards = '>';
    } else {
        offset = destination_index - current_cell_index;
        towards = '>';
        backwards = '<';
    }

    // Zero destination cell
    printf("%d%c", offset, towards);
    printf("[-]");
    printf("%d%c", offset, backwards);

    // While source cell is non-zero
    printf("[");

    // Go backwards to destination
    printf("%d%c", offset, towards);

    // Increment destination cell
    printf("+");

    // Go forwards to source
    printf("%d%c", offset, backwards);

    // Decrement source cell
    printf("-");

    // End while
    printf("]");
}

u0 move_cells_static(u32 destination_index, u32 size){
    // data1 data2 data3 data4
    //                     ^

    // ?
    // ^

    for(u32 i = 0; i < size; i++){
        move_cell_static(destination_index + size - i - 1);

        if(i + 1 < size){
            printf("<");
            emit_context.current_cell_index--;
        }
    }
}

u0 move_cell_dynamic_u8(u32 destination_start_index){
    if(destination_start_index >= emit_context.current_cell_index){
        printf("\nwarning: move_cell_dynamic_u8 failed, can only move backwards\n");
        return;
    }

    u32 back_offset = emit_context.current_cell_index - destination_start_index - 1;

    // value index
    //         ^

    // index
    //   ^

    /* Example:
        >>>>>> # Memory (array of 6 cells)
        ++++++++++> # Value (value that we want to write to the array)
        +++++ # Index (0 is leftmost and 5 is rightmost)
        >[-]>[-]>[-]<<< # Initialize moving window memory
        [>+>+>+<<<-] # Create three copies of index
        >>>[<<<+>>>-]<<< # Move third copy of index back to original location
        [ # While non zero index
        - # Decrement index
            # Move three index values forward
            >>>[-] # Zero next cell
            <[>+<-] # Move third cell to right
            <[>+<-] # Move second cell to right
            <[>+<-] # Move first cell to right
            <[>+<-] # Move value cell to right
            >>
        ]
        < # Point to value
        # Move value to destination
        <<<<<<[-]>>>>>>
        [<<<<<<+>>>>>>-]
        # Go back to where index was
        # Move index copy left
        >>>[<<+>>-]<<
        # Go left that amount
        [
            - # Decrement
            [<+>-] # Copy left
            >
            [<+>-] # Copy left index retainer cell
            << # Point to new index
        ]
        > # Point to offset retained index cell
        [<<+>>-] # Copy to replace cell that was moved
        << # Point to retained index cell
    */

    printf(">[-]>[-]>[-]3<"); // Initialize moving window memory

    printf("[>+>+>+<<<-]"); // Create three copies of index

    printf(">>>[<<<+>>>-]<<<"); // Move third copy of index back to original location

    printf("["); // While non zero index
        printf("-"); // Decrement index
        // Move three index values forward
        printf(">>>[-]"); // Zero next cell
        printf("<[>+<-]"); // Move third cell to right
        printf("<[>+<-]"); // Move second cell to right
        printf("<[>+<-]"); // Move first cell to right
        printf("<[>+<-]"); // Move value cell to right
        printf(">>");
    printf("]");

    printf("<"); // Point to value
    printf("%d<[-]%d>", back_offset, back_offset); // Move value to destination
    printf("[%d<+%d>-]", back_offset, back_offset); // Go back to where index was
    printf(">>>[<<+>>-]<<"); // Move index copy left

    // Go left that amount
    printf("[");
        printf("-"); // Decrement
        printf("[<+>-]"); // Copy left
        printf(">");
        printf("[<+>-]"); // Copy left index retainer cell
        printf("<<"); // Point to new index
    printf("]");

    printf(">"); // Point to offset retained index cell
    printf("[<<+>>-]"); // Copy to replace cell that was moved
    printf("<<"); // Point to retained index cell

    emit_context.current_cell_index--;
}

u0 move_cell_dynamic_u16(u32 destination_start_index){
    if(destination_start_index >= emit_context.current_cell_index){
        printf("\nwarning: move_cell_dynamic_u16 failed, can only move backwards\n");
        return;
    }

    u32 back_offset = emit_context.current_cell_index - destination_start_index - 2;

    // value index_minor index_major
    //                        ^

    // index_minor index_major
    //      ^

    /* Example:
        # Garble memory
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<

 		>>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>> # Memory (array of 50 cells)
        +++++++++++++> # Value (value that we want to write to the array)
        [-]+++++>[-]++++> # Index little endian
        
        # Initialize moving window memory
        [-]>[-]>[-]>[-]>[-]>[-]>[-]<<<<<<
        
        # Go to minor index
        << 
        
         # Create three copies of index
        [>>+>>+>>+<<<<<<-]
        >[>>+>>+>>+<<<<<<-]
        
        # Move data here
        <<[>>+<<-]
        
        # Move third copy here
        >>>>>>>>
        [<<<<<<<+>>>>>>>-]
        <
        [<<<<<<<+>>>>>>>-]
        
        # Point to major index
        <<<
        
        [ # While non zero major index
        - # Decrement index
            # Move forward
            <
            >>>>>>>>>>
            <
            [-]>[-]>[-]>[-]>[-]> # Zero destination
            >
            <
            <<<<<<<<<<
            <[>>>>>>>>>>+<<<<<<<<<<-]
            <[>>>>>>>>>>+<<<<<<<<<<-]
            <[>>>>>>>>>>+<<<<<<<<<<-]
            <[>>>>>>>>>>+<<<<<<<<<<-]
            <[>>>>>>>>>>+<<<<<<<<<<-]
            >>>>>>>>>>
            >>
        ]
        
        # Go to minor cell
        <
       
        [ # While non zero major index
        - # Decrement index
            # Move three index values forward
            <
            >>>>>
            [-]> # Zero destination
            <
            <[>+<-]
            <[>+<-]
            <[>+<-]
            <[>+<-]
            <[>+<-]
            >
            >
        ]
        
        <
        
        # Move into place
        << # Account for duped index offset
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        [-]
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >> # Account for duped index offset
        [
        << # Account for duped index offset
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        +
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >> # Account for duped index offset
        -
        ]
        
        # Copy second copy of index to index position
        >>>
        [<<<+>>>-]
        >
        [<<<+>>>-]
        <<<
        
        # Go to minor index
        <
        
        [-
        	[<+>-]
            >
            [<+>-]
            <<
        ]
        
        # Go to major index
        >
        
        [-
        	[
            <<<<<<<<<<+>>>>>>>>>>-
            ]
            <<<<<<<<<<
        ]
        
        # To back to zeroed minor index
        <
        
        # Point to next available cell (left over duped index which can be used again)
        <<
    */

    // Initialize moving window memory
    printf(">[-]>[-]>[-]>[-]>[-]>[-]>[-]");
    printf("6<");
    
    // Go to minor index
    printf("<<");
    
    // Create three copies of index
    printf("[>>+>>+>>+6<-]");
    printf(">");
    printf("[>>+>>+>>+6<-]");
    
    // Go to data cell
    printf("<<");

    // Move data cell to third cell
    printf("[>>+<<-]");
    
    // Move third copy of index to first two cells
    printf("8>");
    printf("[7<+7>-]");
    printf("<");
    printf("[7<+7>-]");
    
    // Point to major index
    printf("3<");

    // While non zero major index
    printf("[");
        // Decrement index
        printf("-");

        // Move forward
        printf("<");
        printf("256>");
        printf("<");
        printf("[-]>[-]>[-]>[-]>[-]>"); // Zero destination
        printf("256<");
        printf("<[256>+256<-]");
        printf("<[256>+256<-]");
        printf("<[256>+256<-]");
        printf("<[256>+256<-]");
        printf("<[256>+256<-]");
        printf("256>");
        printf(">>");
    printf("]");
    
    // Go to minor cell
    printf("<");
   
    // While non zero major index
    printf("[");

        // Decrement index
        printf("-");

        // Move three index values forward
        printf("4>");
        printf("[-]"); // Zero destination
        printf("<[>+<-]");
        printf("<[>+<-]");
        printf("<[>+<-]");
        printf("<[>+<-]");
        printf("<[>+<-]");
        printf(">>");
    printf("]");
    
    // Go to data cell
    printf("<");
    
    // Move into place
    printf("%d<[-]%d>[%d<+%d>-]", 2 + back_offset, 2 + back_offset, 2 + back_offset, 2 + back_offset); // Account for duped index offset
    
    // Copy second copy of index to index position
    printf("3>");
    printf("[3<+3>-]");
    printf(">");
    printf("[3<+3>-]");
    printf("3<");
    
    // Go to minor index
    printf("<");
    
    // Go backwards by minor index
    printf("[");
        printf("-");
        printf("[<+>-]");
        printf(">");
        printf("[<+>-]");
        printf("<<");
    printf("]");
    
    // Go to major index
    printf(">");
    
    // Go backwards by 256 times major index
    printf("[");
        printf("-");
        printf("[256<+256>-]");
        printf("256<");
    printf("]");
    
    // To back to zeroed minor index
    printf("<");
    
    // Point to next available cell (left over duped index which can be used again)
    printf("<<");

    emit_context.current_cell_index -= 2;
}

u0 move_cell_dynamic_u24(u32 destination_start_index){
    // value index_minor index_major index_major_major
    //                                       ^

    // index_minor index_major index_major_major
    //      ^

    if(destination_start_index >= emit_context.current_cell_index){
        printf("\nwarning: move_cell_dynamic_u16 failed, can only move backwards\n");
        return;
    }

    // Extend to u32
    printf("[-]>");
    emit_context.current_cell_index++;

    // Perform u32 version
    move_cell_dynamic_u32(destination_start_index);
}

u0 move_cell_dynamic_u32(u32 destination_start_index){
    // value minor_minor_index minor_major_index major_minor_index major_major_index
    //                                                                     ^

    // minor_minor_index minor_major_index major_minor_index major_major_index
    //         ^

    u32 back_offset = emit_context.current_cell_index - destination_start_index;

    /*
        EXAMPLE:
        
        # Garble
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>

        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>

        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>
        +>+>+>+>+>+>+>+>+>+>

        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<

        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<

        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<

        # Memory (array of 100 cells)
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>


        [-]+++++++++++++> # Value (value that we want to write to the array)
        [-]++++>[-]+++>[-]++>[-]+> # Index little endian

        # From layout (value) (index)
        # Setup with layout (index) (value) (index copy) (index copy)

        [-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>
        <<<<<<<<<<<<

        [-]<<<<<[>>>>>+<<<<<-]
        >[<+>-]
        >[<+>-]
        >[<+>-]
        >[<+>-]
        >[<+>-]

        <<<<<
        [>>>>>+>>>>+>>>>+<<<<<<<<<<<<<-]
        >[>>>>>+>>>>+>>>>+<<<<<<<<<<<<<-]
        >[>>>>>+>>>>+>>>>+<<<<<<<<<<<<<-]
        >[>>>>>+>>>>+>>>>+<<<<<<<<<<<<<-]

        >>>>>>>>>>>>>
        [<<<<<<<<<<<<<+>>>>>>>>>>>>>-]
        <[<<<<<<<<<<<<<+>>>>>>>>>>>>>-]
        <[<<<<<<<<<<<<<+>>>>>>>>>>>>>-]
        <[<<<<<<<<<<<<<+>>>>>>>>>>>>>-]

        <<<<<<<<<

        # Point to major major index
        >>>>
        # (value) mm mM Mm MM mmcopy mMcopy Mmcopy MMcopy
        #                  ^

        # While major major index
        [
          -          # Decrement
          <<<<       # Go to start of moving block
          
          # Prezero forward moving block destination
          >>>>>>>>>>
          [-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>
          <<<<<<<<<
          <<<<<<<<<<
          
          # Copy forward  
          [>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          
          <<<<<<<<< # Size of block
          >>>>>>>>>>
          >>>>>
        ]

        # Go to major minor index
        <

        # While major minor index
        [
          -         # Decrement
          <<<       # Go to start of moving block
          
          # Prezero forward moving block destination
          >>>>>>>>>>
          [-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>
          <<<<<<<<<
          <<<<<<<<<<
          
          # Copy forward  
          [>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          
          <<<<<<<<< # Size of block
          >>>>>>>>>>
          >>>>
        ]


        # Go to minor major index
        <

        # While minor major index
        [
          -        # Decrement
          <<       # Go to start of moving block
          
          # Prezero forward moving block destination
          >>>>>>>>>>
          [-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>
          <<<<<<<<<
          <<<<<<<<<<
          
          # Copy forward  
          [>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          >[>>>>>>>>>>+<<<<<<<<<<-]
          
          <<<<<<<<< # Size of block
          >>>>>>>>>>
          >>>
        ]

        # Go to minor minor index
        <

        # (value) mm 00 00 00 mmcopy mMcopy Mmcopy MMcopy
        #         ^

        # While minor minor index
        [
          -
          # Go to next empty cell
          >>>>>>>>
          
          # Zero
          [-]
          
          # Copy right
          <[>+<-]
          <[>+<-]
          <[>+<-]
          <[>+<-]
          <<<
          <[>+<-]
          <[>+<-]
          
          # Go to minor minor index
          >>
        ]

        <
        # Offset plus 4 for dupliated index
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<<<<<<<
        <<<<
        [-]
        >>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        >>>>>>>>>>
        # Move
        [
          <<<<<<<<<<
          <<<<<<<<<<
          <<<<<<<<<<
          <<<<<<<<<<
          <<<<<<<<<<
          <<<<<<<<<<
          <<<<<<<<<<
          <<<<<<<<<<
          <<<<<<<<<<
          <<<<<<<<<<
          <<<<
          +
          >>>>
          >>>>>>>>>>
          >>>>>>>>>>
          >>>>>>>>>>
          >>>>>>>>>>
          >>>>>>>>>>
          >>>>>>>>>>
          >>>>>>>>>>
          >>>>>>>>>>
          >>>>>>>>>>
          >>>>>>>>>>
          -
        ]

        # Copy index backward
        >>>>>
        [<<<<<+>>>>>-]
        >[<<<<<+>>>>>-]
        >[<<<<<+>>>>>-]
        >[<<<<<+>>>>>-]
        <<<<<<<<

        # Reverse minor minor index

        [
          -
          <[-]
          >[<+>-]
          >[<+>-]
          >[<+>-]
          >[<+>-]
          <<<<
        ]

        # 00 mM Mm MM
        # ^

        >

        # Reverse minor major index
        # 00 mM Mm MM
        #    ^
        [
          -
          [<<<<<<<<<<+>>>>>>>>>>-]
          >[<<<<<<<<<<+>>>>>>>>>>-]
          >[<<<<<<<<<<+>>>>>>>>>>-]
          <<
          <<<<<<<<<<
        ]

        # Go to major minor index
        >

        # Reverse minor major index
        # 00 00 Mm MM
        #       ^
        [
          -
          [<<<<<<<<<<+>>>>>>>>>>-]
          >[<<<<<<<<<<+>>>>>>>>>>-]
          <
          <<<<<<<<<<
        ]

        # Go to major major index
        >

        # Reverse major major index
        # 00 00 00 MM
        #          ^
        [
          -
          [<<<<<<<<<<+>>>>>>>>>>-]
          <<<<<<<<<<
        ]

        # Point to first cell of preserved index
        <<<<<<<
    */

    // value minor_minor_index minor_major_index major_minor_index major_major_index
    //                                                                     ^

    // From layout (value) (index)
    // Setup with layout (index) (value) (index copy) (index copy)

    printf(">[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>");
    printf("12<");

    //printf(">");
    printf("[-]5<[5>+5<-]");
    printf(">[<+>-]");
    printf(">[<+>-]");
    printf(">[<+>-]");
    printf(">[<+>-]");
    printf(">[<+>-]");

    printf("5<");
    printf("[5>+4>+4>+13<-]");
    printf(">[5>+4>+4>+13<-]");
    printf(">[5>+4>+4>+13<-]");
    printf(">[5>+4>+4>+13<-]");

    printf("13>");
    printf("[13<+13>-]");
    printf("<[13<+13>-]");
    printf("<[13<+13>-]");
    printf("<[13<+13>-]");

    printf("9<");

    // Point to major major index
    printf("4>");
    // (value) mm mM Mm MM mmcopy mMcopy Mmcopy MMcopy
    //                  ^

    // While major major index
    printf("[");
      printf("-");        // Decrement
      printf("4<");       // Go to start of moving block
      
      // Prezero forward moving block destination
      printf("16777216>");
      printf("[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>");
      printf("9<");
      printf("16777216<");
      
      // Copy forward  
      printf("[16777216>+16777216<-]");
      printf(">[16777216>+16777216<-]");
      printf(">[16777216>+16777216<-]");
      printf(">[16777216>+16777216<-]");
      printf(">[16777216>+16777216<-]");
      printf(">[16777216>+16777216<-]");
      printf(">[16777216>+16777216<-]");
      printf(">[16777216>+16777216<-]");
      printf(">[16777216>+16777216<-]");

      printf("9<"); // Size of block
      printf("16777216>");
      printf("5<");
    printf("]");

    // Go to major minor index
    printf("<");

    // While major minor index
    printf("[");
      printf("-");    // Decrement
      printf("3<");   // Go to start of moving block
      
      // Prezero forward moving block destination
      printf("65536>");
      printf("[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>");
      printf("9<");
      printf("65536<");
      
      // Copy forward  
      printf("[65536>+65536<-]");
      printf(">[65536>+65536<-]");
      printf(">[65536>+65536<-]");
      printf(">[65536>+65536<-]");
      printf(">[65536>+65536<-]");
      printf(">[65536>+65536<-]");
      printf(">[65536>+65536<-]");
      printf(">[65536>+65536<-]");
      printf(">[65536>+65536<-]");
      
      printf("9<"); // Size of block
      printf("65536>");
      printf("4>");
    printf("]");

    // Go to minor major index
    printf("<");

    // While minor major index
    printf("[");
      printf("-");    // Decrement
      printf("<<");   // Go to start of moving block
      
      // Prezero forward moving block destination
      printf("256>");
      printf("[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>");
      printf("9<");
      printf("256<");
      
      // Copy forward  
      printf("[256>+256<-]");
      printf(">[256>+256<-]");
      printf(">[256>+256<-]");
      printf(">[256>+256<-]");
      printf(">[256>+256<-]");
      printf(">[256>+256<-]");
      printf(">[256>+256<-]");
      printf(">[256>+256<-]");
      printf(">[256>+256<-]");
      
      printf("9<"); // Size of block
      printf("256>");
      printf("3>");
    printf("]");

    // Go to minor minor index
    printf("<");

    // (value) mm 00 00 00 mmcopy mMcopy Mmcopy MMcopy
    //         ^

    // While minor minor index
    printf("[");
      printf("-");
      // Go to next empty cell
      printf("8>");
      
      // Zero
      printf("[-]");
      
      // Copy right
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf("<[>+<-]");
      printf("3<");
      printf("<[>+<-]");
      printf("<[>+<-]");
      
      // Go to minor minor index
      printf("2>");
    printf("]");

    printf("<");
    printf("%d<", back_offset);
    printf("[-]");
    printf("%d>", back_offset);

    // Move
    printf("[");
      printf("%d<", back_offset);
      printf("+");
      printf("%d>", back_offset);
      printf("-");
    printf("]");

    // Copy index backward
    printf("5>");
    printf("[5<+5>-]");
    printf(">[5<+5>-]");
    printf(">[5<+5>-]");
    printf(">[5<+5>-]");
    printf("8<");

    // Reverse minor minor index

    printf("[");
      printf("-");
      printf("<[-]");
      printf(">[<+>-]");
      printf(">[<+>-]");
      printf(">[<+>-]");
      printf(">[<+>-]");
      printf("4<");
    printf("]");

    // 00 mM Mm MM
    // ^

    printf(">");

    // Reverse minor major index
    // 00 mM Mm MM
    //    ^
    printf("[");
      printf("-");
      printf("[256<+256>-]");
      printf(">[256<+256>-]");
      printf(">[256<+256>-]");
      printf("2<");
      printf("256<");
    printf("]");

    // Go to major minor index
    printf(">");

    // Reverse minor major index
    // 00 00 Mm MM
    //       ^
    printf("[");
      printf("-");
      printf("[65536<+65536>-]");
      printf(">[65536<+65536>-]");
      printf("<");
      printf("65536<");
    printf("]");

    // Go to major major index
    printf(">");

    // Reverse major major index
    // 00 00 00 MM
    //          ^
    printf("[");
      printf("-");
      printf("[16777216<+16777216>-]");
      printf("16777216<");
    printf("]");

    // Point to first cell of preserved index
    printf("7<");

    emit_context.current_cell_index -= 4;
}

u0 move_cells_dynamic_u8(u32 destination_index, u32 size){
    // value1 value2 value3 index
    //                        ^

    // index
    //   ^

    for(u32 i = 0; i < size; i++){
        move_cell_dynamic_u8(destination_index + size - 1 - i);
    }
}

u0 move_cells_dynamic_u16(u32 destination_index, u32 size){
    // value1 value2 value3 minor_index major_index
    //                                       ^

    // minor_index major_index
    //      ^

    for(u32 i = 0; i < size; i++){
        move_cell_dynamic_u16(destination_index + size - 1 - i);

        if(i + 1 != size){
            printf(">");
            emit_context.current_cell_index++;
        }
    }
}

u0 move_cells_dynamic_u24(u32 destination_index, u32 size){
    // value1 value2 value3 minor_index major_index major_major_index
    //                                                      ^

    // minor_index major_index major_major_index
    //      ^

    for(u32 i = 0; i < size; i++){
        move_cell_dynamic_u24(destination_index + size - 1 - i);

        if(i + 1 != size){
            printf("2>");
            emit_context.current_cell_index += 2;
        }
    }
}

u0 move_cells_dynamic_u32(u32 destination_index, u32 size){
    // value1 value2 value3 minor_minor_index minor_major_index major_minor_index major_major_index
    //                                                                                    ^

    // minor_minor_index minor_major_index major_minor_index major_major_index
    //      ^

    for(u32 i = 0; i < size; i++){
        move_cell_dynamic_u32(destination_index + size - 1 - i);

        if(i + 1 != size){
            printf("3>");
            emit_context.current_cell_index += 3;
        }
    }
}

u0 print_cells_static(u32 start_index, u32 max_length){
    u32 current_cell_index = emit_context.current_cell_index;

    if(start_index >= current_cell_index){
        printf("\nwarning: print_cells_static cannot print cells that are in front of current cell index\n");
        return;
    }

    u32 back_offset = (current_cell_index - start_index);

    /* EXAMPLE:
        ++++++++++ ++++++++++ ++++++++++
        ++++++++++ ++++++++++ ++++++++++ 
        ++++++++++ >
        ++++++++++ ++++++++++ ++++++++++
        ++++++++++ ++++++++++ ++++++++++ 
        ++++++++++ +>
        ++++++++++ ++++++++++ ++++++++++
        ++++++++++ ++++++++++ ++++++++++ 
        ++++++++++ ++>
        ++++++++++ ++++++++++ ++++++++++
        ++++++++++ ++++++++++ ++++++++++ 
        ++++++++++ +++>

        +++++> # Example value being used by something else

        +> # Have at least one cell between referenced value
             # and ourselves so that there can be a cell
             # that we will temporarily set to zero

        # Go to first character
        <<<< <<

        [>>>> >>+<< <<<<-]>>>> >> # Move first character to first slot
        >
        <<< <<<< >>>> # Move trailing to second slot
        [
            >>> >>>> <<<< +
            <<< <<<< >>>> -
        ]
        >>> >>>> <<<<

        <

        # Print
        [
        . # Print first character

        # Print insides
        < <<<<
        [.>]<[<]
        > >>>>>

        # Move first character back
        [<<<< << + >> >>>> -]
        ]

        # Go to second slot
        >
        # Move trailing character back
        [<<< <<<< >>>> + >>> >>>> <<<< -]

        # Point to next available cell
        <<
    */

    // Have at least one cell between referenced value
    // and ourselves so that there can be a cell
    // that we will temporarily zero

    // Allocate two cells
    printf("[-]>[-]<");

    // Go to first character
    printf("%d<", back_offset);

    // Move first character to first slot
    printf("[%d>+%d<-]", back_offset + 1, back_offset + 1);

    // Go to trailing cell
    printf("%d>", max_length);

    // Move trailing character to second slot
    printf("[%d>+%d<-]", back_offset - max_length + 2, back_offset - max_length + 2);

    // Go to first slot
    printf("%d>", back_offset - max_length + 1);

    // Print string if first slot is non-zero
    printf("[");
        printf("."); // Print first character

        // Print insides
        printf("%d<", back_offset);
        printf("[.>]<[<]");
        printf("%d>", back_offset + 1);

        // Move first character back
        printf("[%d<+%d>-]", back_offset + 1, back_offset + 1);
    printf("]");

    // Go to second slot
    printf(">");

    // Move trailing character back
    printf("[%d<+%d>-]", back_offset - max_length + 2, back_offset - max_length + 2);

    // Point to next available cell
    printf("<<");
}

u0 emit_print_array_value(u32 max_length){
    print_cells_static(emit_context.current_cell_index - max_length, max_length);
    printf("%d<", max_length);
    emit_context.current_cell_index -= max_length;
}

u0 emit_u1(u1 value){
    printf("[-]");

    if(value){
        printf("+");
    }

    printf(">");
    emit_context.current_cell_index++;
}

u0 emit_u8(u8 value){
    printf("[-]%d+>", value);
    emit_context.current_cell_index++;
}

u0 emit_u16(u16 value){
    // Little endian
    emit_u8(value._0);
    emit_u8(value._1);
}

u0 emit_u24(u24 value){
    /*
    emit_u8(value >> 16);
    emit_u8((value >> 8) & 0xFF);
    emit_u8(value & 0xFF);
    */

    // Little endian
    emit_u8(value.bytes[2]);
    emit_u8(value.bytes[1]);
    emit_u8(value.bytes[0]);
}

u0 emit_u32(u32 value){
    // Little endian
    emit_u8(value._0);
    emit_u8(value._1);
    emit_u8(value._2);
    emit_u8(value._3);
}

u0 emit_printu1(){
    // a ?
    //   ^

    // Allocate 3 temporary cells ('whether to run else', 'copied value', and 'bus')
    // and set 'whether to run else' as true
    printf("[-]+>[-]>[-]");

    // Go to value
    printf("3<");

    // Copy value from 'a' to 'copied value' via 'bus'
    printf("[>>+>+<<<-]");
    printf("3>[3<+3>-]");

    // Go to 'copied value' cell
    printf("<");

    // If copied value
    printf("[");
        // Set 'whether to run else' to false
        printf("<->");

        // Print "true"
        printf("[-]116+.2-.3+.16-.");

        // Zero copied value
        printf("[-]");
    // End if
    printf("]");

    // Go to 'else' cell
    printf("<");
    
    // If 'else'
    printf("[");
        // Print "false"
        printf("[-]102+.5-.11+.7+.14-.");

        // Zero 'else'
        printf("[-]");
    // End if
    printf("]");

    // Remain pointing to next available cell
    // (nothing to do)
}

u0 emit_printu8(){
    // a ?
    //   ^

    // a ?
    //   ^

    // Clear 9 cells
    printf("[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]8<");
    
    // Print algorithm
    printf(">10+<<[->+>-[>+>>]>[+[-<+>]>+>>]6<]>>[-]3>10+<[->-[>+>>]>[+[-<+>]>+>>]5<]>[-]>>[>6+[-<8+>]<.<<+>+>[-]]<[<[->-<]6+[->8+<]>.[-]]<<6+[-<8+>]<.[-]<<[-<+>]");
}

u0 emit_additive_u8(u1 is_plus){
    // a b ?
    //     ^

    // Point to b
    printf("<");

    // While b is non-zero
    printf("[");

    // Go backwards to a
    printf("<");

    if(is_plus){
        // Increment a
        printf("+");
    } else {
        // Decrement a
        printf("-");
    }

    // Go forwards to b
    printf(">");

    // Decrement b
    printf("-");

    // End while
    printf("]");

    emit_context.current_cell_index--;
}

u0 emit_stdlib_function_call(u8 function_name[16], u32 return_size, u32 params_size){
    if(return_size != 0){
        // Make room for return value
        for(u32 i = 0; i < return_size; i++){
            printf("[-]>");
        }
        emit_context.current_cell_index += return_size;

        // Move parameters over to make room for return value
        printf("<");
        printf("%d<", return_size);

        for(u32 i = 0; i < params_size; i++){
            printf("[-%d>+%d<]", return_size, return_size);
            printf("<");
        }

        printf("%d>", 1 + return_size + params_size);
    }

    u32 start_function_cell_index = emit_context.current_cell_index - params_size;

    u32 prev_num_aux = num_aux;
    u32 name = aux_cstr_alloc(function_name);
    u32 function_index = find_function(name);
    num_aux = prev_num_aux;
    
    if(function_index >= FUNCTIONS_CAPACITY){
        printf("\nFailed to emit standard library function call, could not find function\n");
        return;
    }

    if(function_emit(function_index, start_function_cell_index, emit_context.current_cell_index) != 0){
        printf("\nFailed to emit standard library function call, errors exist inside of function\n");
        return;
    }
}

u0 emit_additive_u16(u1 is_plus){
    if(is_plus){
        emit_stdlib_function_call( "u16_add", 2, 4);
    } else {
        emit_stdlib_function_call( "u16_sub", 2, 4);
    }
}

u0 emit_additive_u32(u1 is_plus){
    if(is_plus){
        emit_stdlib_function_call( "u32_add", 4, 8);
    } else {
        emit_stdlib_function_call( "u32_sub", 4, 8);
    }
}

u0 emit_multiply_u8(){
    // a b ?
    //     ^

    // Multiply algorithm

    // Allocate two temporary cells
    printf("[-]>[-]");

    // Go to 'a' cell
    printf("3<");

    // Move 'a' cell to second temporary cell
    printf("[3>+3<-]");

    // Go to second temporary cell
    printf("3>");

    // While second temporary cell
    printf("[");

    // Point to 'b' cell
    printf("<<");

    // Add 'b' cell to 'a' cell and first temporary cell
    printf("[<+>>+<-]");

    // Go to first temporary cell
    printf(">");

    // Move to first temporary cell to 'b' cell
    printf("[<+>-]");

    // Go to second temporary cell and decrement it
    printf(">-");

    // End while
    printf("]");

    // Point to next available cell
    printf("<<");

    emit_context.current_cell_index--;
}

u0 emit_multiply_u16(){
    emit_stdlib_function_call( "u16_mul", 2, 4);
}

u0 emit_multiply_u32(){
    emit_stdlib_function_call( "u32_mul", 4, 8);
}

u0 emit_divmod_u8(){
    // n d ?
    //     ^

    // 0 d-n%d n%d n/d
    // ^

    // Setup
    printf("[-]>[-]>[-]>[-]5<");

    // Divmod algorithm
    printf("[->[->+>>]>[<<+>>[-<+>]>+>>]5<]>[3>]>[[-<+>]>+>>]5<");

    // Consume 'd'
    emit_context.current_cell_index -= 2;
}

u0 emit_divide_u8(){
    // a b ?
    //     ^

    emit_divmod_u8();

    // Go to n/d cell and move n/d to result cell
    printf("3>[3<+3>-]2<");
    emit_context.current_cell_index++;
}

u0 emit_divide_u16(){
    emit_stdlib_function_call( "u16_div", 2, 4);
}

u0 emit_divide_u32(){
    emit_stdlib_function_call( "u32_div", 4, 8);
}

u0 emit_mod_u8(){
    // a b ?
    //     ^

    emit_divmod_u8();

    // Go to n%d cell and move n%d to result cell
    printf("2>[2<+2>-]<");
    emit_context.current_cell_index++;
}

u0 emit_mod_u16(){
    emit_stdlib_function_call( "u16_mod", 2, 4);
}

u0 emit_mod_u32(){
    emit_stdlib_function_call( "u32_mod", 4, 8);
}

u0 emit_lshift_u8(){
    // a b ?
    //     ^

    // Create temporary cell
    printf("[-]");

    // Go to 'b' cell
    printf("<");

    // While 'b'
    printf("[");

    // Go to 'a' cell
    printf("<");

    // Move 'a' cell to temporary cell
    printf("[>>+<<-]");

    // Go to temporary cell
    printf(">>");

    // Store 2 times the temporary cell in 'a' cell
    printf("[<<++>>-]");

    // Go to 'b' cell and decrement
    printf("<-");
    
    // End while
    printf("]");

    emit_context.current_cell_index--;
}

u0 emit_lshift_u16(){
    // Convert u16 amount to u8 amount
    printf("<");
    emit_context.current_cell_index--;

    emit_stdlib_function_call( "u16_sll", 2, 3);
}

u0 emit_lshift_u32(){
    // Convert u32 amount to u8 amount
    printf("3<");
    emit_context.current_cell_index -= 3;

    emit_stdlib_function_call( "u32_sll", 4, 5);
}

u0 emit_rshift_u8(){
    // a b ?
    //     ^

    // Allocate 4 temporary cells (c, x, y, and z)
    printf("[-]>[-]>[-]>[-]");

    // Go to 'b' cell
    printf("4<");

    // While 'b'
    printf("[");

    // Set 'c' cell to 2
    printf(">++");

    // Point to 'a' cell
    printf("<<");

    // While 'a'
    printf("[");
    
    // Decrement 'a' cell
    printf("-");

    // Go to and decrement 'c' cell
    printf(">>-");

    // Copy 'c' cell to 'y' cell via 'z' cell
    printf("[>>+>+3<-]3>[3<+3>-]");

    // Go to 'y' cell
    printf("<");

    // If 'y' cell is 0
    printf("-[");

    // Go to and increment 'x' cell
    printf("<+");

    // Set 'c' cell to 2
    printf("<++");

    // Go to and semi-zero 'y' cell
    printf(">>+");

    // End if
    printf("]");

    // Go to 'a' cell
    printf("4<");

    // End while
    printf("]");

    // Go to 'x' cell
    printf("3>");

    // Move 'x' cell to 'a' cell
    printf("[3<+3>-]");

    // Zero 'c' cell
    printf("<[-]");

    // Go to and decrement 'b' cell
    printf("<-");

    // End while
    printf("]");

    emit_context.current_cell_index--;
}

u0 emit_rshift_u16(){
    // Convert u16 amount to u8 amount
    printf("<");
    emit_context.current_cell_index--;

    emit_stdlib_function_call( "u16_srl", 2, 3);
}

u0 emit_rshift_u32(){
    // Convert u32 amount to u8 amount
    printf("3<");
    emit_context.current_cell_index -= 3;

    emit_stdlib_function_call( "u32_srl", 4, 5);
}

u0 emit_eq_u8(){
    // a b ?
    //     ^

    // Go to 'a' cell
    printf("<<");

    // Subtract 'a' cell from 'b' cell
    printf("[->-<]");

    // Set 'a' cell to 1
    printf("+");

    // Go to 'b' cell
    printf(">");

    // If 'b' cell
    printf("[");
    
    // Semi-zero 'a' cell
    printf("<->");

    // End if
    printf("[-]]");

    // Remain pointing to next available cell
    // (nothing to do)
    
    emit_context.current_cell_index--;
}

u0 emit_eq_u16(){
    emit_stdlib_function_call( "u16_eq", 1, 4);
}

u0 emit_eq_u32(){
    emit_stdlib_function_call( "u32_eq", 1, 8);
}

u0 emit_neq_u8(){
    // a b ?
    //     ^

    // Go to 'a' cell
    printf("<<");

    // Subtract 'a' cell from 'b' cell
    printf("[->-<]");

    // Go to 'b' cell
    printf(">");

    // If 'b' cell
    printf("[");

    // Set 'a' cell to 1
    printf("<+>");

    // End if
    printf("[-]]");

    emit_context.current_cell_index--;
}

u0 emit_neq_u16(){
    emit_stdlib_function_call( "u16_eq", 1, 4);
    emit_not_u1();
}

u0 emit_neq_u32(){
    emit_stdlib_function_call( "u32_eq", 1, 8);
    emit_not_u1();
}

u0 emit_lt_u8(){
    // a b ?
    //     ^

    // Allocate two temporary cells ('c' and 'd')
    printf("[-]>[-]");

    // Go to 'b' cell
    printf("<<");

    // While 'b' cell
    printf("[");

    // Set 'c' cell to zero
    printf(">[-]");

    // Go to 'a' cell
    printf("<<");

    // Copy 'a' cell to 'd' cell via 'c' cell
    printf("[>>+>+3<-]>>[<<+>>-]");

    // Set 'c' cell to 1
    printf("+");

    // Go to 'd' cell
    printf(">");

    // If 'd' cell
    printf("[");

    // Zero 'd' cell
    printf("[-]");

    // Go to and semi-zero 'c' cell
    printf("<-");

    // Go to and decrement 'a' cell
    printf("<<-");

    // Go to 'd' cell
    printf("3>");

    // End if
    printf("]");

    // Go to 'b' cell and decrement
    printf("<<-");

    // End while
    printf("]");

    // Move 'c' cell to 'a' cell
    printf("<[-]>>[<<+>>-]");

    // Go to next available cell
    printf("<");

    emit_context.current_cell_index--;
}

u0 emit_lt_u16(){
    emit_stdlib_function_call( "u16_lt", 1, 4);
}

u0 emit_lt_u32(){
    emit_stdlib_function_call( "u32_lt", 1, 8);
}

u0 emit_gt_u8(){
    // a b ?
    //     ^

    // Allocate two temporary cells ('c' and 'd')
    printf("[-]>[-]");
    
    // Go to 'a' cell
    printf("3<");

    // While 'a'
    printf("[");

    // Go to and zero 'c' cell
    printf(">>[-]");

    // Go to 'b'
    printf("<");

    // Copy 'b' cell to 'd' cell via 'c' cell
    printf("[>+>+<<-]>[<+>-]");

    // Set 'c' cell to 1
    printf("+");

    // Go to 'd' cell
    printf(">");

    // If 'd' cell
    printf("[");

    // Zero 'd' cell
    printf("[-]");

    // Go 'c' cell and semi-zero
    printf("<-");

    // Go to 'b' cell and decrement
    printf("<-");

    // Go to 'd' cell
    printf(">>");

    // End if
    printf("]");

    // Go to 'a' cell
    printf("3<");

    // Decrement 'a' cell
    printf("-");

    // End while
    printf("]");

    // Move 'c' cell to 'a' cell
    printf(">>[<<+>>-]");
    
    // Go to next available cell
    printf("<");

    emit_context.current_cell_index--;
}

u0 emit_gt_u16(){
    emit_stdlib_function_call( "u16_gt", 1, 4);
}

u0 emit_gt_u32(){
    emit_stdlib_function_call( "u32_gt", 1, 8);
}

u0 emit_lte_u8(){
    // a b ?
    //     ^

    // Allocate two temporary cells ('c' and 'd'), with 'c' starting at 1
    printf("[-]+>[-]");

    // Go to 'a' cell
    printf("3<");

    // While 'a' cell
    printf("[");

    // Set 'c' cell to zero
    printf(">>[-]");

    // Go to 'b' cell
    printf("<");

    // Copy 'b' cell to 'd' cell via 'c' cell
    printf("[>+>+<<-]>[<+>-]");

    // Go to 'd' cell
    printf(">");

    // If 'd' cell
    printf("[");

    // Zero 'd' cell
    printf("[-]");

    // Go to 'c' cell and set to 1
    printf("<+");

    // Go to and decrement 'b' cell
    printf("<-");

    // Go to 'd' cell
    printf(">>");

    // End if
    printf("]");

    // Go to 'a' cell and decrement
    printf("3<-");

    // End while
    printf("]");

    // Move 'c' cell to 'a' cell
    printf(">>[<<+>>-]");

    // Go to next available cell
    printf("<");

    emit_context.current_cell_index--;
}

u0 emit_lte_u16(){
    emit_stdlib_function_call( "u16_lte", 1, 4);
}

u0 emit_lte_u32(){
    emit_stdlib_function_call( "u32_lte", 1, 8);
}

u0 emit_gte_u8(){
    // a b ?
    //     ^

    // Allocate two temporary cells ('c' and 'd'), with 'c' starting at 1
    printf("[-]+>[-]");
    
    // Go to 'b' cell
    printf("<<");

    // While 'b'
    printf("[");

    // Go to and zero 'c' cell
    printf(">[-]");

    // Go to 'a'
    printf("<<");

    // Copy 'a' cell to 'd' cell via 'c' cell
    printf("[>>+>+<<<-]>>[<<+>>-]");

    // Go to 'd' cell
    printf(">");

    // If 'd' cell
    printf("[");

    // Zero 'd' cell
    printf("[-]");

    // Go 'c' cell and set to 1
    printf("<+");

    // Go to 'a' cell and decrement
    printf("<<-");

    // Go to 'd' cell
    printf("3>");

    // End if
    printf("]");

    // Go to 'b' cell
    printf("<<");

    // Decrement 'b' cell
    printf("-");

    // End while
    printf("]");

    // Move 'c' cell to 'a' cell
    printf("<[-]>>[<<+>>-]");
    
    // Go to next available cell
    printf("<");

    emit_context.current_cell_index--;
}

u0 emit_gte_u16(){
    emit_stdlib_function_call( "u16_gte", 1, 4);
}

u0 emit_gte_u32(){
    emit_stdlib_function_call( "u32_gte", 1, 8);
}

u0 emit_binary_bitwise_operator_pre(){
    // a b ?
    //     ^

    printf("5>");
    printf("[-]>>[-]<");
    printf("[-]8-[8+");
    printf("<");
    printf("<[-]<[-]<[-]<[-]<[-]");
    printf("++");
    printf("<<");
    printf("[");
    printf("-");
    printf(">>-");
    printf("[>+>>+3<-]>[<+>-]");
    printf(">>");
    printf(">>+<<");
    printf("-[");
    printf("<+");
    printf("<<++");
    printf("5>");
    printf("--");
    printf("<<");
    printf("+");
    printf("]");
    printf("5<");
    printf("]");
    printf("4>[4<+4>-]");
    printf("<<[-]++");
    printf("<");
    printf("[");
    printf("-");
    printf(">-");
    printf("[>+>>+3<-]>[<+>-]");
    printf(">>");
    printf(">+<");
    printf("-[");
    printf(">--<");
    printf("<+");
    printf("<<++");
    printf("3>");
    printf("+");
    printf("]");
    printf("4<");
    printf("]");
    printf("3>[3<+3>-]");
    printf(">>");
}

u0 emit_binary_bitwise_operator_post(){
    printf(">[<+<+>>-]<[>+<-]");
    printf("<");
    printf("[");
    printf("<");
    printf("[<+>-]");
    printf("<[>++<-]");
    printf(">>-");
    printf("]");
    printf("<");
    printf("[4>+4<-]");
    printf("3>");
    printf("7-");
    printf("]");
    printf(">[9<+9>-]");
    printf("8<");
    emit_context.current_cell_index--;
}

u0 emit_bit_and_u8(){
    // a b ?
    //     ^

    emit_binary_bitwise_operator_pre();
    printf("[->[-<<+>>]<]>[-]");
    emit_binary_bitwise_operator_post();
}

u0 emit_bit_and_u16(){
    emit_stdlib_function_call( "u16_bit_and", 2, 4);
}

u0 emit_bit_and_u32(){
    emit_stdlib_function_call( "u32_bit_and", 4, 8);
}

u0 emit_bit_or_u8(){
    // a b ?
    //     ^

    emit_binary_bitwise_operator_pre();
    printf("[>+<-]>[[-]<<+>>]");
    emit_binary_bitwise_operator_post();
}

u0 emit_bit_or_u16(){
    emit_stdlib_function_call( "u16_bit_or", 2, 4);
}

u0 emit_bit_or_u32(){
    emit_stdlib_function_call( "u32_bit_or", 4, 8);
}

u0 emit_bit_xor_u8(){
    // a b ?
    //     ^

    emit_binary_bitwise_operator_pre();
    printf("[>-<-]>[[-]<<+>>]");
    emit_binary_bitwise_operator_post();
}

u0 emit_bit_xor_u16(){
    emit_stdlib_function_call( "u16_bit_xor", 2, 4);
}

u0 emit_bit_xor_u32(){
    emit_stdlib_function_call( "u32_bit_xor", 4, 8);
}

u0 emit_not_u1(){
    // a ?
    //   ^

    printf("[-]+<[");
        printf(">-<");
    printf("[-]]");

    printf(">[<+>-]");
}

u0 emit_negate_u8(){
    // a ?
    //   ^

    printf("<-[>+<-]>+[<->-]");
}

u0 emit_negate_u16(){
    // Add u16 value of 0 before value
    printf("[-]>[-]<");
    printf("<<[>>+<<-]>[>>+<<-]");
    printf("3>");
    emit_context.current_cell_index += 2;

    // Subtract
    emit_stdlib_function_call( "u16_sub", 2, 4);
}

u0 emit_negate_u32(){
    // Add u32 value of 0 before value

    printf("[-]>[-]>[-]>[-]7<");
    printf("[4>+4<-]>[4>+4<-]>[4>+4<-]>[4>+4<-]");
    printf("5>");

    emit_context.current_cell_index += 4;

    // Subtract
    emit_stdlib_function_call( "u32_sub", 4, 8);
}

u0 emit_bit_complement_u8(){
    // a ?
    //   ^

    printf("<[>+<-]>+[<->-]");
}

u0 emit_bit_complement_u16(){
    emit_stdlib_function_call( "u16_bit_neg", 2, 2);
}

u0 emit_bit_complement_u32(){
    emit_stdlib_function_call( "u32_bit_neg", 4, 4);
}

u0 emit_printu16(){
    emit_stdlib_function_call( "printu16", 0, 2);
}

u0 emit_printu32(){
    emit_stdlib_function_call( "printu32", 0, 4);
}



EmitContext emit_context;
EmitSettings emit_settings;



u0 expression_print_operator(ExpressionKind kind){
    switch(kind){
    case EXPRESSION_ASSIGN:
        printf("=");
        break;
    case EXPRESSION_ADD:
        printf("+");
        break;
    case EXPRESSION_SUBTRACT:
        printf("-");
        break;
    case EXPRESSION_MULTIPLY:
        printf("*");
        break;
    case EXPRESSION_DIVIDE:
        printf("/");
        break;
    case EXPRESSION_MOD:
        printf("%%");
        break;
    case EXPRESSION_EQUALS:
        printf("==");
        break;
    case EXPRESSION_NOT_EQUALS:
        printf("!=");
        break;
    case EXPRESSION_LESS_THAN:
        printf("<");
        break;
    case EXPRESSION_GREATER_THAN:
        printf(">");
        break;
    case EXPRESSION_LESS_THAN_OR_EQUAL:
        printf("<=");
        break;
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
        printf(">=");
        break;
    case EXPRESSION_LSHIFT:
        printf("<<");
        break;
    case EXPRESSION_RSHIFT:
        printf(">>");
        break;
    case EXPRESSION_AND:
        printf("&&");
        break;
    case EXPRESSION_OR:
        printf("||");
        break;
    case EXPRESSION_BIT_AND:
        printf("&");
        break;
    case EXPRESSION_BIT_OR:
        printf("|");
        break;
    case EXPRESSION_BIT_XOR:
        printf("^");
        break;
    case EXPRESSION_NEGATE:
        printf("-");
        break;
    case EXPRESSION_NOT:
        printf("!");
        break;
    case EXPRESSION_BIT_COMPLEMENT:
        printf("~");
        break;
    case EXPRESSION_PRE_INCREMENT:
    case EXPRESSION_POST_INCREMENT:
    case EXPRESSION_NO_RESULT_INCREMENT:
        printf("++");
        break;
    case EXPRESSION_PRE_DECREMENT:
    case EXPRESSION_POST_DECREMENT:
    case EXPRESSION_NO_RESULT_DECREMENT:
        printf("--");
        break;
    default:
        printf("<unknown math operator>");
    }
}

u0 expression_print_operation_name(ExpressionKind kind){
    switch(kind){
    case EXPRESSION_ASSIGN:
        printf("assign");
        break;
    case EXPRESSION_ADD:
        printf("add");
        break;
    case EXPRESSION_SUBTRACT:
        printf("subtract");
        break;
    case EXPRESSION_MULTIPLY:
        printf("multiply");
        break;
    case EXPRESSION_DIVIDE:
        printf("divide");
        break;
    case EXPRESSION_MOD:
        printf("mod");
        break;
    case EXPRESSION_EQUALS:
    case EXPRESSION_NOT_EQUALS:
    case EXPRESSION_LESS_THAN:
    case EXPRESSION_GREATER_THAN:
    case EXPRESSION_LESS_THAN_OR_EQUAL:
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
        printf("compare");
        break;
    case EXPRESSION_LSHIFT:
        printf("left shift");
        break;
    case EXPRESSION_RSHIFT:
        printf("right shift");
        break;
    case EXPRESSION_AND:
        printf("AND");
        break;
    case EXPRESSION_OR:
        printf("OR");
        break;
    case EXPRESSION_BIT_AND:
        printf("bitwise-and");
        break;
    case EXPRESSION_BIT_OR:
        printf("bitwise-or");
        break;
    case EXPRESSION_BIT_XOR:
        printf("bitwise-xor");
        break;
    case EXPRESSION_NEGATE:
        printf("negate");
        break;
    case EXPRESSION_NOT:
        printf("not");
        break;
    case EXPRESSION_BIT_COMPLEMENT:
        printf("bitwise-complement");
        break;
    case EXPRESSION_PRE_INCREMENT:
    case EXPRESSION_POST_INCREMENT:
        printf("increment");
        break;
    case EXPRESSION_PRE_DECREMENT:
    case EXPRESSION_POST_DECREMENT:
        printf("decrement");
        break;
    default:
        printf("<unknown math operation of id %d>", (u8) kind);
    }
}

ExpressionKind expression_kind_unary_prefix_from_token_kind(TokenKind kind){
    switch(kind){
    case TOKEN_SUBTRACT:
        return EXPRESSION_NEGATE;
    case TOKEN_NOT:
        return EXPRESSION_NOT;
    case TOKEN_BIT_COMPLEMENT:
        return EXPRESSION_BIT_COMPLEMENT;
    case TOKEN_INCREMENT:
        return EXPRESSION_PRE_INCREMENT;
    case TOKEN_DECREMENT:
        return EXPRESSION_PRE_DECREMENT;
    default:
        return EXPRESSION_NONE;
    }
}

ExpressionKind expression_kind_unary_postfix_from_token_kind(TokenKind kind){
    switch(kind){
    case TOKEN_INCREMENT:
        return EXPRESSION_POST_INCREMENT;
    case TOKEN_DECREMENT:
        return EXPRESSION_POST_DECREMENT;
    default:
        return EXPRESSION_NONE;
    }
}

ExpressionKind expression_kind_binary_from_token_kind(TokenKind kind){
    switch(kind){
    case TOKEN_ASSIGN:
        return EXPRESSION_ASSIGN;
    case TOKEN_ADD:
        return EXPRESSION_ADD;
    case TOKEN_SUBTRACT:
        return EXPRESSION_SUBTRACT;
    case TOKEN_MULTIPLY:
        return EXPRESSION_MULTIPLY;
    case TOKEN_DIVIDE:
        return EXPRESSION_DIVIDE;
    case TOKEN_MOD:
        return EXPRESSION_MOD;
    case TOKEN_EQUALS:
        return EXPRESSION_EQUALS;
    case TOKEN_NOT_EQUALS:
        return EXPRESSION_NOT_EQUALS;
    case TOKEN_LESS_THAN:
        return EXPRESSION_LESS_THAN;
    case TOKEN_GREATER_THAN:
        return EXPRESSION_GREATER_THAN;
    case TOKEN_LESS_THAN_OR_EQUAL:
        return EXPRESSION_LESS_THAN_OR_EQUAL;
    case TOKEN_GREATER_THAN_OR_EQUAL:
        return EXPRESSION_GREATER_THAN_OR_EQUAL;
    case TOKEN_LSHIFT:
        return EXPRESSION_LSHIFT;
    case TOKEN_RSHIFT:
        return EXPRESSION_RSHIFT;
    case TOKEN_AND:
        return EXPRESSION_AND;
    case TOKEN_OR:
        return EXPRESSION_OR;
    case TOKEN_BIT_AND:
        return EXPRESSION_BIT_AND;
    case TOKEN_BIT_OR:
        return EXPRESSION_BIT_OR;
    case TOKEN_BIT_XOR:
        return EXPRESSION_BIT_XOR;
    default:
        return EXPRESSION_NONE;
    }
}

ExpressionKind expression_kind_binary_from_assignment_token_kind(TokenKind kind){
    switch(kind){
    case TOKEN_ADD_ASSIGN:
        return EXPRESSION_ADD;
    case TOKEN_SUBTRACT_ASSIGN:
        return EXPRESSION_SUBTRACT;
    case TOKEN_MULTIPLY_ASSIGN:
        return EXPRESSION_MULTIPLY;
    case TOKEN_DIVIDE_ASSIGN:
        return EXPRESSION_DIVIDE;
    case TOKEN_MOD_ASSIGN:
        return EXPRESSION_MOD;
    case TOKEN_LSHIFT_ASSIGN:
        return EXPRESSION_LSHIFT;
    case TOKEN_RSHIFT_ASSIGN:
        return EXPRESSION_RSHIFT;
    case TOKEN_BIT_AND_ASSIGN:
        return EXPRESSION_BIT_AND;
    case TOKEN_BIT_OR_ASSIGN:
        return EXPRESSION_BIT_OR;
    case TOKEN_BIT_XOR_ASSIGN:
        return EXPRESSION_BIT_XOR;
    default:
        return EXPRESSION_NONE;
    }
}

u0 expression_print_cannot_use_case_here_error(Expression expression){
    printf("\nerror on line %d: Cannot use '", u24_unpack(expression.line));

    if(operands[expression.ops] >= EXPRESSIONS_CAPACITY){
        printf("default");
    } else {
        printf("case");
    }

    printf("' here, must be used inside 'switch' statement\n");
}



u32 expression_emit_string(Expression expression);

u0 print_nth_argument_label(u8 number){
    switch(number){
    case 0:
        printf("Zeroth");
        break;
    case 1:
        printf("First");
        break;
    case 2:
        printf("Second");
        break;
    case 3:
        printf("Third");
        break;
    case 4:
        printf("Fourth");
        break;
    case 5:
        printf("Fifth");
        break;
    case 6:
        printf("Sixth");
        break;
    case 7:
        printf("Seventh");
        break;
    case 8:
        printf("Eighth");
        break;
    case 9:
        printf("Ninth");
        break;
    case 10:
        printf("Tenth");
    default:
        printf("%d-th", number);
    }
}

ErrorCode grow_type(u32 from_type_index, u32 to_type_index, u8 offset_size){
    Type from_type = types[from_type_index];
    Type to_type = types[to_type_index];

    if(!aux_cstr_equals(from_type.name, to_type.name)){
        return 1;
    }

    if(from_type.dimensions == 0 || to_type.dimensions == 0){
        return 1;
    }

    u32 f[4];
    u32 t[4];

    memcpy(f, dimensions[from_type.dimensions], sizeof f);
    memcpy(t, dimensions[to_type.dimensions], sizeof t);

    u8 num_f_dims = 1;
    u8 num_t_dims = 1;

    while(num_f_dims < 4 && f[num_f_dims] != 0){
        num_f_dims++;
    }
    while(num_t_dims < 4 && t[num_t_dims] != 0){
        num_t_dims++;
    }

    if(num_f_dims != num_t_dims){
        return 1;
    }

    u32 t_len = t[num_t_dims - 1];
    u32 f_len = f[num_f_dims - 1];

    if(t_len > f_len){
        u32 difference = t_len - f_len;

        // If we have an offset, then move it forward
        if(offset_size > 0){
            printf("<");
            emit_context.current_cell_index--;

            u32 new_offset_position = emit_context.current_cell_index - (u32) offset_size + 1 + difference;

            move_cells_static(new_offset_position, (u32) offset_size);
        }

        // Zero extend array
        while(f_len < t_len){
            printf("[-]>");
            emit_context.current_cell_index++;
            f_len++;
        }

        if(offset_size > 0){
            printf("%d>", offset_size);
            emit_context.current_cell_index += (u32) offset_size;
        }

        return 0;
    }

    return 1;
}

u32 expression_emit_printf(Expression expression){
    u8 arity = (u8) operands[expression.ops + 1];

    if(arity < 1){
        printf("\nerror on line %d: printf requires at least one argument\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    Expression format_argument = expressions[operands[expression.ops + 2]];

    if(format_argument.kind != EXPRESSION_STRING){
        printf("\nerror on line %d: First argument to 'printf' must be a compile-time known string\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    u32 format = format_argument.ops;
    u8 next_argument_i = 1;
    u8 c = aux[format];

    while(c != 0){
        // Print until a '%'

        printf("[-]");
        u8 previous_value = 0;

        while(c != 0){
            if(c == '%'){
                c = aux[++format];

                if(c == 'd'){
                    format++;
                    break;
                } else if(c == 'c'){
                    format++;
                    break;
                } else if(c != '%'){
                    printf("\nerror on line %d: Unknown printf format '%%", u24_unpack(expression.line));
                    put(c);
                    printf("'\n");
                    return TYPES_CAPACITY;
                }
            }

            set_cell_to_value(c, previous_value);
            printf(".");
            previous_value = c;
            c = aux[++format];
        }

        if(c != 0){
            if(next_argument_i == arity){
                printf("\nerror on line %d: No value specified for printf format '%%%c'", u24_unpack(expression.line), c);
                return TYPES_CAPACITY;
            }

            Expression argument = expressions[operands[expression.ops + 2 + (u32) next_argument_i++]];
            u32 argument_type = expression_emit(argument);
            if(argument_type == TYPES_CAPACITY) return TYPES_CAPACITY;

            if(c == 'd'){
                if(argument_type == u1_type){
                    emit_printu1();
                } else if(argument_type == u8_type){
                    emit_printu8();
                } else if(argument_type == u16_type){
                    emit_printu16();
                } else if(argument_type == u32_type){
                    emit_printu32();
                } else {
                    printf("\nerror on line %d: Cannot print '", u24_unpack(expression.line));
                    type_print(types[argument_type]);
                    printf("' with printf format specifier '%%d'\n");
                    return TYPES_CAPACITY;
                }
                
                c = aux[format];
            } else if(c == 'c'){
                if(argument_type != u8_type){
                    printf("\nerror on line %d: Cannot print '", u24_unpack(expression.line));
                    type_print(types[argument_type]);
                    printf("' with printf format specifier '%%c'\n");
                    return TYPES_CAPACITY;
                }
            }
        }
    }

    if(next_argument_i != arity){
        printf("\nerror on line %d: printf was supplied with %d unused arguments\n", u24_unpack(expression.line), arity - next_argument_i);
        return TYPES_CAPACITY;
    }

    return u0_type;
}

typedef struct {
   u32 value;
   u1 ok;
} CompileTimeInteger;

CompileTimeInteger as_compile_time_integer(Expression bytes_argument){
    u32 value;

    if(bytes_argument.kind == EXPRESSION_INT){
        // Integer
        value = bytes_argument.ops;
    } else if(bytes_argument.kind == EXPRESSION_SIZEOF_TYPE){
        // sizeof(Type)
        value = type_sizeof_or_max(bytes_argument.ops, bytes_argument.line);
        if(value == -1) return (CompileTimeInteger){ .ok = false };
    } else if(bytes_argument.kind == EXPRESSION_SIZEOF_VALUE){
        // sizeof value
        u32 type = expression_get_type(expressions[bytes_argument.ops], EXPRESSION_GET_TYPE_MODE_PRINT_ERROR);
        if(type == TYPES_CAPACITY) return (CompileTimeInteger){ .ok = false };

        value = type_sizeof_or_max(type, bytes_argument.line);
        if(value == -1) return (CompileTimeInteger){ .ok = false };
    } else {
        // Invalid
        return (CompileTimeInteger){ .ok = false };
    }

    return (CompileTimeInteger){ .ok = true, .value = value };
}

u32 expression_emit_memcmp(Expression expression){
    u8 arity = (u8) operands[expression.ops + 1];

    if(arity != 3){
        printf("\nerror on line %d: memcmp requires three arguments\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    Expression bytes_argument = expressions[operands[expression.ops + 2 + 2]];
    CompileTimeInteger integer = as_compile_time_integer(bytes_argument);

    if(!integer.ok){
        printf("\nerror on line %d: Third argument to memcmp must be a compile-time known integer\n", u24_unpack(bytes_argument.line));
        return TYPES_CAPACITY;
    }

    u32 bytes = integer.value;

    if(bytes == 0){
        emit_u8(0);
        return u8_type;
    }

    u32 type_dimensions[4] = { bytes };
    Type new_type_layout = (Type){
        .name = types[u8_type].name,
        .dimensions = add_dimensions(type_dimensions),
    };
    u32 new_type = add_type(new_type_layout);
    if(new_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    Destination destination;
    Expression argument;

    argument = expressions[operands[expression.ops + 2]];
    if(argument.kind == EXPRESSION_STRING){
        if(expression_emit_string(argument) == TYPES_CAPACITY){
            return TYPES_CAPACITY;
        }
    } else {
        destination = expression_get_destination(argument, emit_context.current_cell_index);
        if(destination.type == TYPES_CAPACITY) return 1;
        destination.type = new_type;
        if(read_destination(destination, expression.line) == TYPES_CAPACITY){
            return TYPES_CAPACITY;
        }
    }

    argument = expressions[operands[expression.ops + 2 + 1]];
    if(argument.kind == EXPRESSION_STRING){
        if(expression_emit_string(argument) == TYPES_CAPACITY){
            return TYPES_CAPACITY;
        }
    } else {
        destination = expression_get_destination(argument, emit_context.current_cell_index);
        if(destination.type == TYPES_CAPACITY) return TYPES_CAPACITY;
        destination.type = new_type;
        if(read_destination(destination, expression.line) == TYPES_CAPACITY){
            return TYPES_CAPACITY;
        }
    }

    // Allocate not done and result cell
    printf(">[-]+>[-]<");

    for(u32 j = 0; j < bytes; j++){
        u32 i = bytes - 1 - j;
        
        // If not done
        printf("[");

        // Zero initialize temporary cell
        printf("<[-]");

        // Go to Y
        printf("%d<", i + 1);

        // Set X to X - Y
        printf("[%d<-%d>+%d<-]", bytes, bytes + i + 1, i + 1);
        printf("%d>[%d<+%d>-]", i + 1, i + 1, i + 1);

        // Move X' to temporary cell
        u32 x_distance = bytes + i + 1;
        printf("%d<[-%d>+%d<]%d>", x_distance, x_distance, x_distance, x_distance);

        // If temporary cell is not zero
        printf("[");
        
        // Move temporary cell to result cell
        printf("[>>+<<-]");

        // Set 'not done' to false
        printf(">[-]<");

        printf("]");

        // Go to 'not done' cell
        printf(">");

        // Mark as done if out of bytes
        if(j + 1 == bytes){
            printf("[-]");
        }
    }

    // Close if's
    printf("%d]", bytes);

    // Go to result cell
    printf(">");

    // Copy result cell to final position
    u32 distance = 2 + 2 * bytes;
    printf("%d<[-]%d>[-%d<+%d>]", distance, distance, distance, distance);

    // Point to next available cell
    printf("%d<", distance - 1);
    emit_context.current_cell_index -= 2 * bytes - 1;
    return u8_type;
}

u32 expression_emit_memcpy(Expression expression){
    u8 arity = (u8) operands[expression.ops + 1];

    if(arity != 3){
        printf("\nerror on line %d: memcpy requires three arguments\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    Expression bytes_argument = expressions[operands[expression.ops + 2 + 2]];
    CompileTimeInteger integer = as_compile_time_integer(bytes_argument);

    if(!integer.ok){
        printf("\nerror on line %d: Third argument to memcpy must be a compile-time known integer\n", u24_unpack(bytes_argument.line));
        return TYPES_CAPACITY;
    }

    u32 bytes = integer.value;

    if(bytes == 0){
        return u0_type;
    }

    u32 type_dimensions[4] = { bytes };
    Type new_type_layout = (Type){
        .name = types[u8_type].name,
        .dimensions = add_dimensions(type_dimensions),
    };
    u32 new_type = add_type(new_type_layout);
    if(new_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    // Read N bytes of source
    Destination destination;
    Expression argument;
    argument = expressions[operands[expression.ops + 2 + 1]];
    if(argument.kind == EXPRESSION_STRING){
        if(expression_emit_string(argument) == TYPES_CAPACITY){
            return TYPES_CAPACITY;
        }
    } else {
        destination = expression_get_destination(argument, emit_context.current_cell_index);
        if(destination.type == TYPES_CAPACITY) return TYPES_CAPACITY;
        destination.type = new_type;
        if(read_destination(destination, expression.line) == TYPES_CAPACITY){
            return TYPES_CAPACITY;
        }
    }

    // Get destination
    argument = expressions[operands[expression.ops + 2]];
    destination = expression_get_destination(argument, emit_context.current_cell_index);
    if(destination.type == TYPES_CAPACITY) return 1;
    destination.type = new_type;

    return write_destination_unsafe(new_type, destination, expression.line);
}

u32 expression_emit_call(Expression expression){
    u32 name = operands[expression.ops];
    u8 arity = (u8) operands[expression.ops + 1];

    u32 function_index = find_function(name);

    if(function_index >= FUNCTIONS_CAPACITY){
        printf("\nerror on line %d: Undeclared function '", u24_unpack(expression.line));
        print_aux_cstr(name);
        printf("'\n");
        return TYPES_CAPACITY;
    }

    /*
        RETURN VALUE SPACE
        ------------------------ function start index
        ARGUMENTS
        EARLY RETURN CELL?
        LOCAL VARIABLES
    */

    Function function = functions[function_index];

    if(function.arity != arity){
        printf("\nerror on line %d: ", u24_unpack(expression.line));
        if(arity < function.arity){
            printf("Not enough");
        } else {
            printf("Too many");
        }
        printf(" arguments for '");
        print_aux_cstr(name);
        printf("', expected %d but got %d\n", function.arity, arity);
        return TYPES_CAPACITY;
    }

    u32 return_size = type_sizeof_or_max(function.return_type, function.line);
    if(return_size == -1) return TYPES_CAPACITY;

    // Make room for return value
    for(u32 i = 0; i < return_size; i++){
        printf("[-]>");
    }
    emit_context.current_cell_index += return_size;

    u32 continuation_basicblock_id;

    if(function.is_recursive){
        continuation_basicblock_id = emit_settings.next_basicblock_id++;
        emit_u32(continuation_basicblock_id);
    }

    u32 start_function_cell_index = emit_context.current_cell_index;

    // Push Arguments
    for(u8 i = 0; i < arity; i++){
        Expression argument = expressions[operands[expression.ops + 2 + (u32) i]];

        u32 type = expression_emit(argument);
        if(type == TYPES_CAPACITY) return TYPES_CAPACITY;

        u32 type_size = type_sizeof_or_max(type, argument.line);
        if(type_size == -1) return TYPES_CAPACITY;

        // Ensure type matches expected type
        u32 expected_type = operands[expressions[statements[function.begin + (u32) i]].ops];

        if(type != expected_type){
            if(grow_type(type, expected_type, 0) != 0){
                printf("\nerror on line %d: ", u24_unpack(expression.line));
                print_nth_argument_label(i + 1);
                printf(" argument to function '");
                print_aux_cstr(function.name);
                printf("' should be '");
                type_print(types[expected_type]);
                printf("', but got type '");
                type_print(types[type]);
                printf("'\n");
                return TYPES_CAPACITY;
            }

            type = expected_type;
        }
    }

    if(function.is_recursive){
        u32 args_size = function_args_size(function);
        u32 continuation_memory_count = emit_stack_driver_push_all() - args_size + return_size;

        emit_u32(basicblock_id_for_function(function_index));
        emit_stack_push_n(4);
        emit_end_basicblock();

        emit_start_basicblock(continuation_basicblock_id);
        emit_stack_pop_n(continuation_memory_count);
    } else {
        if(function_emit(function_index, start_function_cell_index, emit_context.current_cell_index) != 0){
            return TYPES_CAPACITY;
        }
    }

    return function.return_type;
}

u1 is_destination(Expression expression){
    switch(expression.kind){
    case EXPRESSION_VARIABLE:
    case EXPRESSION_INDEX:
        return true;
    case EXPRESSION_MEMBER:
        // Is a destination only if subject is a destination
        return is_destination(expressions[operands[expression.ops]]);
    default:
        return false;
    }
}

Destination destination_member(Destination destination, u32 name, u24 line_on_error){
    Type type = types[destination.type];
    u1 is_struct_type = true;
    TypeDef def;

    // Ensure not array
    if(type.dimensions != 0){
        is_struct_type = false;
    }

    // Ensure typedef exists
    if(is_struct_type){
        // Get typedef
        u32 def_index = find_typedef(types[destination.type].name);
        if(def_index == TYPES_CAPACITY){
            is_struct_type = false;
        } else {
            def = typedefs[def_index];
        }
    }

    // Ensure typedef is a struct
    if(is_struct_type){
        if(def.kind != TYPEDEF_STRUCT){
            is_struct_type = false;
        }
    }

    if(!is_struct_type){
        if(destination.type == u16_type && aux[name] == '_' && in_range_inclusive(aux[name + 1], '0', '1') && aux[name + 2] == '\0'){
            destination.type = u8_type;
            destination.tape_location += (u32) (aux[name + 1] - '0');
            return destination;
        } else if(destination.type == u32_type && aux[name] == '_' && in_range_inclusive(aux[name + 1], '0', '3') && aux[name + 2] == '\0'){
            destination.type = u8_type;
            destination.tape_location += (u32)(aux[name + 1] - '0');
            return destination;
        } else if(destination.type == u32_type && aux[name] == '_' && in_range_inclusive(aux[name + 1], '0', '1') && aux[name + 2] == 'u' && aux[name + 3] == '1' && aux[name + 4] == '6' && aux[name + 5] == '\0'){
            destination.type = u16_type;
            destination.tape_location += (u32) (2 * (aux[name + 1] - '0'));
            return destination;
        } else {
            printf("\nerror on line %d: Cannot get '", u24_unpack(line_on_error));
            print_aux_cstr(name);
            printf("' of non-struct type '");
            type_print(type);
            printf("'\n");
            return (Destination) { .type = TYPES_CAPACITY };
        }
    }

    // Result destination type is invalid unless we find the member
    destination.type = TYPES_CAPACITY;

    for(u32 i = 0; i < def.num_fields; i++){
        Expression expression = expressions[statements[def.begin + i]];
        if(expression.kind != EXPRESSION_DECLARE) continue;

        u32 field_name = operands[expression.ops + 1];
        u32 field_type = operands[expression.ops];

        if(aux_cstr_equals(field_name, name)){
            destination.type = field_type;
            break;
        }

        u32 field_size = type_sizeof_or_max(field_type, expression.line);
        if(field_size == -1) return (Destination){ .type = TYPES_CAPACITY };

        destination.tape_location += field_size;
    }

    if(destination.type == TYPES_CAPACITY){
        printf("\nerror on line %d: Field '", u24_unpack(line_on_error));
        print_aux_cstr(name);
        printf("' does not exist on type '");
        type_print(type);
        printf("'\n");
        /* fall through */
    }

    // If successful, then .type will be less than TYPES_CAPACITY
    return destination;
}

Destination destination_index(
    Destination array_destination,
    u32 index_expression_index,
    u24 line_on_error
){
    // Ensure not on stack
    if(array_destination.on_stack){
        printf("\nerror on line %d: Cannot index into destination on the stack yet (not supported)\n", u24_unpack(line_on_error));
        return (Destination) { .type = TYPES_CAPACITY };
    }
    
    // Get type of new index
    Expression index_expression = expressions[index_expression_index];
    u32 index_type = expression_get_type(index_expression, EXPRESSION_GET_TYPE_MODE_NONE);

    if(index_type == TYPES_CAPACITY){
        printf("\nerror on line %d: Could not predict type used for index\n", u24_unpack(line_on_error));
        return (Destination) { .type = TYPES_CAPACITY };
    }

    // Get size of new index
    u8 index_type_size = 0;

    if(index_type == u8_type || index_type == u16_type || index_type == u24_type || index_type == u32_type){
        index_type_size = (u8) type_sizeof_or_max(index_type, u24_pack(0));
        if(index_type_size == (u8) -1) return (Destination){ .type = TYPES_CAPACITY };
    } else {
        printf("\nerror on line %d: Cannot use index of type '", u24_unpack(index_expression.line));
        type_print(types[index_type]);
        printf("'\n");
        return (Destination) { .type = TYPES_CAPACITY };
    }

    // Get array item destination type
    u32 item_type = get_item_type(types[array_destination.type], line_on_error, true);
    if(item_type == TYPES_CAPACITY) return (Destination) { .type = TYPES_CAPACITY };

    // Get size of array item destination type
    u32 item_size = type_sizeof_or_max(item_type, line_on_error);
    if(item_size == -1) return (Destination) { .type = TYPES_CAPACITY };

    // Determine target offset size
    u8 offset_size = index_type_size >= array_destination.offset_size
        ? index_type_size
        : array_destination.offset_size;

    // If we're going to need to multiply, increase
    // the offset size by 1 if we support it
    u8 max_offset_size = 4;
    if(item_size != 1 && array_destination.offset_size != 0 && offset_size < max_offset_size){
        offset_size++;
    }

    // Automatically upgrade u24 indexing to u32 indexing for now since u24 indexing is not supported yet
    if(offset_size == 3){
        u32 todo_this_code_add_u24_indexing_instead;
        offset_size = 4;
    }

    // Pad original index
    if(array_destination.offset_size != 0){
        while(array_destination.offset_size < offset_size){
            printf("[-]>");
            array_destination.offset_size++;
            emit_context.current_cell_index++;
        }
    }

    // Emit index
    u32 actual_index_type = expression_emit(index_expression);
    if(actual_index_type == TYPES_CAPACITY) return (Destination) { .type = TYPES_CAPACITY };

    // Pad new index
    while(index_type_size < offset_size){
        printf("[-]>");
        index_type_size++;
        emit_context.current_cell_index++;
    }

    // Perform appropriate operation for offset size
    if(offset_size == 1){
        // Multiply index by item size (unless item size is 1)
        if(item_size != 1){
            emit_u8((u8) item_size);
            emit_multiply_u8();
        }

        if(array_destination.offset_size != 0){
            emit_additive_u8(true);
        }
    } else if(offset_size == 2){
        // Multiply index by item size (unless item size is 1)
        if(item_size != 1){
            emit_u16((u16) item_size);
            emit_multiply_u16();
        }

        if(array_destination.offset_size != 0){
            emit_additive_u16(true);
        }
    } else if(offset_size == 3){
        printf("\nerror: u24 indexing not supported yet, exiting...\n");
        return (Destination) { .type = TYPES_CAPACITY };
    } else if(offset_size == 4){
        // Multiply index by item size (unless item size is 1)
        if(item_size != 1){
            emit_u32((u32) item_size);
            emit_multiply_u32();
        }

        if(array_destination.offset_size != 0){
            emit_additive_u32(true);
        }
    } else {
        printf("\nerror on line %d: Cannot perform indexing for offset size ", u24_unpack(index_expression.line));
        printf("%d\n", offset_size);
        printf("\n");
        return (Destination) { .type = TYPES_CAPACITY };
    }

    return (Destination) {
        .tape_location = array_destination.tape_location,
        .on_stack = false,
        .type = item_type,
        .offset_size = offset_size,
    };
}

Destination expression_get_destination(Expression expression, u32 tape_anchor){
    // Creates a u32 value on the tape with the mutable location for an expression.
    // If result is `on_stack`, then the u32 offset will be relative to the stack pointer,
    // Otherwise, the u32 offset will be relative to the supplied anchor cell

    // Tape example
    // | 0 | 0 | 0 | 0 | 0 | 7 | 1 | ? | ? | ? | ? |
    //                           ^ chosen anchor cell
    //                           ^ target location is 1 cell away

    // Stack example
    // stack: | 0 | 0 | 0 | 0 | 0 | 7 | ? | ? | ? | ? | ? |
    //                                  ^ stack pointer
    // tape: | ? | ? | ? | ? | ? | ? | 1 | ? | ? | ? | ? |
    //                                 ^ target location is 1 stack cell away

    // A destination result with a type == TYPES_CAPACITY means an error occurred.
    
    if(expression.kind == EXPRESSION_VARIABLE){
        u32 name = expression.ops;
        Variable variable = variable_find(name);

        if(!variable.defined){
            printf("\nerror on line %d: Variable '", u24_unpack(expression.line));
            print_aux_cstr(name);
            printf("' is not defined\n");
            return (Destination){ .type = TYPES_CAPACITY };
        }

        return (Destination){
            .on_stack = false,
            .tape_location = variable.location.location,
            .type = variable.type,
            .offset_size = 0,
        };
    } else if(expression.kind == EXPRESSION_INDEX){
        // Emit subject destination
        Expression subject_expression = expressions[operands[expression.ops]];
        Destination destination = expression_get_destination(subject_expression, tape_anchor);
        if(destination.type == TYPES_CAPACITY) return (Destination) { .type = TYPES_CAPACITY };

        // Emit destination modification
        return destination_index(destination, operands[expression.ops + 1], expression.line);
    } else if(expression.kind == EXPRESSION_MEMBER){
        // Emit subject destination
        Expression subject_expression = expressions[operands[expression.ops]];
        Destination destination = expression_get_destination(subject_expression, tape_anchor);
        if(destination.type == TYPES_CAPACITY) return (Destination) { .type = TYPES_CAPACITY };

        // Emit destination modification
        return destination_member(destination, operands[expression.ops + 1], expression.line);
    } else {
        printf("\nerror on line %d: Cannot get destination for expression `", u24_unpack(expression.line));
        expression_print(expression);
        printf("`\n");

        return (Destination){ .type = TYPES_CAPACITY };
    }
}

u32 write_destination(u32 new_value_type, Destination destination, u24 error_line_number){
    if(new_value_type != destination.type){
        if(grow_type(new_value_type, destination.type, destination.offset_size) != 0){
            printf("\nerror on line %d: Cannot assign '", u24_unpack(error_line_number));
            type_print(types[new_value_type]);
            printf("' to '");
            type_print(types[destination.type]);
            printf("'\n");
            return TYPES_CAPACITY;
        }

        new_value_type = destination.type;
    }

    return write_destination_unsafe(new_value_type, destination, error_line_number);
}

u32 write_destination_unsafe(u32 new_value_type, Destination destination, u24 error_line_number){
    u32 type_size = type_sizeof_or_max(new_value_type, error_line_number);
    if(type_size == -1) return TYPES_CAPACITY;

    // Point to last cell of new-value/index combination
    printf("<");
    emit_context.current_cell_index--;

    if(destination.offset_size == 0){
        move_cells_static(destination.tape_location, type_size);
        return u0_type;
    } else if(destination.offset_size == 1){
        move_cells_dynamic_u8(destination.tape_location, type_size);
        return u0_type;
    } else if(destination.offset_size == 2){
        move_cells_dynamic_u16(destination.tape_location, type_size);
        return u0_type;
    } else if(destination.offset_size == 3){
        move_cells_dynamic_u24(destination.tape_location, type_size);
        return u0_type;
    } else if(destination.offset_size == 4){
        move_cells_dynamic_u32(destination.tape_location, type_size);
        return u0_type;
    } else {
        printf("\nerror on line %d: Cannot assign to destination with u%d offset\n", u24_unpack(error_line_number), 8*destination.offset_size);
        return TYPES_CAPACITY;
    }
}

u32 write_destination_expression(u32 new_value_type, Expression destination_expression, u24 error_line_number){
    Destination destination = expression_get_destination(destination_expression, emit_context.current_cell_index);
    if(destination.type == TYPES_CAPACITY) return TYPES_CAPACITY;

    return write_destination(new_value_type, destination, error_line_number);
}

u32 expression_emit_assign(Expression expression){
    u32 new_value = operands[expression.ops + 1];
    u32 new_value_type = expression_emit(expressions[new_value]);
    if(new_value_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    return write_destination_expression(new_value_type, expressions[operands[expression.ops]], expression.line);
}

u32 expression_emit_variable(Expression expression){
    u32 name = expression.ops;

    Variable variable = variable_find(name);

    if(!variable.defined){
        printf("\nerror on line %d: Variable '", u24_unpack(expression.line));
        print_aux_cstr(name);
        printf("' is not defined\n");
        return TYPES_CAPACITY;
    }

    u32 size = type_sizeof_or_max(variable.type, expression.line);
    if(size == -1) return TYPES_CAPACITY;

    if(variable.location.kind == VARIABLE_LOCATION_IMMUTABLE){
        if(size == 1){
            emit_u8((u8) variable.location.location);
        } else if(size == 2){
            emit_u16((u16) variable.location.location);
        } else if(size == 3){
            emit_u24(u24_pack(variable.location.location));
        } else if(size == 4){
            emit_u32((u32) variable.location.location);
        } else {
            printf("\nerror on line %d: Cannot emit immutable value of size %d\n", u24_unpack(expression.line), size);
            return TYPES_CAPACITY;
        }
        return variable.type;
    }

    if(variable.location.kind != VARIABLE_LOCATION_ON_TAPE){
        // Stack variable
        printf("\nerror: stack/immutable variable expression not supported yet\n");
        return TYPES_CAPACITY;
    }

    if(variable.depth == 0){
        // Global variable
        copy_cells_static(variable.location.location, size);
        return variable.type;
    }

    // Tape variable
    copy_cells_static(variable.location.location, size);
    return variable.type;
}

u32 expression_emit_cast(Expression expression){
    u32 from_type = expression_emit(expressions[operands[expression.ops + 1]]);
    if(from_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    u32 to_type = operands[expression.ops];

    /* Allow self-casting and casting between u1 and u8 */
    if((from_type == u1_type && to_type == u8_type) || from_type == to_type){
        return to_type;
    }

    /* Allow casting to u1 */
    if(to_type == u1_type){
        if(from_type == u8_type){
            emit_u8(0);
            emit_neq_u8();
            return to_type;
        }

        if(from_type == u16_type){
            emit_u16(0);
            emit_neq_u16();
            return to_type;
        }

        if(from_type == u32_type){
            emit_u32(0);
            emit_neq_u32();
            return to_type;
        }
    }

    /* Allow valid casting from 1 cell to 2 cell types */
    if((from_type == u1_type || from_type == u8_type) && to_type == u16_type){
        printf("[-]>");
        emit_context.current_cell_index++;
        return to_type;
    }

    /* Allow valid casting from 2 cell to 4 cell types */
    if(from_type == u16_type && to_type == u32_type){
        printf("[-]>[-]>");
        emit_context.current_cell_index += 2;
        return to_type;
    }

    /* Allow valid casting from 1 cell to 4 cell types */
    if((from_type == u1_type || from_type == u8_type) && to_type == u32_type){
        printf("[-]>[-]>[-]>");
        emit_context.current_cell_index += 3;
        return to_type;
    }

    u32 from_enum = find_enum_from_type(from_type);
    u32 to_enum = find_enum_from_type(to_type);

    // Try to cast from enum to integer
    if(from_enum != TYPEDEFS_CAPACITY){
        TypeDef def = typedefs[from_enum];

        if(to_type == u8_type && def.computed_size == 1){
            return to_type;
        } else if(to_type == u16_type && def.computed_size == 2){
            return to_type;
        } else if(to_type == u24_type && def.computed_size == 3){
            return to_type;
        } else if(to_type == u32_type && def.computed_size == 4){
            return to_type;
        }
    }

    if(to_enum != TYPEDEFS_CAPACITY){
        TypeDef def = typedefs[to_enum];

        if(from_type == u8_type && def.computed_size == 1){
            return to_type;
        } else if(from_type == u16_type && def.computed_size == 2){
            return to_type;
        } else if(from_type == u24_type && def.computed_size == 3){
            return to_type;
        } else if(from_type == u32_type && def.computed_size == 4){
            return to_type;
        }
    }

    if(to_type == u0_type){
        u32 size = type_sizeof_or_max(from_type, expression.line);
        if(size == -1) return TYPES_CAPACITY;

        printf("%d<", size);
        emit_context.current_cell_index -= size;
        return to_type;
    }

    if(to_type == u8_type){
        if(from_type == u16_type){
            printf("<");
            emit_context.current_cell_index -= 1;
            return to_type;
        } else if(from_type == u24_type){
            printf("2<");
            emit_context.current_cell_index -= 2;
            return to_type;
        } else if(from_type == u32_type){
            printf("3<");
            emit_context.current_cell_index -= 3;
            return to_type;
        }
    }

    if(to_type == u16_type){
        if(from_type == u24_type){
            printf("<");
            emit_context.current_cell_index -= 1;
            return to_type;
        } else if(from_type == u32_type){
            printf("2<");
            emit_context.current_cell_index -= 2;
            return to_type;
        }
    }

    printf("\nerror on line %d: Cannot cast '", u24_unpack(expression.line));
    type_print(types[from_type]);
    printf("' to '");
    type_print(types[to_type]);
    printf("'\n");
    return TYPES_CAPACITY;
}

u32 emit_math_u8(ExpressionKind kind, u32 operand_type){
    switch(kind){
    case EXPRESSION_ADD:
        emit_additive_u8(true);
        return operand_type;
    case EXPRESSION_SUBTRACT:
        emit_additive_u8(false);
        return operand_type;
    case EXPRESSION_MULTIPLY:
        emit_multiply_u8();
        return operand_type;
    case EXPRESSION_DIVIDE:
        emit_divide_u8();
        return operand_type;
    case EXPRESSION_MOD:
        emit_mod_u8();
        return operand_type;
    case EXPRESSION_EQUALS:
        emit_eq_u8();
        return u1_type;
    case EXPRESSION_NOT_EQUALS:
        emit_neq_u8();
        return u1_type;
    case EXPRESSION_LESS_THAN:
        emit_lt_u8();
        return u1_type;
    case EXPRESSION_GREATER_THAN:
        emit_gt_u8();
        return u1_type;
    case EXPRESSION_LESS_THAN_OR_EQUAL:
        emit_lte_u8();
        return u1_type;
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
        emit_gte_u8();
        return u1_type;
    case EXPRESSION_LSHIFT:
        emit_lshift_u8();
        return operand_type;
    case EXPRESSION_RSHIFT:
        emit_rshift_u8();
        return operand_type;
    case EXPRESSION_BIT_AND:
        emit_bit_and_u8();
        return operand_type;
    case EXPRESSION_BIT_OR:
        emit_bit_or_u8();
        return operand_type;
    case EXPRESSION_BIT_XOR:
        emit_bit_xor_u8();
        return operand_type;
    default:
        printf("\nerror: Could not perform unknown math operation for expression kind %d\n", (u8) kind);
        return TYPES_CAPACITY;
    }

    return 0;
}

u32 emit_math_u16(ExpressionKind kind, u32 operand_type){
    switch(kind){
    case EXPRESSION_ADD:
        emit_additive_u16(true);
        return operand_type;
    case EXPRESSION_SUBTRACT:
        emit_additive_u16(false);
        return operand_type;
    case EXPRESSION_MULTIPLY:
        emit_multiply_u16();
        return operand_type;
    case EXPRESSION_DIVIDE:
        emit_divide_u16();
        return operand_type;
    case EXPRESSION_MOD:
        emit_mod_u16();
        return operand_type;
    case EXPRESSION_EQUALS:
        emit_eq_u16();
        return u1_type;
    case EXPRESSION_NOT_EQUALS:
        emit_neq_u16();
        return u1_type;
    case EXPRESSION_LESS_THAN:
        emit_lt_u16();
        return u1_type;
    case EXPRESSION_GREATER_THAN:
        emit_gt_u16();
        return u1_type;
    case EXPRESSION_LESS_THAN_OR_EQUAL:
        emit_lte_u16();
        return u1_type;
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
        emit_gte_u16();
        return u1_type;
    case EXPRESSION_LSHIFT:
        emit_lshift_u16();
        return operand_type;
    case EXPRESSION_RSHIFT:
        emit_rshift_u16();
        return operand_type;
    case EXPRESSION_BIT_AND:
        emit_bit_and_u16();
        return operand_type;
    case EXPRESSION_BIT_OR:
        emit_bit_or_u16();
        return operand_type;
    case EXPRESSION_BIT_XOR:
        emit_bit_xor_u16();
        return operand_type;
    default:
        printf("\nerror: Could not perform unknown math operation for expression kind %d\n", (u8) kind);
        return TYPES_CAPACITY;
    }

    return 0;
}

u32 emit_math_u32(ExpressionKind kind, u32 operand_type){
    switch(kind){
    case EXPRESSION_ADD:
        emit_additive_u32(true);
        return operand_type;
    case EXPRESSION_SUBTRACT:
        emit_additive_u32(false);
        return operand_type;
    case EXPRESSION_MULTIPLY:
        emit_multiply_u32();
        return operand_type;
    case EXPRESSION_DIVIDE:
        emit_divide_u32();
        return operand_type;
    case EXPRESSION_MOD:
        emit_mod_u32();
        return operand_type;
    case EXPRESSION_EQUALS:
        emit_eq_u32();
        return u1_type;
    case EXPRESSION_NOT_EQUALS:
        emit_neq_u32();
        return u1_type;
    case EXPRESSION_LESS_THAN:
        emit_lt_u32();
        return u1_type;
    case EXPRESSION_GREATER_THAN:
        emit_gt_u32();
        return u1_type;
    case EXPRESSION_LESS_THAN_OR_EQUAL:
        emit_lte_u32();
        return u1_type;
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
        emit_gte_u32();
        return u1_type;
    case EXPRESSION_LSHIFT:
        emit_lshift_u32();
        return operand_type;
    case EXPRESSION_RSHIFT:
        emit_rshift_u32();
        return operand_type;
    case EXPRESSION_BIT_AND:
        emit_bit_and_u32();
        return operand_type;
    case EXPRESSION_BIT_OR:
        emit_bit_or_u32();
        return operand_type;
    case EXPRESSION_BIT_XOR:
        emit_bit_xor_u32();
        return operand_type;
    default:
        printf("\nerror: Could not perform unknown math operation for expression kind %d\n", (u8) kind);
        return TYPES_CAPACITY;
    }

    return 0;
}

u32 expression_emit_unary_operation(Expression expression, u32 type){
    switch(expression.kind){
    case EXPRESSION_NOT:
        if(type == u1_type){
            emit_not_u1();
            return type;
        }
        break;
    case EXPRESSION_NEGATE:
        if(type == u8_type){
            emit_negate_u8();
            return type;
        } else if(type == u16_type){
            emit_negate_u16();
            return type;
        } else if(type == u32_type){
            emit_negate_u32();
            return type;
        }
        break;
    case EXPRESSION_BIT_COMPLEMENT:
        if(type == u8_type || type == u1_type){
            emit_bit_complement_u8();
            return type;
        } else if(type == u16_type){
            emit_bit_complement_u16();
            return type;
        } else if(type == u32_type){
            emit_bit_complement_u32();
            return type;
        }
        break;
    case EXPRESSION_PRE_INCREMENT:
    case EXPRESSION_PRE_DECREMENT:
        if(type == u8_type){
            emit_u8(1);
            emit_additive_u8(expression.kind == EXPRESSION_PRE_INCREMENT);
            dupe_cell();
            if(write_destination_expression(u8_type, expressions[expression.ops], expression.line) == TYPES_CAPACITY){
                return TYPES_CAPACITY;
            }
            return type;
        } else if(type == u16_type){
            emit_u16(1);
            emit_additive_u16(expression.kind == EXPRESSION_PRE_INCREMENT);
            dupe_cells(2);
            if(write_destination_expression(u16_type, expressions[expression.ops], expression.line) == TYPES_CAPACITY){
                return TYPES_CAPACITY;
            }
            return type;
        } else if(type == u32_type){
            emit_u32(1);
            emit_additive_u32(expression.kind == EXPRESSION_PRE_INCREMENT);
            dupe_cells(4);
            if(write_destination_expression(u32_type, expressions[expression.ops], expression.line) == TYPES_CAPACITY){
                return TYPES_CAPACITY;
            }
            return type;
        }
        break;
    case EXPRESSION_POST_INCREMENT:
    case EXPRESSION_POST_DECREMENT:
        if(type == u8_type){
            dupe_cell();
            emit_u8(1);
            emit_additive_u8(expression.kind == EXPRESSION_POST_INCREMENT);
            if(write_destination_expression(u8_type, expressions[expression.ops], expression.line) == TYPES_CAPACITY){
                return TYPES_CAPACITY;
            }
            return type;
        } else if(type == u16_type){
            dupe_cells(2);
            emit_u16(1);
            emit_additive_u16(expression.kind == EXPRESSION_POST_INCREMENT);
            if(write_destination_expression(u16_type, expressions[expression.ops], expression.line) == TYPES_CAPACITY){
                return TYPES_CAPACITY;
            }
            return type;
        } else if(type == u32_type){
            dupe_cells(4);
            emit_u32(1);
            emit_additive_u32(expression.kind == EXPRESSION_POST_INCREMENT);
            if(write_destination_expression(u32_type, expressions[expression.ops], expression.line) == TYPES_CAPACITY){
                return TYPES_CAPACITY;
            }
            return type;
        }
        break;
    case EXPRESSION_NO_RESULT_INCREMENT:
    case EXPRESSION_NO_RESULT_DECREMENT:
        if(type == u8_type){
            emit_u8(1);
            emit_additive_u8(expression.kind == EXPRESSION_NO_RESULT_INCREMENT);
            if(write_destination_expression(u8_type, expressions[expression.ops], expression.line) == TYPES_CAPACITY){
                return TYPES_CAPACITY;
            }
            return u0_type;
        } else if(type == u16_type){
            emit_u16(1);
            emit_additive_u16(expression.kind == EXPRESSION_NO_RESULT_INCREMENT);
            if(write_destination_expression(u16_type, expressions[expression.ops], expression.line) == TYPES_CAPACITY){
                return TYPES_CAPACITY;
            }
            return u0_type;
        } else if(type == u32_type){
            emit_u32(1);
            emit_additive_u32(expression.kind == EXPRESSION_NO_RESULT_INCREMENT);
            if(write_destination_expression(u32_type, expressions[expression.ops], expression.line) == TYPES_CAPACITY){
                return TYPES_CAPACITY;
            }
            return u0_type;
        }
        break;
    default:
        break;
    }

    u32 enum_typedef = find_enum_from_type(type);

    if(enum_typedef < TYPEDEFS_CAPACITY){
        return expression_emit_unary_operation(expression, u8_type);
    }

    printf("\nerror on line %d: Cannot ", u24_unpack(expression.line));
    expression_print_operation_name(expression.kind);
    printf(" value of type '");
    type_print(types[type]);
    printf("'\n");
    return TYPES_CAPACITY;
}

u32 expression_emit_unary(Expression expression){
    u32 type = expression_emit(expressions[expression.ops]);
    if(type == TYPES_CAPACITY) return TYPES_CAPACITY;

    return expression_emit_unary_operation(expression, type);
}

u32 expression_emit_math_operation(Expression expression, u32 a_type){
    if(a_type == u8_type){
        return emit_math_u8(expression.kind, a_type);
    }

    if(a_type == u16_type){
        return emit_math_u16(expression.kind, a_type);
    }

    if(a_type == u32_type){
        return emit_math_u32(expression.kind, a_type);
    }

    // Allow bitwise operations on u1 types
    if(a_type == u1_type && (
        expression.kind == EXPRESSION_BIT_AND
     || expression.kind == EXPRESSION_BIT_OR
     || expression.kind == EXPRESSION_BIT_XOR
    )){
        return emit_math_u8(expression.kind, a_type);
    }

    u32 enum_typedef = find_enum_from_type(a_type);

    if(enum_typedef < TYPEDEFS_CAPACITY){
        return expression_emit_math_operation(expression, u8_type);
    }

    printf("\nerror on line %d: Cannot ", u24_unpack(expression.line));
    expression_print_operation_name(expression.kind);
    printf(" values of type '");
    type_print(types[a_type]);
    printf("'\n");
    return TYPES_CAPACITY;
}

u32 expression_emit_math(Expression expression){
    u32 a = operands[expression.ops];
    u32 b = operands[expression.ops + 1];

    u32 a_type = expression_emit(expressions[a]);
    if(a_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    u32 b_type = expression_emit(expressions[b]);
    if(b_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    if(a_type != b_type){
        printf("\nerror on line %d: Cannot ", u24_unpack(expression.line));
        expression_print_operation_name(expression.kind);
        printf(" incompatible types '");
        type_print(types[a_type]);
        printf("' and '");
        type_print(types[b_type]);
        printf("'\n");
        return TYPES_CAPACITY;
    }

    return expression_emit_math_operation(expression, a_type);
}

u32 expression_emit_and(Expression expression){
    // Allocate result cell
    printf("[-]>");
    emit_context.current_cell_index++;

    // Evaluate left hand side
    u32 a_type = expression_emit(expressions[operands[expression.ops]]);
    if(a_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    // Convert to boolean
    if(a_type != u1_type){
        printf("\nerror on line %d: Expected first operand of '&&' to be 'u1'", u24_unpack(expression.line));
        printf(", got '");
        type_print(types[a_type]);
        printf("'\n");
        return TYPES_CAPACITY;
    }

    // Go to first operand
    printf("<");
    emit_context.current_cell_index--;

    // If first operand is non-zero
    printf("[");

    // Zero first operand
    printf("[-]");

    // Evaluate right hand side
    u32 b_type = expression_emit(expressions[operands[expression.ops + 1]]);
    if(b_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    // Convert to boolean
    if(b_type != u1_type){
        printf("\nerror on line %d: Expected second operand of '&&' to be 'u1'", u24_unpack(expression.line));
        printf(", got '");
        type_print(types[b_type]);
        printf("'\n");
        return TYPES_CAPACITY;
    }

    // Go to second operand
    printf("<");
    emit_context.current_cell_index--;

    // If second operand is non-zero
    printf("[");

    // Set result to 1
    printf("<+>");

    // Zero second operand
    printf("[-]");

    // End if
    printf("]");

    // End if
    printf("]");

    // Remain pointing to the next available cell
    // (nothing to do)

    return u1_type;
}

u32 expression_emit_or(Expression expression){
    // Allocate result cell
    printf("[-]>");
    emit_context.current_cell_index++;

    // Set whether to evaluate second operand to true
    printf("[-]+");

    // Point to next available cell
    printf(">");
    emit_context.current_cell_index++;

    // Evaluate left hand side
    u32 a_type = expression_emit(expressions[operands[expression.ops]]);
    if(a_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    // Convert to boolean
    if(a_type != u1_type){
        printf("\nerror on line %d: First operand to '&&' must be a 'u1'\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    // Go to first operand
    printf("<");
    emit_context.current_cell_index--;

    // If first operand is non-zero
    printf("[");

    // Set result to 1
    printf("<<+");

    // Set whether to check second operand to false
    printf(">-");

    // Zero first operand
    printf(">[-]");

    // End if
    printf("]");

    // Go to 'whether to check second operand'
    printf("<");
    emit_context.current_cell_index--;

    // If 'whether to check second operand' is non-zero
    printf("[");

    // Evaluate right hand side
    u32 b_type = expression_emit(expressions[operands[expression.ops + 1]]);
    if(b_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    // Convert to boolean
    if(a_type != u1_type){
        printf("\nerror on line %d: Second operand to '&&' must be a 'u1'\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    // Go to second operand
    printf("<");
    emit_context.current_cell_index--;

    // If second operand is non-zero
    printf("[");

    // Set result to 1
    printf("<+>");

    // Zero second operand
    printf("[-]");

    // End if
    printf("]");

    // End if
    printf("]");

    // Remain pointing to the next available cell
    // (nothing to do)

    return u1_type;
}

u32 read_destination(Destination destination, u24 line_on_error){
    if(destination.on_stack){
        printf("\nerror on line %d: Cannot index into destination on the stack yet (not supported)\n", u24_unpack(line_on_error));
        return TYPES_CAPACITY;
    }

    u32 item_type_size = type_sizeof_or_max(destination.type, line_on_error);
    if(item_type_size == -1) return TYPES_CAPACITY;

    if(destination.offset_size == 0){
        copy_cells_static(destination.tape_location, item_type_size);
        return destination.type;
    } else if(destination.offset_size == 1){
        // u8 indexing
        copy_cells_dynamic_u8(destination.tape_location, item_type_size);
        return destination.type;
    } else if(destination.offset_size == 2){
        // u16 indexing
        copy_cells_dynamic_u16(destination.tape_location, item_type_size);
        return destination.type;
    } else if(destination.offset_size == 3){
        // u24 indexing
        copy_cells_dynamic_u24(destination.tape_location, item_type_size);
        return destination.type;
    } else if(destination.offset_size == 4){
        // u32 indexing
        copy_cells_dynamic_u32(destination.tape_location, item_type_size);
        return destination.type;
    } else {
        printf("\nerror on line %d: Cannot use index of type 'u%d'\n", u24_unpack(line_on_error), destination.offset_size * 8);
        return TYPES_CAPACITY;
    }
}

u32 expression_emit_read_destination(Expression expression){
    u32 tape_anchor = emit_context.current_cell_index;

    // Calculate subject destination
    Destination destination = expression_get_destination(expression, tape_anchor);
    if(destination.type == TYPES_CAPACITY) return TYPES_CAPACITY;

    return read_destination(destination, expression.line);
}

ErrorCode print_array_reference(Destination destination, u32 max_length, u24 line_on_error){
    if(destination.offset_size == 0){
        print_cells_static(destination.tape_location, max_length);
    } else {
        // TODO: Optimize this
        // Ignore reference and just copy and print the value

        if(read_destination(destination, line_on_error) == TYPES_CAPACITY){
            return 1;
        }

        emit_print_array_value(max_length);
    }

    return 0;
}

u32 expression_emit_ternary_stack(Expression expression){
    u32 condition = operands[expression.ops];
    u32 when_true = operands[expression.ops + 1];
    u32 when_false = operands[expression.ops + 2];

    // Evaluate condition
    u32 condition_type = expression_emit(expressions[condition]);
    if(condition_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    if(condition_type != u1_type){
        printf("\nerror on line %d: Expected ternary condition to be 'u1', got '", u24_unpack(expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return TYPES_CAPACITY;
    }

    u32 then_block = emit_settings.next_basicblock_id++;
    u32 else_block = emit_settings.next_basicblock_id++;
    u32 continuation_block = emit_settings.next_basicblock_id++;

    u32 pushed = emit_end_basicblock_jump_conditional(then_block, else_block);

    // Then block
    emit_start_basicblock_landing(then_block, pushed);

    u32 when_true_type = expression_emit(expressions[when_true]);
    if(when_true_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    u32 result_size = type_sizeof_or_max(when_true_type, expression.line);
    if(result_size == -1) return TYPES_CAPACITY;

    if(emit_settings.in_basicblock){
        emit_end_basicblock_jump_compatible(continuation_block, pushed + result_size);
    }

    // Else block
    emit_start_basicblock_landing(else_block, pushed);

    u32 when_false_type = expression_emit(expressions[when_false]);
    if(when_false_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    if(when_false_type != when_true_type){
        printf("\nerror on line %d: Expected false branch of ternary expression to be '", u24_unpack(expression.line));
        type_print(types[when_true_type]);
        printf("', got '");
        type_print(types[when_false_type]);
        printf("'\n");
        return TYPES_CAPACITY;
    }

    if(emit_settings.in_basicblock){
        emit_end_basicblock_jump_compatible(continuation_block, pushed + result_size);
    }

    // Continuation block
    emit_start_basicblock_landing(continuation_block, pushed + result_size);
    return when_true_type;
}

u32 expression_emit_ternary_tape(Expression expression){
    // result should_do_else condition

    u32 condition = operands[expression.ops];
    u32 when_true = operands[expression.ops + 1];
    u32 when_false = operands[expression.ops + 2];

    u32 result_type = expression_get_type(expressions[when_true], EXPRESSION_GET_TYPE_MODE_PRINT_ERROR);
    u32 result_size;

    if(result_type < TYPES_CAPACITY){
        result_size = type_sizeof_or_max(result_type, expression.line);
        if(result_size == -1) return TYPES_CAPACITY;
    } else {
        printf("\nerror on line %d: Could not determine result size for ternary expression\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    // Allocate room for result
    printf("%d>", result_size);
    emit_context.current_cell_index += result_size;

    // Allocate 'should_do_else' cell and initialize to 1
    printf("[-]+>");
    emit_context.current_cell_index++;

    // Evaluate condition
    u32 condition_type = expression_emit(expressions[condition]);
    if(condition_type == TYPES_CAPACITY) return TYPES_CAPACITY;
    
    if(condition_type != u1_type){
        printf("\nerror on line %d: Expected ternary condition to be 'u1', got '", u24_unpack(expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return TYPES_CAPACITY;
    }

    // Go to 'condition' cell
    printf("<");
    emit_context.current_cell_index--;

    // If 'condition' cell
    printf("[");

    // Evaluate true branch
    printf("%d<", result_size + 1);
    emit_context.current_cell_index -= result_size + 1;

    u32 when_true_type = expression_emit(expressions[when_true]);
    if(when_true_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    if(when_true_type != result_type){
        printf("\nerror on line %d: Expected true branch of ternary expression to be '", u24_unpack(expression.line));
        type_print(types[result_type]);
        printf("', got '");
        type_print(types[when_true_type]);
        printf("'\n");
        return TYPES_CAPACITY;
    }

    // Zero 'should_do_else' cell and 'condition' cell,
    printf("[-]>[-]");
    emit_context.current_cell_index++;

    // End if
    printf("]");

    // Go to 'should_do_else' cell
    printf("<");
    emit_context.current_cell_index--;

    // If 'should_do_else' cell
    printf("[");

    // Evaluate false branch
    printf("%d<", result_size);
    emit_context.current_cell_index -= result_size;

    u32 when_false_type = expression_emit(expressions[when_false]);
    if(when_false_type == TYPES_CAPACITY) return TYPES_CAPACITY;

    if(when_false_type != result_type){
        printf("\nerror on line %d: Expected false branch of ternary expression to be '", u24_unpack(expression.line));
        type_print(types[result_type]);
        printf("', got '");
        type_print(types[when_false_type]);
        printf("'\n");
        return TYPES_CAPACITY;
    }

    // Zero 'should_do_else' cell,
    // and end if
    printf("[-]");
    printf("]");

    return result_type;
}

u32 expression_emit_ternary(Expression expression){
    if(emit_context.in_recursive_function){
        return expression_emit_ternary_stack(expression);
    } else {
        return expression_emit_ternary_tape(expression);
    }
}


u32 expression_emit_string(Expression expression){
    u32 str = expression.ops;
    u32 len = aux_cstr_len(str);

    for(u32 i = 0; i < len; i++){
        printf("[-]%d+", aux[str + i]);
        printf(">");
    }

    emit_context.current_cell_index += len;

    return expression_get_type_for_string(expression);
}

u32 expression_emit_return(Expression expression){
    u32 return_type = functions[emit_context.function].return_type;
    u32 value_type;

    if(expression.ops == EXPRESSIONS_CAPACITY){
        // `return;`
        value_type = u0_type;
    } else {
        // `return value;`
        value_type = expression_emit(expressions[expression.ops]);
        if(value_type == TYPES_CAPACITY) return TYPES_CAPACITY;
    }

    if(value_type != return_type){
        if(grow_type(value_type, return_type, 0) != 0){
            printf("\nerror on line %d: ", u24_unpack(expression.line));
            printf("Expected '");
            type_print(types[return_type]);
            printf("' return value, but got type '");
            type_print(types[value_type]);
            printf("'\n");
            return TYPES_CAPACITY;
        }

        value_type = return_type;
    }

    u32 return_type_size = type_sizeof_or_max(return_type, expression.line);
    if(return_type_size == -1) return TYPES_CAPACITY;

    if(emit_context.in_recursive_function){
        emit_stack_pointer();
        emit_u32(4 + return_type_size);
        emit_additive_u32(false);

        // Point to last cell of data value
        printf("<");
        emit_context.current_cell_index--;

        // Move data value into return value location
        move_cells_dynamic_u32(emit_settings.stack_begin, return_type_size);

        // Remove working memory
        printf("%d<", emit_context.current_cell_index - emit_settings.stack_driver_position);
        emit_context.current_cell_index = emit_settings.stack_driver_position;

        // End basicblock
        emit_end_basicblock();
    } else {
        // Point to last cell of data value
        printf("<");
        emit_context.current_cell_index--;

        u32 return_value_location = emit_context.function_cell_index - return_type_size;

        // Move data value into return value location
        move_cells_static(return_value_location, return_type_size);

        // Unmark 'incomplete' cell if function can early return
        if(emit_context.can_function_early_return){
            u32 offset = emit_context.current_cell_index - emit_context.incomplete_cell;
            printf("%d<[-]%d>", offset, offset);
        }
    }

    return u0_type;
}

u32 expression_emit_break(Expression expression){
    if(!emit_settings.can_break){
        printf("\nerror on line %d: Cannot break, nowhere to go\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    if(emit_context.in_recursive_function){
        emit_end_basicblock_jump_to(emit_settings.break_basicblock_context);
    } else {
        // Zero 'didnt_break_cell'
        u32 offset = emit_context.current_cell_index - emit_context.didnt_break_cell;
        printf("%d<[-]%d>", offset, offset);
    }

    return u0_type;
}

u32 expression_emit_continue(Expression expression){
    if(!emit_settings.can_continue){
        printf("\nerror on line %d: Cannot continue, nowhere to go\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    if(emit_context.in_recursive_function){
        emit_end_basicblock_jump_to(emit_settings.continue_basicblock_context);
    } else {
        // Zero 'didnt_continue_cell'
        u32 offset = emit_context.current_cell_index - emit_context.didnt_continue_cell;
        printf("%d<[-]%d>", offset, offset);
    }

    return u0_type;
}

u32 emit_sizeof_size(u32 type_index, u8 integer_cells, u24 line_on_error){
    u32 size = type_sizeof_or_max(type_index, line_on_error);
    if(size == -1) return TYPES_CAPACITY;

    u32 max_values[5] = {
        (u32) 0,
        (u32) 255,
        (u32) 65535,
        (u32) 16777215,
        (u32) 4294967295,
    };

    if(!in_range_inclusive(integer_cells, 1, 4) || size > max_values[integer_cells]){
        printf("\nerror on line %d: Cannot emit size of '", u24_unpack(line_on_error));
        type_print(types[type_index]);
        printf("' as 'u%d' (maximum size exceeded)\n", integer_cells * 8);
        return TYPES_CAPACITY;
    }

    switch(integer_cells){
    case 1:
        emit_u8((u8) size);
        return u8_type;
    case 2:
        emit_u16((u16) size);
        return u16_type;
    case 3:
        emit_u24(u24_pack(size));
        return u24_type;
    case 4:
        emit_u32(size);
        return u32_type;
    }

    printf("\nerror on line %d: Cannot emit size of '", u24_unpack(line_on_error));
    type_print(types[type_index]);
    printf("' as 'u%d' (maximum size exceeded)\n", integer_cells * 8);
    return TYPES_CAPACITY;
}

u32 expression_emit_sizeof_type(Expression expression, u8 integer_cells){
    return emit_sizeof_size(expression.ops, integer_cells, expression.line);
}

u32 expression_emit_sizeof_value(Expression expression, u8 integer_cells){
    u32 expression_type = expression_get_type(expressions[expression.ops], EXPRESSION_GET_TYPE_MODE_PRINT_ERROR);

    if(expression_type == TYPES_CAPACITY){
        printf("\nerror on line %d: Could not determine size of expression, perhaps you have undeclared variables?", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    return emit_sizeof_size(expression_type, integer_cells, expression.line);
}

u32 expression_emit_array_initializer(Expression expression){
    u32 element_type = u0_type;
    u32 length = operands[expression.ops];

    for(u32 i = 0; i < length; i++){
        u32 item_type = expression_emit(expressions[operands[expression.ops + 1 + i]]);
        if(item_type == TYPES_CAPACITY) return item_type;

        if(i == 0){
            element_type = item_type;
        } else if(item_type != element_type){
            printf("\nerror on line %d: Element %d of array initializer has different type than first element\n", u24_unpack(expression.line), i + 1);
            printf("  Expected '");
            type_print(types[element_type]);
            printf("',");
            printf(" got '");
            type_print(types[item_type]);
            printf("'\n");
            return TYPES_CAPACITY;
        }
    }

    u32 new_dims[4];
    memcpy(new_dims, dimensions[types[element_type].dimensions], sizeof new_dims);

    u8 empty_i = 0;
    for(empty_i = 0; empty_i < 4; empty_i++){
        if(new_dims[empty_i] == 0){
            break;
        }
    }

    if(empty_i >= 4){
        printf("\nerror on line %d: Cannot create array intializer with element type that already has maximum number of dimensions\n", u24_unpack(expression.line));
        return TYPES_CAPACITY;
    }

    new_dims[empty_i] = length;

    u32 initializer_type_dimensions = add_dimensions(new_dims);
    if(initializer_type_dimensions >= UNIQUE_DIMENSIONS_CAPACITY) return TYPES_CAPACITY;

    Type initializer_type = (Type){
        .name = types[element_type].name,
        .dimensions = initializer_type_dimensions,
    };

    return add_type(initializer_type);
}

u32 expression_emit_struct_initializer(Expression expression){
    u32 type = operands[expression.ops];

    u32 type_size = type_sizeof_or_max(type, expression.line);
    if(type_size == -1) return TYPES_CAPACITY;

    // Allocate space for result
    for(u32 i = 0; i < type_size; i++){
        printf("[-]>");
        emit_context.current_cell_index++;
    }

    // Set fields
    u32 length = operands[expression.ops + 1];
    u32 out_struct_location = emit_context.current_cell_index - type_size;

    for(u32 i = 0; i < length; i++){
        Expression field_initializer = expressions[operands[expression.ops + 2 + i]];

        // Assume expression is field initializer expression
        u32 field_name = operands[field_initializer.ops];
        u32 field_value = operands[field_initializer.ops + 1];

        u32 field_value_type = expression_emit(expressions[field_value]);
        if(field_value_type == TYPES_CAPACITY) return TYPES_CAPACITY;

        Destination destination = (Destination){
            .type = type,
            .on_stack = false,
            .offset_size = 0,
            .tape_location = out_struct_location,
        };

        destination = destination_member(destination, field_name, field_initializer.line);
        if(destination.type == TYPES_CAPACITY) return TYPES_CAPACITY;

        u32 result = write_destination(field_value_type, destination, field_initializer.line);
        if(result == TYPES_CAPACITY) return TYPES_CAPACITY;
    }

    return type;
}

u32 expression_emit(Expression expression){
    switch(expression.kind){
    case EXPRESSION_NONE:
    case EXPRESSION_IF:
    case EXPRESSION_IF_ELSE:
    case EXPRESSION_WHILE:
    case EXPRESSION_DO_WHILE:
    case EXPRESSION_CONDITIONLESS_BLOCK:
    case EXPRESSION_FOR:
    case EXPRESSION_SWITCH:
        break;
    case EXPRESSION_DECLARE: {
            u32 variable_size = type_sizeof_or_max(operands[expression.ops], expression.line);
            if(variable_size == -1){
                printf("    In variable declaration on line %d\n", u24_unpack(expression.line));
                return TYPES_CAPACITY;
            }

            for(u32 j = 0; j < variable_size; j++){
                printf("[-]>");
            }

            emit_context.current_cell_index += variable_size;
        }
        return u0_type;
    case EXPRESSION_PRINT_LITERAL:
        emit_print_aux_cstr(expression.ops);
        return u0_type;
    case EXPRESSION_PRINT_ARRAY: {
            if(is_destination(expressions[expression.ops])){
                // Print reference
                u32 tape_anchor = emit_context.current_cell_index;
                Destination destination = expression_get_destination(expressions[expression.ops], tape_anchor);
                if(destination.type == TYPES_CAPACITY) return TYPES_CAPACITY;

                if(get_item_type(types[destination.type], expression.line, false) != u8_type){
                    printf("\nerror on line %d: Can only print 'u8[]' but got '", u24_unpack(expression.line));
                    type_print(types[destination.type]);
                    printf("'\n");
                    return TYPES_CAPACITY;
                }

                u32 max_length = dimensions[types[destination.type].dimensions][0];
                if(print_array_reference(destination, max_length, expression.line) != 0){
                    return TYPES_CAPACITY;
                }
            } else {
                // Print value
                u32 array_type = expression_emit(expressions[expression.ops]);
                if(array_type == TYPES_CAPACITY) return TYPES_CAPACITY;

                if(get_item_type(types[array_type], expression.line, false) != u8_type){
                    printf("\nerror on line %d: Can only print 'u8[]' but got '", u24_unpack(expression.line));
                    type_print(types[array_type]);
                    printf("'\n");
                    return TYPES_CAPACITY;
                }

                u32 max_length = dimensions[types[array_type].dimensions][0];
                emit_print_array_value(max_length);
            }
        }
        return u0_type;
    case EXPRESSION_PRINTF:
        return expression_emit_printf(expression);
    case EXPRESSION_MEMCMP:
        return expression_emit_memcmp(expression);
    case EXPRESSION_MEMCPY:
        return expression_emit_memcpy(expression);
    case EXPRESSION_CALL:
        return expression_emit_call(expression);
    case EXPRESSION_IMPLEMENT_PUT:
        printf("<.>");
        return u0_type;
    case EXPRESSION_IMPLEMENT_PRINTU1:
        emit_printu1();
        return u0_type;
    case EXPRESSION_IMPLEMENT_PRINTU8:
        emit_printu8();
        return u0_type;
    case EXPRESSION_IMPLEMENT_GET:
        printf("<,>");
        return u0_type;
    case EXPRESSION_IMPLEMENT_READU8:
        printf("<[-]>[-]+[[-]>[-],[+[11-[>[-]6+[<6->-]<--<<[->>10+<<]>>[-<<+>>]<+>]]]<]");
        return u0_type;
    case EXPRESSION_U1:
        emit_u1((u1) expression.ops);
        return u1_type;
    case EXPRESSION_INT:
        if(expression.ops >= 256){
            printf("\nerror on line %d: Cannot fit integer literal value into assumed type 'u8', must be explicitly casted to correct type\n", u24_unpack(expression.line));
            return TYPES_CAPACITY;
        }
    case EXPRESSION_U8:
        emit_u8((u8) expression.ops);
        return u8_type;
    case EXPRESSION_U16:
        emit_u16((u16) expression.ops);
        return u16_type;
    case EXPRESSION_U24:
        emit_u24(u24_pack(expression.ops));
        return u24_type;
    case EXPRESSION_U32:
        emit_u32(expression.ops);
        return u32_type;
    case EXPRESSION_ASSIGN:
        return expression_emit_assign(expression);
    case EXPRESSION_VARIABLE:
        return expression_emit_variable(expression);
    case EXPRESSION_CAST:
        return expression_emit_cast(expression);
    case EXPRESSION_ADD:
    case EXPRESSION_SUBTRACT:
    case EXPRESSION_MULTIPLY:
    case EXPRESSION_DIVIDE:
    case EXPRESSION_MOD:
    case EXPRESSION_EQUALS:
    case EXPRESSION_NOT_EQUALS:
    case EXPRESSION_LESS_THAN:
    case EXPRESSION_GREATER_THAN:
    case EXPRESSION_LESS_THAN_OR_EQUAL:
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
    case EXPRESSION_LSHIFT:
    case EXPRESSION_RSHIFT:
    case EXPRESSION_BIT_AND:
    case EXPRESSION_BIT_OR:
    case EXPRESSION_BIT_XOR:
        return expression_emit_math(expression);
    case EXPRESSION_AND:
        return expression_emit_and(expression);
    case EXPRESSION_OR:
        return expression_emit_or(expression);
    case EXPRESSION_INDEX:
    case EXPRESSION_MEMBER:
        return expression_emit_read_destination(expression);
    case EXPRESSION_NEGATE:
    case EXPRESSION_NOT:
    case EXPRESSION_BIT_COMPLEMENT:
    case EXPRESSION_PRE_INCREMENT:
    case EXPRESSION_PRE_DECREMENT:
    case EXPRESSION_POST_INCREMENT:
    case EXPRESSION_POST_DECREMENT:
    case EXPRESSION_NO_RESULT_INCREMENT:
    case EXPRESSION_NO_RESULT_DECREMENT:
        return expression_emit_unary(expression);
    case EXPRESSION_TERNARY:
        return expression_emit_ternary(expression);
    case EXPRESSION_STRING:
        return expression_emit_string(expression);
    case EXPRESSION_RETURN:
        return expression_emit_return(expression);
    case EXPRESSION_BREAK:
        return expression_emit_break(expression);
    case EXPRESSION_CONTINUE:
        return expression_emit_continue(expression);
    case EXPRESSION_SIZEOF_TYPE:
    case EXPRESSION_SIZEOF_TYPE_U8:
        return expression_emit_sizeof_type(expression, 1);
    case EXPRESSION_SIZEOF_TYPE_U16:
        return expression_emit_sizeof_type(expression, 2);
    case EXPRESSION_SIZEOF_TYPE_U24:
        return expression_emit_sizeof_type(expression, 3);
    case EXPRESSION_SIZEOF_TYPE_U32:
        return expression_emit_sizeof_type(expression, 4);
    case EXPRESSION_SIZEOF_VALUE:
    case EXPRESSION_SIZEOF_VALUE_U8:
        return expression_emit_sizeof_value(expression, 1);
    case EXPRESSION_SIZEOF_VALUE_U16:
        return expression_emit_sizeof_value(expression, 2);
    case EXPRESSION_SIZEOF_VALUE_U24:
        return expression_emit_sizeof_value(expression, 3);
    case EXPRESSION_SIZEOF_VALUE_U32:
        return expression_emit_sizeof_value(expression, 4);
    case EXPRESSION_ARRAY_INITIALIZER:
        return expression_emit_array_initializer(expression);
    case EXPRESSION_STRUCT_INITIALIZER:
        return expression_emit_struct_initializer(expression);
    case EXPRESSION_CASE:
    case EXPRESSION_FIELD_INITIALIZER:
    case EXPRESSION_ENUM_VARIANT:
        printf("\nerror: Invalid expression kind %d during expression_emit\n", (u8) expression.kind);
        return TYPES_CAPACITY;
    case EXPRESSION_PANICLOOP:
        printf("[-]+[]");
        return u0_type;
    }

    printf("\nerror: Unknown expression kind %d during expression_emit\n", (u8) expression.kind);
    return TYPES_CAPACITY;
}



u32 expression_get_type_for_call(Expression expression){
    u32 name = operands[expression.ops];
    u32 function_index = find_function(name);

    if(function_index >= FUNCTIONS_CAPACITY){
        return TYPES_CAPACITY;
    }

    return functions[function_index].return_type;
}

u32 expression_get_type_for_string(Expression expression){
    u32 str = expression.ops;
    u32 len = aux_cstr_len(str);

    u32 dims[4];
    dims[0] = len;
    dims[1] = 0;
    dims[2] = 0;
    dims[3] = 0;

    u32 type_dimensions = add_dimensions(dims);
    if(type_dimensions >= UNIQUE_DIMENSIONS_CAPACITY) return TYPES_CAPACITY;

    return add_type((Type){
        .name = types[u8_type].name,
        .dimensions = type_dimensions,
    });
}

u32 expression_get_type_for_variable(Expression expression, ExpressionGetTypeMode mode){
    u32 name = expression.ops;
    Variable variable = variable_find(name);

    if(variable.defined){
        return variable.type;
    }

    if((u1)(mode & (u8) EXPRESSION_GET_TYPE_MODE_PRINT_ERROR)){
        printf("\nerror on line %d: Variable '", u24_unpack(expression.line));
        print_aux_cstr(name);
        printf("' is not defined\n");
    }
    return TYPES_CAPACITY;
}

u32 expression_get_type(Expression expression, ExpressionGetTypeMode mode){
    switch(expression.kind){
    case EXPRESSION_NONE:
    case EXPRESSION_RETURN:
    case EXPRESSION_NO_RESULT_INCREMENT:
    case EXPRESSION_NO_RESULT_DECREMENT:
    case EXPRESSION_IF:
    case EXPRESSION_IF_ELSE:
    case EXPRESSION_WHILE:
    case EXPRESSION_DO_WHILE:
    case EXPRESSION_BREAK:
    case EXPRESSION_CONTINUE:
    case EXPRESSION_FOR:
    case EXPRESSION_CONDITIONLESS_BLOCK:
    case EXPRESSION_SWITCH:
    case EXPRESSION_CASE:
    case EXPRESSION_ARRAY_INITIALIZER:
    case EXPRESSION_FIELD_INITIALIZER:
    case EXPRESSION_ENUM_VARIANT:
    case EXPRESSION_PANICLOOP:
        break;

    case EXPRESSION_STRUCT_INITIALIZER:
        return operands[expression.ops];
    case EXPRESSION_DECLARE:
    case EXPRESSION_PRINT_LITERAL:
    case EXPRESSION_PRINT_ARRAY:
    case EXPRESSION_PRINTF:
    case EXPRESSION_MEMCPY:
    case EXPRESSION_IMPLEMENT_PUT:
    case EXPRESSION_IMPLEMENT_PRINTU1:
    case EXPRESSION_IMPLEMENT_PRINTU8:
        return u0_type;
    case EXPRESSION_IMPLEMENT_GET:
    case EXPRESSION_IMPLEMENT_READU8:
    case EXPRESSION_MEMCMP:
        return u8_type;
    case EXPRESSION_CALL:
        return expression_get_type_for_call(expression);
    case EXPRESSION_U1:
        return u1_type;
    case EXPRESSION_INT:
        if(mode == EXPRESSION_GET_TYPE_MODE_INFER){
            return TYPES_CAPACITY;
        }
        /* fallthrough */
    case EXPRESSION_U8:
        return u8_type;
    case EXPRESSION_U16:
        return u16_type;
    case EXPRESSION_U24:
        return u24_type;
    case EXPRESSION_U32:
        return u32_type;
    case EXPRESSION_ASSIGN:
        return u0_type;
    case EXPRESSION_VARIABLE:
        return expression_get_type_for_variable(expression, mode);
    case EXPRESSION_CAST:
        return operands[expression.ops];
    case EXPRESSION_ADD:
    case EXPRESSION_SUBTRACT:
    case EXPRESSION_MULTIPLY:
    case EXPRESSION_DIVIDE:
    case EXPRESSION_MOD:
    case EXPRESSION_LSHIFT:
    case EXPRESSION_RSHIFT:
    case EXPRESSION_BIT_AND:
    case EXPRESSION_BIT_OR:
    case EXPRESSION_BIT_XOR: {
            u32 type = expression_get_type(expressions[operands[expression.ops]], mode);
            if(type < TYPES_CAPACITY || !(u1)(mode & (u8) EXPRESSION_GET_TYPE_MODE_INFER)){
                return type;
            }

            return expression_get_type(expressions[operands[expression.ops + 1]], mode);
        }
    case EXPRESSION_EQUALS:
    case EXPRESSION_NOT_EQUALS:
    case EXPRESSION_LESS_THAN:
    case EXPRESSION_GREATER_THAN:
    case EXPRESSION_LESS_THAN_OR_EQUAL:
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
    case EXPRESSION_AND:
    case EXPRESSION_OR:
        return u1_type;
    case EXPRESSION_INDEX: {
            u32 array_type = expression_get_type(expressions[operands[expression.ops]], mode);
            if(array_type == TYPES_CAPACITY) return TYPES_CAPACITY;
            return get_item_type(types[array_type], expression.line, false);
        }
    case EXPRESSION_MEMBER: {
            u32 subject_type_index = expression_get_type(expressions[operands[expression.ops]], mode);
            if(subject_type_index == TYPES_CAPACITY) return TYPES_CAPACITY;

            Type subject_type = types[subject_type_index];
            if(subject_type.dimensions != 0) return TYPES_CAPACITY;

            u32 field_name = operands[expression.ops + 1];

            u32 def_index = find_typedef(subject_type.name);
            if(def_index >= TYPEDEFS_CAPACITY){
                if(subject_type_index == u16_type && aux[field_name] == '_' && in_range_inclusive(aux[field_name + 1], '0', '1') && aux[field_name + 2] == '\0'){
                    return u8_type;
                } else if(subject_type_index == u32_type && aux[field_name] == '_' && in_range_inclusive(aux[field_name + 1], '0', '3') && aux[field_name + 2] == '\0'){
                    return u8_type;
                } else if(subject_type_index == u32_type && aux[field_name] == '_' && in_range_inclusive(aux[field_name + 1], '0', '1') && aux[field_name + 2] == 'u' && aux[field_name + 3] == '1' && aux[field_name + 4] == '6' && aux[field_name + 5] == '\0'){
                    return u16_type;
                }

                return TYPES_CAPACITY;
            }

            TypeDef def = typedefs[def_index];
            if(def.kind != TYPEDEF_STRUCT) return TYPES_CAPACITY;

            for(u32 i = 0; i < def.num_fields; i++){
                Expression field = expressions[statements[def.begin + i]];
                if(field.kind != EXPRESSION_DECLARE) continue;

                u32 other_field_name = operands[field.ops + 1];

                if(aux_cstr_equals(field_name, other_field_name)){
                    u32 field_type = operands[field.ops];
                    return field_type;
                }
            }

            return TYPES_CAPACITY;
        }
    case EXPRESSION_NEGATE:
    case EXPRESSION_NOT:
    case EXPRESSION_BIT_COMPLEMENT:
    case EXPRESSION_PRE_INCREMENT:
    case EXPRESSION_PRE_DECREMENT:
    case EXPRESSION_POST_INCREMENT:
    case EXPRESSION_POST_DECREMENT:
        return expression_get_type(expressions[expression.ops], mode);
    case EXPRESSION_TERNARY:
        return expression_get_type(expressions[operands[expression.ops + 1]], mode);
    case EXPRESSION_STRING:
        return expression_get_type_for_string(expression);
    case EXPRESSION_SIZEOF_TYPE:
        if((u1)(mode & (u8) EXPRESSION_GET_TYPE_MODE_INFER)){
            return TYPES_CAPACITY;
        } else {
            printf("\nwarning on line %d: assuming result type of sizeof_type to be u8\n", u24_unpack(expression.line));
        }
        /* fallthrough */
    case EXPRESSION_SIZEOF_TYPE_U8:
        return u8_type;
    case EXPRESSION_SIZEOF_TYPE_U16:
        return u16_type;
    case EXPRESSION_SIZEOF_TYPE_U24:
        return u24_type;
    case EXPRESSION_SIZEOF_TYPE_U32:
        return u32_type;
    case EXPRESSION_SIZEOF_VALUE:
        if((u1)(mode & (u8) EXPRESSION_GET_TYPE_MODE_INFER)){
            return TYPES_CAPACITY;
        } else {
            printf("\nwarning on line %d: assuming result type of sizeof_value to be u8\n", u24_unpack(expression.line));
        }
        /* fallthrough */
    case EXPRESSION_SIZEOF_VALUE_U8:
        return u8_type;
    case EXPRESSION_SIZEOF_VALUE_U16:
        return u16_type;
    case EXPRESSION_SIZEOF_VALUE_U24:
        return u24_type;
    case EXPRESSION_SIZEOF_VALUE_U32:
        return u32_type;
    }

    printf("\nerror on line %d: Cannot get type of this expression\n", u24_unpack(expression.line));
    return TYPES_CAPACITY;
}

u32 get_item_type(Type type, u24 line_on_error, u1 show_error_message){
    u32 dims[4];
    memcpy(dims, dimensions[type.dimensions], sizeof dims);

    if(dims[0] == 0){
        if(show_error_message){
            printf("\nerror on line %d: Cannot index into non-array type '", u24_unpack(line_on_error));
            type_print(type);
            printf("'\n");
        }
        return TYPES_CAPACITY;
    }

    // Remove dimension
    for(int i = 0; i < 3; i++){
        dims[i] = dims[i + 1];
    }
    dims[3] = 0;

    u32 type_dimensions = add_dimensions(dims);
    if(type_dimensions >= UNIQUE_DIMENSIONS_CAPACITY) return TYPES_CAPACITY;

    Type item_type = (Type){
        .name = type.name,
        .dimensions = type_dimensions,
    };

    return add_type(item_type);
}



ExpressionKind type_to_expression_kind(u32 type){
    if(type == u8_type){
        return EXPRESSION_U8;
    } else if(type == u16_type){
        return EXPRESSION_U16;
    } else if(type == u24_type){
        return EXPRESSION_U24;
    } else if(type == u32_type){
        return EXPRESSION_U32;
    }

    return EXPRESSION_NONE;
}


ExpressionKind expression_get_preferred_int_kind_or_none(u32 expression_index){
    Expression expression = expressions[expression_index];

    u32 type = expression_get_type(expression, EXPRESSION_GET_TYPE_MODE_INFER);

    if(type < TYPES_CAPACITY){
        return type_to_expression_kind(type);
    }
    
    return EXPRESSION_NONE;
}

ExpressionKind function_argument_preferred_int_kind(u32 function_begin, u32 argument_i){
    Expression declare_statement = expressions[statements[function_begin + argument_i]];
    u32 argument_type = operands[declare_statement.ops];
    return type_to_expression_kind(argument_type);
}

u0 expression_infer_call(Expression expression){
    u32 name = operands[expression.ops];
    u32 function_index = find_function(name);
    u1 has_function = function_index < FUNCTIONS_CAPACITY;

    u32 arity = operands[expression.ops + 1];

    for(u32 i = 0; i < arity; i++){
        u32 argument = operands[expression.ops + 2 + i];

        ExpressionKind preferred = has_function
            ? function_argument_preferred_int_kind(functions[function_index].begin, i)
            : EXPRESSION_NONE;

        expression_infer(argument, preferred);
    }
}

u0 expression_infer_math(Expression expression, ExpressionKind preferred_int_kind){
    u32 a = operands[expression.ops];
    u32 b = operands[expression.ops + 1];

    if(preferred_int_kind == EXPRESSION_NONE){
        preferred_int_kind = expression_get_preferred_int_kind_or_none(a);
    }

    if(preferred_int_kind == EXPRESSION_NONE){
        preferred_int_kind = expression_get_preferred_int_kind_or_none(b);
    }

    expression_infer(a, preferred_int_kind);
    expression_infer(b, preferred_int_kind);
}

u0 expression_infer(u32 expression_index, ExpressionKind preferred_int_kind){
    Expression expression = expressions[expression_index];

    switch(expression.kind){
    case EXPRESSION_NONE:
    case EXPRESSION_DECLARE:
    case EXPRESSION_PRINT_LITERAL:
    case EXPRESSION_IMPLEMENT_PUT:
    case EXPRESSION_IMPLEMENT_PRINTU1:
    case EXPRESSION_IMPLEMENT_PRINTU8:
    case EXPRESSION_IMPLEMENT_GET:
    case EXPRESSION_IMPLEMENT_READU8:
    case EXPRESSION_U1:
    case EXPRESSION_U8:
    case EXPRESSION_U16:
    case EXPRESSION_U24:
    case EXPRESSION_U32:
    case EXPRESSION_VARIABLE:
    case EXPRESSION_STRING:
    case EXPRESSION_BREAK:
    case EXPRESSION_CONTINUE:
    case EXPRESSION_SIZEOF_TYPE_U8:
    case EXPRESSION_SIZEOF_TYPE_U16:
    case EXPRESSION_SIZEOF_TYPE_U24:
    case EXPRESSION_SIZEOF_TYPE_U32:
    case EXPRESSION_ENUM_VARIANT:
    case EXPRESSION_PANICLOOP:
        break;

    case EXPRESSION_STRUCT_INITIALIZER: {
            u32 length = operands[expression.ops + 1];

            for(u32 i = 0; i < length; i++){
                expression_infer(operands[expression.ops + 2 + i], EXPRESSION_NONE);
            }
        }
        break;
    case EXPRESSION_FIELD_INITIALIZER:
        expression_infer(operands[expression.ops + 1], EXPRESSION_NONE);
        break;
    case EXPRESSION_RETURN:
        if(expression.ops != EXPRESSIONS_CAPACITY){
            expression_infer(expression.ops, type_to_expression_kind(functions[emit_context.function].return_type));
        }
        break;
    case EXPRESSION_ASSIGN:
        if(preferred_int_kind == EXPRESSION_NONE){
            preferred_int_kind = expression_get_preferred_int_kind_or_none(operands[expression.ops]);
        }
        expression_infer(operands[expression.ops], preferred_int_kind);
        expression_infer(operands[expression.ops + 1], preferred_int_kind);
        break;
    case EXPRESSION_INDEX:
        expression_infer(operands[expression.ops], EXPRESSION_NONE);
        expression_infer(operands[expression.ops + 1], EXPRESSION_NONE);
        break;
    case EXPRESSION_PRINT_ARRAY:
        expression_infer(expression.ops, EXPRESSION_NONE);
        break;
    case EXPRESSION_INT:
        if(preferred_int_kind != EXPRESSION_NONE){
            expressions[expression_index].kind = preferred_int_kind;
        }
        break;
    case EXPRESSION_CALL:
    case EXPRESSION_PRINTF:
    case EXPRESSION_MEMCMP:
    case EXPRESSION_MEMCPY:
        expression_infer_call(expression);
        break;
    case EXPRESSION_CAST: {
            u32 value = operands[expression.ops + 1];

            if(expressions[value].kind == EXPRESSION_INT){
                expression_infer(value, type_to_expression_kind(operands[expression.ops]));
            } else {
                expression_infer(value, EXPRESSION_NONE);
            }
        }
        break;
    case EXPRESSION_ADD:
    case EXPRESSION_SUBTRACT:
    case EXPRESSION_MULTIPLY:
    case EXPRESSION_DIVIDE:
    case EXPRESSION_MOD:
    case EXPRESSION_LSHIFT:
    case EXPRESSION_RSHIFT:
    case EXPRESSION_BIT_AND:
    case EXPRESSION_BIT_OR:
    case EXPRESSION_BIT_XOR:
        expression_infer_math(expression, preferred_int_kind);
        break;
    case EXPRESSION_EQUALS:
    case EXPRESSION_NOT_EQUALS:
    case EXPRESSION_LESS_THAN:
    case EXPRESSION_GREATER_THAN:
    case EXPRESSION_LESS_THAN_OR_EQUAL:
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
        expression_infer_math(expression, EXPRESSION_NONE);
        break;
    case EXPRESSION_AND:
    case EXPRESSION_OR:
        expression_infer_math(expression, EXPRESSION_U1);
        break;
    case EXPRESSION_NOT:
        expression_infer(expression.ops, EXPRESSION_U1);
        break;
    case EXPRESSION_NEGATE:
    case EXPRESSION_BIT_COMPLEMENT:
    case EXPRESSION_PRE_INCREMENT:
    case EXPRESSION_PRE_DECREMENT:
    case EXPRESSION_POST_INCREMENT:
    case EXPRESSION_POST_DECREMENT:
    case EXPRESSION_NO_RESULT_INCREMENT:
    case EXPRESSION_NO_RESULT_DECREMENT:
        expression_infer(expression.ops, preferred_int_kind);
        break;
    case EXPRESSION_TERNARY: {
            expression_infer(operands[expression.ops], EXPRESSION_U1);
            ExpressionKind result_preferred_kind = expression_get_preferred_int_kind_or_none(operands[expression.ops + 1]);
            expression_infer(operands[expression.ops + 1], result_preferred_kind);
            expression_infer(operands[expression.ops + 2], result_preferred_kind);
        }
        break;
    case EXPRESSION_IF:
    case EXPRESSION_IF_ELSE:
    case EXPRESSION_WHILE:
    case EXPRESSION_DO_WHILE:
        expression_infer(operands[expression.ops], EXPRESSION_U1);
    case EXPRESSION_CONDITIONLESS_BLOCK:
        break;
    case EXPRESSION_FOR:
        // Go to context past pre-statements
        emit_context.current_statement += operands[expression.ops];

        expression_infer(operands[expression.ops + 1], EXPRESSION_U1);

        // Return context to before pre-statements
        emit_context.current_statement -= operands[expression.ops];
    case EXPRESSION_SWITCH:
    case EXPRESSION_CASE:
    case EXPRESSION_MEMBER:
        expression_infer(operands[expression.ops], EXPRESSION_NONE);
        break;
    case EXPRESSION_SIZEOF_TYPE:
        switch(preferred_int_kind){
        case EXPRESSION_U8:
            expressions[expression_index].kind = EXPRESSION_SIZEOF_TYPE_U8;
            break;
        case EXPRESSION_U16:
            expressions[expression_index].kind = EXPRESSION_SIZEOF_TYPE_U16;
            break;
        case EXPRESSION_U24:
            expressions[expression_index].kind = EXPRESSION_SIZEOF_TYPE_U24;
            break;
        case EXPRESSION_U32:
            expressions[expression_index].kind = EXPRESSION_SIZEOF_TYPE_U32;
            break;
        default:
            break;
        }
        break;
    case EXPRESSION_SIZEOF_VALUE:
        switch(preferred_int_kind){
        case EXPRESSION_U8:
            expressions[expression_index].kind = EXPRESSION_SIZEOF_VALUE_U8;
            break;
        case EXPRESSION_U16:
            expressions[expression_index].kind = EXPRESSION_SIZEOF_VALUE_U16;
            break;
        case EXPRESSION_U24:
            expressions[expression_index].kind = EXPRESSION_SIZEOF_VALUE_U24;
            break;
        case EXPRESSION_U32:
            expressions[expression_index].kind = EXPRESSION_SIZEOF_VALUE_U32;
            break;
        default:
            break;
        }
        /* fallthrough */
    case EXPRESSION_SIZEOF_VALUE_U8:
    case EXPRESSION_SIZEOF_VALUE_U16:
    case EXPRESSION_SIZEOF_VALUE_U24:
    case EXPRESSION_SIZEOF_VALUE_U32:
        expression_infer(expression.ops, preferred_int_kind);
        break;
    case EXPRESSION_ARRAY_INITIALIZER: {
            u32 length = operands[expression.ops];
            for(u32 i = 0; i < length; i++){
                expression_infer(operands[expression.ops + 1 + i], EXPRESSION_NONE);
            }
        }
        break;
    }
}



u0 expression_print(Expression expression){
    switch(expression.kind){
    case EXPRESSION_RETURN: {
            printf("return");

            u32 return_value_index = expression.ops;

            if(return_value_index < EXPRESSIONS_CAPACITY){
                printf(" ");
                expression_print(expressions[return_value_index]);
            }
        }
        break;
    case EXPRESSION_DECLARE:
        type_print(types[operands[expression.ops]]);
        printf(" ");
        print_aux_cstr(operands[expression.ops + 1]);
        break;
    case EXPRESSION_PRINT_LITERAL:
        printf("print(\"");
        print_aux_cstr_escaped(expression.ops);
        printf("\")");
        break;
    case EXPRESSION_PRINT_ARRAY:
        printf("print(\"");
        expression_print(expressions[expression.ops]);
        printf("\")");
        break;
    case EXPRESSION_CALL:
    case EXPRESSION_PRINTF:
    case EXPRESSION_MEMCMP:
    case EXPRESSION_MEMCPY: {
            u32 name = operands[expression.ops];
            u32 arity = operands[expression.ops + 1];
            print_aux_cstr(name);
            printf("(");
            for(u32 i = 0; i < arity; i++){
                expression_print(expressions[operands[expression.ops + 2 + i]]);
                if(i + 1 != arity){
                    printf(", ");
                }
            }
            printf(")");
        }
        break;
    case EXPRESSION_IMPLEMENT_PUT:
        printf("<implementation of put>");
        break;
    case EXPRESSION_IMPLEMENT_PRINTU1:
        printf("<implementation of printu1>");
        break;
    case EXPRESSION_IMPLEMENT_PRINTU8:
        printf("<implementation of printu8>");
        break;
    case EXPRESSION_IMPLEMENT_GET:
        printf("<implementation of get>");
        break;
    case EXPRESSION_INT:
        printf("%d", expression.ops);
        break;
    case EXPRESSION_U1:
        if(expression.ops != 0){
            printf("true");
        } else {
            printf("false");
        }
        break;
    case EXPRESSION_U8:
        printf("%du8", expression.ops);
        break;
    case EXPRESSION_U16:
        printf("%du16", expression.ops);
        break;
    case EXPRESSION_U24:
        printf("%du24", expression.ops);
        break;
    case EXPRESSION_U32:
        printf("%du32", expression.ops);
        break;
    case EXPRESSION_VARIABLE:
        print_aux_cstr(expression.ops);
        break;
    case EXPRESSION_CAST:
        printf("(");
        type_print(types[operands[expression.ops]]);
        printf(") ");
        expression_print(expressions[operands[expression.ops + 1]]);
        break;
    case EXPRESSION_ASSIGN:
    case EXPRESSION_ADD:
    case EXPRESSION_SUBTRACT:
    case EXPRESSION_MULTIPLY:
    case EXPRESSION_DIVIDE:
    case EXPRESSION_MOD:
    case EXPRESSION_EQUALS:
    case EXPRESSION_NOT_EQUALS:
    case EXPRESSION_LESS_THAN:
    case EXPRESSION_GREATER_THAN:
    case EXPRESSION_LESS_THAN_OR_EQUAL:
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
    case EXPRESSION_AND:
    case EXPRESSION_OR:
    case EXPRESSION_BIT_AND:
    case EXPRESSION_BIT_OR:
    case EXPRESSION_BIT_XOR:
    case EXPRESSION_LSHIFT:
    case EXPRESSION_RSHIFT: {
            u32 a = operands[expression.ops];
            u32 b = operands[expression.ops + 1];

            printf("(");
            expression_print(expressions[a]);
            printf(" ");
            expression_print_operator(expression.kind);
            printf(" ");
            expression_print(expressions[b]);
            printf(")");
        }
        break;
    case EXPRESSION_INDEX: {
            u32 a = operands[expression.ops];
            u32 b = operands[expression.ops + 1];

            expression_print(expressions[a]);
            printf("[");
            expression_print(expressions[b]);
            printf("]");
        }
        break;
    case EXPRESSION_NEGATE:
    case EXPRESSION_NOT:
    case EXPRESSION_BIT_COMPLEMENT:
        expression_print_operator(expression.kind);
        printf("(");
        expression_print(expressions[expression.ops]);
        printf(")");
        break;
    case EXPRESSION_PRE_INCREMENT:
        printf("++");
        expression_print(expressions[expression.ops]);
        break;
    case EXPRESSION_PRE_DECREMENT:
        printf("--");
        expression_print(expressions[expression.ops]);
        break;
    case EXPRESSION_POST_INCREMENT:
    case EXPRESSION_NO_RESULT_INCREMENT:
        expression_print(expressions[expression.ops]);
        printf("++");
        break;
    case EXPRESSION_POST_DECREMENT:
    case EXPRESSION_NO_RESULT_DECREMENT:
        expression_print(expressions[expression.ops]);
        printf("--");
        break;
    case EXPRESSION_TERNARY:
        printf("(");
        expression_print(expressions[operands[expression.ops]]);
        printf(" ? ");
        expression_print(expressions[operands[expression.ops + 1]]);
        printf(" : ");
        expression_print(expressions[operands[expression.ops + 2]]);
        printf(")");
        break;
    case EXPRESSION_MEMBER:
        expression_print(expressions[operands[expression.ops]]);
        printf(".");
        print_aux_cstr(operands[expression.ops + 1]);
        break;
    case EXPRESSION_STRING:
        printf("\"");
        print_aux_cstr_escaped(expression.ops);
        printf("\"");
        break;
    case EXPRESSION_BREAK:
        printf("break");
        break;
    case EXPRESSION_CONTINUE:
        printf("continue");
        break;
    case EXPRESSION_SIZEOF_TYPE:
    case EXPRESSION_SIZEOF_TYPE_U8:
    case EXPRESSION_SIZEOF_TYPE_U16:
    case EXPRESSION_SIZEOF_TYPE_U24:
    case EXPRESSION_SIZEOF_TYPE_U32:
        printf("sizeof");
        if(expression.kind == EXPRESSION_SIZEOF_TYPE_U8){
            printf("<u8>");
        } else if(expression.kind == EXPRESSION_SIZEOF_TYPE_U16){
            printf("<u16>");
        } else if(expression.kind == EXPRESSION_SIZEOF_TYPE_U24){
            printf("<u24>");
        } else if(expression.kind == EXPRESSION_SIZEOF_TYPE_U32){
            printf("<u32>");
        }
        printf("(");
        type_print(types[expression.ops]);
        printf(")");
        break;
    case EXPRESSION_SIZEOF_VALUE:
    case EXPRESSION_SIZEOF_VALUE_U8:
    case EXPRESSION_SIZEOF_VALUE_U16:
    case EXPRESSION_SIZEOF_VALUE_U24:
    case EXPRESSION_SIZEOF_VALUE_U32:
        printf("sizeof");
        if(expression.kind == EXPRESSION_SIZEOF_VALUE_U8){
            printf("<u8>");
        } else if(expression.kind == EXPRESSION_SIZEOF_VALUE_U16){
            printf("<u16>");
        } else if(expression.kind == EXPRESSION_SIZEOF_VALUE_U24){
            printf("<u24>");
        } else if(expression.kind == EXPRESSION_SIZEOF_VALUE_U32){
            printf("<u32>");
        }
        printf(" ");
        expression_print(expressions[expression.ops]);
        break;
    case EXPRESSION_CASE:
        if(operands[expression.ops] < EXPRESSIONS_CAPACITY){
            printf("case ");
            expression_print(expressions[operands[expression.ops]]);
        } else {
            printf("default");
        }
        break;
    case EXPRESSION_ARRAY_INITIALIZER: {
            u32 length = operands[expression.ops];
            printf("{");

            for(u32 i = 0; i < length; i++){
                if(i != 0){
                    printf(", ");
                }

                expression_print(expressions[operands[expression.ops + 1 + i]]);
            }

            printf("}");
        }
        break;
    case EXPRESSION_STRUCT_INITIALIZER: {
            u32 type = operands[expression.ops];
            u32 length = operands[expression.ops + 1];
            printf("(");
            type_print(types[type]);
            printf("){ ");

            for(u32 i = 0; i < length; i++){
                if(i != 0){
                    printf(", ");
                }

                expression_print(expressions[operands[expression.ops + 2 + i]]);
            }

            printf(" }");
        }
        break;
    case EXPRESSION_FIELD_INITIALIZER: {
            printf(".");
            print_aux_cstr(operands[expression.ops]);
            printf(" = ");
            expression_print(expressions[operands[expression.ops + 1]]);
        }
        break;
    case EXPRESSION_ENUM_VARIANT: {
            print_aux_cstr(expression.ops);
            printf(",");
        }
        break;
    case EXPRESSION_PANICLOOP: {
            printf("panicloop()");
       }
       break;
    default:
        printf("<unknown expression>");
    }
}



u32 function_args_size(Function function){
    u32 total_size = 0;

    for(u8 i = 0; i < function.arity; i++){
        Expression arg = expressions[statements[function.begin + (u32) i]];

        if(arg.kind != EXPRESSION_DECLARE){
            printf("\ninternal error on line %d: Failed to compute arguments size\n", u24_unpack(function.line));
            return -1;
        }

        u32 arg_size = type_sizeof_or_max(operands[arg.ops], arg.line);
        if(arg_size == -1) return -1;

        total_size += arg_size;
    }

    return total_size;
}



// ============= Inlined function calls =============
// Have layout like: `global1 global2 unknown1 unknown2 return_value1 return_value2 return_value3 param1 param2 param3 param4 local1 local2`
//                                                                                                                            ^
// on the tape.
// They are told their current position on the tape.
//
// Calling: ----------------------------
// Return value space and parameters are pushed on to the tape.
// The cell pointer is then left pointing at the next available cell.
// Returning: --------------------------
// Parameters and local variables will be popped from the tape.
// The return value will remain intact as a value on the tape.
// The cell pointer is decremented to be the next available cell.
//
// For example, the `put` function is implemented as:
// <.
// To call the put function, we push the return value (no cells) and paremeters (single cell) on to the tape,
// with the cell pointer pointing to the next available cell.
// 65+>
// The function contents are inlined (this may require knowning the cell pointer at compile time in some cases),
// <.
// The function returns, by getting rid of the parameters (1 cell in this case) and pointing to the next available cell, while retaining the
// return value (0 cells in this case)
// No additional code is necessary for this example

// 10 ? ? ?
//    ^
// 10 ? ? ?
//  ^ -------------- and outputs 10
// ? ? ? ?
// ^ -------------- after return

// The function is responsible for returning, the caller is responsible for calling.

// ============= Recursive functions calls =============
// Have stack layout like: `unknown1 unknown2 return_value1 return_value2 return_value3 param1 param2 param3 param4 local1 local2`
// Have tape layout like: `global1 global2`
// Caller pushes uninitialized space for return values (on to the stack)
// Caller pushes return block address (on to the stack)
// Caller pushes parameters with initialized values (on to the stack)
// Caller pushes target block address (on to the stack)
// Control flow is given to function dispatcher
// Tape pointer should be pointing to the beginning of the stack pointer

// The callee then returns by popping it's local variables and parameters,
// Leaving the return block address at the stop of the stack
// Tape pointer should be pointing to the beginning of the stack pointer
// The caller can now use the return value by copying it to the tape

// Whether a function is recursive or not will be determined by the following:
// Create an array with the amount of recursive calls for each function (all calls are assumed to be recursive to start)
// Create array of arrows, each arrow is from_function_index->to_function_index
/*
u16 num_outgoing[MAX_FUNCTIONS];
typedef struct { u16 source; u16 destination; } Arrow;
Arrow arrows[MAX_ARROWS];
u1 changed = 1;
while(changed){
    changed = 0;

    for(int i = 0; i < arrows.length; i++){
        u16 destination = arrows[i].destination;

        if(num_outgoing[destination] == 0){
            for(int j = 0; j < arrows.length; j++){
                if(arrows[j].destination == destination){
                    num_outgoing[arrow.source]--;
                    memove(arrows[j], &arrows[j + 1], sizeof arrows - j);
                    j--;
                }
            }
            changed = 1;
        }
    }
}
for(int i = 0; i < functions.length; i++){
    functions[i].is_recursive = (num_outgoing[i] == 0);
}
*/

/*
GLOBAL_VARIABLES globals;
u32 stack_pointer;
u8[MAX_U32] stack;

// Memory never used (stack_pointer of zero means exit)
stack[0] = 0;
stack[1] = 0;

// Entry point block
stack[2] = 0;
stack[3] = 1;

// Size of starting block address
stack_pointer = 2;

while(stack_pointer != 0){
    const u16 block_address = u16(stack[stack_pointer], stack[stack_pointer + 1]);

    switch(block_address){
    case 1: // Main Function Block 1
        // Write return address
        stack[stack_pointer] = 0;
        stack[stack_pointer + 1] = 3;
        // Write parameters (none)
        // Write callee block address
        stack[stack_pointer] = 0;
        stack[stack_pointer + 1] = 2;
        // Increase stack pointer by the size of what we appended
        stack_pointer += 4; // Call Function 2 Block 1
        break;
    case 2: // Function 2 Block 1
        printf("Hello World\n");
        // Do nothing, return
        break;
    case 3: // Main Function Block 2
        printf("Bye world!\n");
        // Do nothing, return
        break;
    }

    stack_pointer -= 2;
}
*/

ErrorCode emit_if_like(Expression expression);
ErrorCode emit_while(Expression expression);
ErrorCode emit_do_while(Expression expression);
ErrorCode emit_for(Expression expression);
ErrorCode emit_switch(Expression expression);
ErrorCode emit_case(Expression expression);

ErrorCode emit_if_like_stack(Expression expression);
ErrorCode emit_if_like_tape(Expression expression);
ErrorCode emit_while_stack(Expression expression);
ErrorCode emit_while_tape(Expression expression);
ErrorCode emit_do_while_stack(Expression expression);
ErrorCode emit_do_while_tape(Expression expression);
ErrorCode emit_for_stack(Expression expression);
ErrorCode emit_for_tape(Expression expression);
ErrorCode emit_conditionless_block(Expression expression);
ErrorCode emit_switch_stack(Expression expression);
ErrorCode emit_switch_tape(Expression expression);
ErrorCode emit_case_stack(Expression expression);
ErrorCode emit_case_tape(Expression expression);

u1 can_statement_break_current_level(u32 statement_index);
u1 can_statements_break_current_level(u32 start_statement_i, u32 stop_statement_i);
u1 can_loop_break(u32 statement_index);
u1 can_statement_continue_current_level(u32 statement_index);
u1 can_statements_continue_current_level(u32 start_statement_i, u32 stop_statement_i);
u1 can_loop_continue(u32 statement_index);

ErrorCode add_close_needed(CloseNeeded close_needed){
    if(num_closes_needed >= CLOSES_NEEDED_CAPCAITY){
        printf("\nout of memory: Exceeded maximum number of pending check closes\n");
        return 1;
    }

    closes_needed[num_closes_needed++] = close_needed;
    return 0;
}

ErrorCode emit_early_return_check(){
    if(emit_context.can_function_early_return){
        u32 offset = emit_context.current_cell_index - emit_context.incomplete_cell;

        // Allocate temporary cell, and ensure 'incomplete' cell is still true
        printf("[-]%d<[%d>", offset, offset);

        return add_close_needed(CLOSE_NEEDED_FOR_EARLY_RETURN_CHECK);
    } else {
        return 0;
    }
}

ErrorCode emit_break_check(){
    if(emit_settings.can_break){
        u32 offset = emit_context.current_cell_index - emit_context.didnt_break_cell;

        // Allocate temporary cell, and ensure 'didnt_break_cell' cell is still true
        printf("[-]%d<[%d>", offset, offset);

        return add_close_needed(CLOSE_NEEDED_FOR_BREAK_CHECK);
    } else {
        return 0;
    }
}

ErrorCode emit_continue_check(){
    if(emit_settings.can_continue){
        u32 offset = emit_context.current_cell_index - emit_context.didnt_continue_cell;

        // Allocate temporary cell, and ensure 'didnt_continue_cell' cell is still true
        printf("[-]%d<[%d>", offset, offset);

        return add_close_needed(CLOSE_NEEDED_FOR_CONTINUE_CHECK);
    } else {
        return 0;
    }
}

u0 emit_pre_loop_condition_early_return_check(){
    if(emit_context.can_function_early_return){
        // Allocate 1 cell for default condition value of false or eventual evaluated condition
        printf("[-]>");
        emit_context.current_cell_index++;

        // Copy 'incomplete' cell
        copy_cell_static(emit_context.incomplete_cell);

        // Go to copied cell
        printf("<");
        emit_context.current_cell_index--;

        // If function is still incomplete
        printf("[<");
        emit_context.current_cell_index--;
    }
}

u0 emit_post_loop_condition_early_return_check(){
    if(emit_context.can_function_early_return){
        // Remain pointing at next available cell

        // Close if
        printf("[-]]");
    }
}

u0 emit_pre_loop_condition_break_check(){
    if(emit_settings.can_break){
        // Allocate 1 cell for default condition value of false or eventual evaluated condition
        printf("[-]>");
        emit_context.current_cell_index++;

        // Copy 'didnt_break_cell' cell
        copy_cell_static(emit_context.didnt_break_cell);

        // Go to copied cell
        printf("<");
        emit_context.current_cell_index--;

        // If loop hasn't been broken yet
        printf("[<");
        emit_context.current_cell_index--;
    }
}

u0 emit_post_loop_condition_break_check(){
    if(emit_settings.can_break){
        // Remain pointing at next available cell

        // Close if
        printf("[-]]");
    }
}

u0 emit_pre_case_fallthrough_check(){
    // Allocate default result (true)
    printf("[-]+>");
    emit_context.current_cell_index++;

    // Copy 'fell_through_cell'
    copy_cell_static(emit_context.fell_through_cell);

    // Negate 'fell_through_cell'
    emit_not_u1();

    // Go to '!fell_through_cell'
    printf("<");
    emit_context.current_cell_index--;

    // If hasn't fallen through, evalute case value instead of
    // default value
    printf("[<");
    emit_context.current_cell_index--;
}

u0 emit_post_case_fallthrough_check(){
    // Remain pointing at next available cell
    // End if
    printf("[-]]");
}

ErrorCode emit_close_checks_until(u32 waterline){
    while(num_closes_needed > waterline){
        CloseNeeded close_needed = closes_needed[--num_closes_needed];

        u32 offset;

        switch(close_needed){
        case CLOSE_NEEDED_FOR_EARLY_RETURN_CHECK:
            offset = emit_context.current_cell_index - emit_context.incomplete_cell;
            break;
        case CLOSE_NEEDED_FOR_BREAK_CHECK:
            offset = emit_context.current_cell_index - emit_context.didnt_break_cell;
            break;
        case CLOSE_NEEDED_FOR_CONTINUE_CHECK:
            offset = emit_context.current_cell_index - emit_context.didnt_continue_cell;
            break;
        default:
            printf("\nerror: emit_close_checks_until() got unknown close kind\n");
            return 1;
        }

        u32 amount = 1;

        while(num_closes_needed > waterline && closes_needed[num_closes_needed - 1] == close_needed){
            num_closes_needed--;
            amount++;
        }

        // Zero temporary 'restoration_copy' cell
        printf("[-]");

        // Go to target cell
        printf("%d<", offset);

        // Move target cell to 'restoration_copy' cell
        printf("[%d>+%d<-]", offset, offset);

        // Close checks of same kind
        printf("%d]", amount);

        // Restore target cell from copy and go back to cell where came from
        printf("%d>[%d<+%d>-]", offset, offset, offset);

        // (emit_context.current_cell_index remains unchanged)
    }

    return 0;
}

ErrorCode emit_body(u32 start_statement_i, u32 stop_statement_i, u1 allow_cases){
    u32 closes_needed_waterline = num_closes_needed;

    for(u32 i = start_statement_i; i < stop_statement_i; i++){
        Expression expression = expressions[statements[i]];
        emit_context.current_statement = i;

        // Skip over contained statements
        switch(expression.kind){
        case EXPRESSION_IF:
            if(emit_if_like(expression) != 0) return 1;
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_IF_ELSE:
            if(emit_if_like(expression) != 0) return 1;
            i += operands[expression.ops + 1] + operands[expression.ops + 2];
            break;
        case EXPRESSION_WHILE:
            if(emit_while(expression) != 0) return 1;
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_FOR:
            if(emit_for(expression) != 0) return 1;
            i += operands[expression.ops] + operands[expression.ops + 2] + operands[expression.ops + 3];
            break;
        case EXPRESSION_DO_WHILE:
            if(emit_do_while(expression) != 0) return 1;
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_CONDITIONLESS_BLOCK:
            if(emit_conditionless_block(expression) != 0) return 1;
            i += expression.ops;
            break;
        case EXPRESSION_SWITCH:
            if(emit_switch(expression) != 0) return 1;
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_CASE:
            if(!allow_cases){
                expression_print_cannot_use_case_here_error(expression);
                return 1;
            }
            if(emit_case(expression) != 0) return 1;
            i += operands[expression.ops + 1];
            break;
        default: {
                u32 result_type = expression_emit(expression);
                if(result_type == TYPES_CAPACITY) return 1;

                if(result_type != u0_type){
                    printf("\nerror on line %d: Statement result ignored\n", u24_unpack(expression.line));
                    return 1;
                }
                
                if(expression.kind == EXPRESSION_RETURN || expression.kind == EXPRESSION_BREAK || expression.kind == EXPRESSION_CONTINUE){
                    i = stop_statement_i;
                }
            }
        }
    }

    return emit_close_checks_until(closes_needed_waterline);
}

ErrorCode emit_body_scoped(u32 start_statement_i, u32 stop_statement_i, u1 allow_cases){
    u32 starting_cell_index = emit_context.current_cell_index;

    // Emit body
    if(emit_body(start_statement_i, stop_statement_i, allow_cases) != 0){
        return 1;
    }

    // Deallocate locally scoped variables
    if(emit_context.current_cell_index > starting_cell_index){
        printf("%d<", emit_context.current_cell_index - starting_cell_index);
        emit_context.current_cell_index = starting_cell_index;
    }

    return 0;
}


ErrorCode emit_if_like(Expression expression){
    if(emit_context.in_recursive_function){
        return emit_if_like_stack(expression);
    } else {
        return emit_if_like_tape(expression);
    }
}

ErrorCode emit_if_like_stack(Expression expression){
    // Evaluate condition
    u32 condition_type = expression_emit(expressions[operands[expression.ops]]);
    if(condition_type == TYPES_CAPACITY) return 1;

    if(condition_type != u1_type){
        printf("\nerror on line %d: Expected 'if' condition to be 'u1', got '", u24_unpack(expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return 1;
    }

    u1 has_else = expression.kind == EXPRESSION_IF_ELSE;

    u32 then_block = emit_settings.next_basicblock_id++;
    u32 else_block = emit_settings.next_basicblock_id++;
    u32 continuation_block = has_else ? emit_settings.next_basicblock_id++ : else_block;

    u32 pushed = emit_end_basicblock_jump_conditional(then_block, else_block);

    // Then block
    emit_start_basicblock_landing(then_block, pushed);

    // Emit 'if' body
    if(emit_body_scoped(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 1] + 1, false) != 0){
        return 1;
    }

    if(emit_settings.in_basicblock){
        emit_end_basicblock_jump_compatible(continuation_block, pushed);
    }

    if(has_else){
        // Else block
        emit_start_basicblock_landing(else_block, pushed);

        // Emit 'else' body
        if(emit_body_scoped(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 2] + 1, false) != 0){
            return 1;
        }

        if(emit_settings.in_basicblock){
            emit_end_basicblock_jump_compatible(continuation_block, pushed);
        }
    }

    // Continuation block
    emit_start_basicblock_landing(continuation_block, pushed);
    return 0;
}

ErrorCode emit_if_like_tape(Expression expression){
    // Emits code for if/if-else statements
    
    // Evaluate condition
    u32 condition_type = expression_emit(expressions[operands[expression.ops]]);
    if(condition_type == TYPES_CAPACITY) return 1;

    if(condition_type != u1_type){
        printf("\nerror on line %d: Expected 'if' condition to be 'u1', got '", u24_unpack(expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return 1;
    }

    u1 has_else = expression.kind == EXPRESSION_IF_ELSE;

    if(has_else){
        // Allocate 'should_run_else' cell
        printf("[-]+");
    }

    // Go to condition cell
    printf("<");
    emit_context.current_cell_index--;

    // If condition
    printf("[");

    // Emit 'if' body
    if(emit_body_scoped(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 1] + 1, false) != 0){
        return 1;
    }

    // Go to 'condition' cell
    if(has_else){
        // Zero 'should_run_else' cell on the way
        printf(">[-]<");
    }

    // End if
    printf("[-]]");

    // Handle else
    if(has_else){
        // Go to 'should_run_else' cell
        printf(">");
        emit_context.current_cell_index++;

        // If 'should_run_else' cell
        printf("[");

        // Emit 'else' body
        if(emit_body_scoped(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 2] + 1, false) != 0){
            return 1;
        }

        // End if
        printf("[-]]");

        // Go to next available cell
        printf("<");
        emit_context.current_cell_index--;
    }

    return (ErrorCode) (emit_break_check() != 0 || emit_continue_check() != 0 || emit_early_return_check() != 0);
}

u0 emit_reset_didnt_continue(){
    if(emit_settings.can_continue){
        u32 offset = emit_context.current_cell_index - emit_context.didnt_continue_cell;

        // Set 'didnt_continue_cell' to true
        printf("%d<[-]+%d>", offset, offset);
    }
}

u0 enter_maybe_breakable_continuable_loop_tape(Expression expression, u32 inner_variable_offset_ops_offset){
    emit_settings.can_break = can_loop_break(emit_context.current_statement);
    emit_settings.can_continue = can_loop_continue(emit_context.current_statement);

    operands[expression.ops + inner_variable_offset_ops_offset] = 0;

    if(emit_settings.can_break){
        // Allocate 'didnt_break_cell'
        printf("[-]+>");
        emit_context.didnt_break_cell = emit_context.current_cell_index++;

        // Increase inner variable offset
        operands[expression.ops + inner_variable_offset_ops_offset]++;
    }

    if(emit_settings.can_continue){
        // Allocate 'didnt_continue_cell'
        printf("[-]+>");
        emit_context.didnt_continue_cell = emit_context.current_cell_index++;

        // Increase inner variable offset
        operands[expression.ops + inner_variable_offset_ops_offset]++;
    }
}

u0 exit_maybe_breakable_continuable_loop(){
    // Deallocate 'didnt_continue_cell' if used
    if(emit_settings.can_continue){
        printf("<");
        emit_context.current_cell_index--;
    }

    // Deallocate 'didnt_break_cell' if used
    if(emit_settings.can_break){
        printf("<");
        emit_context.current_cell_index--;
    }
}

u0 enter_switch(){
    emit_settings.can_break = true;

    // Allocate 'didnt_break_cell'
    printf("[-]+>");
    emit_context.didnt_break_cell = emit_context.current_cell_index++;

    // Allocate 'fell_through_cell'
    printf("[-]>");
    emit_context.fell_through_cell = emit_context.current_cell_index++;
}

u0 exit_switch(){
    // Deallocate 'didnt_break_cell'
    printf("<");
    emit_context.current_cell_index--;
}

ErrorCode emit_while(Expression expression){
    if(emit_context.in_recursive_function){
        return emit_while_stack(expression);
    } else {
        return emit_while_tape(expression);
    }
}

ErrorCode emit_while_stack(Expression expression){
    u1 was_breakable = emit_settings.can_break;
    u1 was_continuable = emit_settings.can_continue;
    JumpContext old_break_context = emit_settings.break_basicblock_context;
    JumpContext old_continue_context = emit_settings.continue_basicblock_context;

    // Evaluate condition
    u32 condition_type = expression_emit(expressions[operands[expression.ops]]);
    if(condition_type == TYPES_CAPACITY) return 1;

    if(condition_type != u1_type){
        printf("\nerror on line %d: Expected 'while' condition to be 'u1', got '", u24_unpack(expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return 1;
    }

    u32 then_block = emit_settings.next_basicblock_id++;
    u32 continuation_block = emit_settings.next_basicblock_id++;
    u32 pushed = emit_end_basicblock_jump_conditional(then_block, continuation_block);

    emit_settings.can_break = can_loop_break(emit_context.current_statement);
    emit_settings.can_continue = can_loop_continue(emit_context.current_statement);

    if(emit_settings.can_break){
        emit_settings.break_basicblock_context = (JumpContext){
            .basicblock_id = continuation_block,
            .num_cells_input = pushed,
        };
    }

    if(emit_settings.can_continue){
        // Create special separate block if using `continue`
        u32 condition_block = emit_settings.next_basicblock_id++;

        // Condition block
        emit_start_basicblock_landing(condition_block, pushed);

        // Re-evaluate condition (this should never fail)
        (u0) expression_emit(expressions[operands[expression.ops]]);

        // Either redo or continue onwards
        if(emit_settings.in_basicblock){
            (u0) emit_end_basicblock_jump_conditional(then_block, continuation_block);
        }

        emit_settings.continue_basicblock_context = (JumpContext){
            .basicblock_id = condition_block,
            .num_cells_input = pushed,
        };
    }

    // Then block
    emit_start_basicblock_landing(then_block, pushed);

    // Emit 'while' body
    if(emit_body_scoped(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 1] + 1, false) != 0){
        return 1;
    }

    // Either redo or continue onwards
    if(emit_settings.in_basicblock){
        // Re-evaluate condition (this should never fail)
        (u0) expression_emit(expressions[operands[expression.ops]]);

        (u0) emit_end_basicblock_jump_conditional(then_block, continuation_block);
    }

    // Continuation block
    emit_start_basicblock_landing(continuation_block, pushed);
    emit_settings.break_basicblock_context = old_break_context;
    emit_settings.continue_basicblock_context = old_continue_context;
    emit_settings.can_break = was_breakable;
    emit_settings.can_continue = was_continuable;
    return 0;
}

ErrorCode emit_while_tape(Expression expression){
    u1 was_breakable = emit_settings.can_break;
    u1 was_continuable = emit_settings.can_continue;
    u32 old_didnt_break_cell = emit_context.didnt_break_cell;
    u32 old_didnt_continue_cell = emit_context.didnt_continue_cell;

    enter_maybe_breakable_continuable_loop_tape(expression, 2);

    // Evaluate condition
    emit_pre_loop_condition_early_return_check();
    u32 condition_type = expression_emit(expressions[operands[expression.ops]]);
    if(condition_type == TYPES_CAPACITY) return 1;
    emit_post_loop_condition_early_return_check();

    if(condition_type != u1_type){
        printf("\nerror on line %d: Expected 'while' condition to be 'u1', got '", u24_unpack(expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return 1;
    }

    // Go to 'condition' cell
    printf("<");
    emit_context.current_cell_index--;

    // While 'condition' cell
    printf("[");
    emit_reset_didnt_continue();

    // Emit 'while' body
    if(emit_body_scoped(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 1] + 1, false) != 0){
        return 1;
    }

    // Re-evaluate condition (should never fail)
    emit_pre_loop_condition_early_return_check();
    emit_pre_loop_condition_break_check();
    (u0) expression_emit(expressions[operands[expression.ops]]);
    emit_post_loop_condition_break_check();
    emit_post_loop_condition_early_return_check();

    // Go to 'condition' cell
    printf("<");
    emit_context.current_cell_index--;

    // End while
    printf("]");

    exit_maybe_breakable_continuable_loop();

    emit_settings.can_break = was_breakable;
    emit_settings.can_continue = was_continuable;
    emit_context.didnt_break_cell = old_didnt_break_cell;
    emit_context.didnt_continue_cell = old_didnt_continue_cell;

    return (ErrorCode) (emit_break_check() != 0 || emit_continue_check() != 0 || emit_early_return_check() != 0);
}

ErrorCode emit_do_while(Expression expression){
    if(emit_context.in_recursive_function){
        return emit_do_while_stack(expression);
    } else {
        return emit_do_while_tape(expression);
    }
}

ErrorCode emit_do_while_stack(Expression expression){
    u1 was_breakable = emit_settings.can_break;
    u1 was_continuable = emit_settings.can_continue;
    JumpContext old_break_context = emit_settings.break_basicblock_context;
    JumpContext old_continue_context = emit_settings.continue_basicblock_context;

    u32 then_block = emit_settings.next_basicblock_id++;
    u32 continuation_block = emit_settings.next_basicblock_id++;
    u32 pushed = emit_end_basicblock_jump(then_block);

    emit_settings.can_break = can_loop_break(emit_context.current_statement);
    emit_settings.can_continue = can_loop_continue(emit_context.current_statement);

    if(emit_settings.can_break){
        emit_settings.break_basicblock_context = (JumpContext){
            .basicblock_id = continuation_block,
            .num_cells_input = pushed,
        };
    }

    if(emit_settings.can_continue){
        // Create special separate block if using `continue`
        u32 condition_block = emit_settings.next_basicblock_id++;

        // Condition block
        emit_start_basicblock_landing(condition_block, pushed);

        // Evaluate condition
        u32 condition_type = expression_emit(expressions[operands[expression.ops]]);
        if(condition_type == TYPES_CAPACITY) return 1;

        if(condition_type != u1_type){
            printf("\nerror on line %d: Expected 'do-while' condition to be 'u1', got '", u24_unpack(expression.line));
            type_print(types[condition_type]);
            printf("'\n");
            return 1;
        }

        // Either redo or continue onwards
        if(emit_settings.in_basicblock){
            (u0) emit_end_basicblock_jump_conditional(then_block, continuation_block);
        }

        emit_settings.continue_basicblock_context = (JumpContext){
            .basicblock_id = condition_block,
            .num_cells_input = pushed,
        };
    }

    // Then block
    emit_start_basicblock_landing(then_block, pushed);

    // Emit 'do-while' body
    if(emit_body_scoped(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 1] + 1, false) != 0){
        return 1;
    }

    // Either redo or continue onwards
    if(emit_settings.in_basicblock){
        // Evaluate condition
        u32 condition_type = expression_emit(expressions[operands[expression.ops]]);
        if(condition_type == TYPES_CAPACITY) return 1;

        if(condition_type != u1_type){
            printf("\nerror on line %d: Expected 'do-while' condition to be 'u1', got '", u24_unpack(expression.line));
            type_print(types[condition_type]);
            printf("'\n");
            return 1;
        }

        (u0) emit_end_basicblock_jump_conditional(then_block, continuation_block);
    }

    // Continuation block
    emit_start_basicblock_landing(continuation_block, pushed);
    emit_settings.break_basicblock_context = old_break_context;
    emit_settings.continue_basicblock_context = old_continue_context;
    emit_settings.can_break = was_breakable;
    emit_settings.can_continue = was_continuable;
    return 0;
}

ErrorCode emit_do_while_tape(Expression expression){
    u1 was_breakable = emit_settings.can_break;
    u1 was_continuable = emit_settings.can_continue;
    u32 old_didnt_break_cell = emit_context.didnt_break_cell;
    u32 old_didnt_continue_cell = emit_context.didnt_continue_cell;

    enter_maybe_breakable_continuable_loop_tape(expression, 2);

    u32 starting_cell_index = emit_context.current_cell_index;

    // Set 'condition' cell to true
    printf("[-]+");

    // While 'condition' cell
    printf("[");
    emit_reset_didnt_continue();
    
    // Emit 'do-while' body
    if(emit_body(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 1] + 1, false) != 0){
        return 1;
    }

    // Deallocate variables
    if(emit_context.current_cell_index > starting_cell_index){
        printf("%d<", emit_context.current_cell_index - starting_cell_index);
        emit_context.current_cell_index = starting_cell_index;
    }

    // Evaluate condition
    emit_pre_loop_condition_early_return_check();
    emit_pre_loop_condition_break_check();
    u32 condition_type = expression_emit(expressions[operands[expression.ops]]);
    if(condition_type == TYPES_CAPACITY) return 1;
    emit_post_loop_condition_break_check();
    emit_post_loop_condition_early_return_check();

    if(condition_type != u1_type){
        printf("\nerror on line %d: Expected 'do-while' condition to be 'u1', got '", u24_unpack(expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return 1;
    }

    // Go to 'condition' cell
    printf("<");
    emit_context.current_cell_index--;

    // End while
    printf("]");
    
    exit_maybe_breakable_continuable_loop();

    emit_settings.can_break = was_breakable;
    emit_settings.can_continue = was_continuable;
    emit_context.didnt_break_cell = old_didnt_break_cell;
    emit_context.didnt_continue_cell = old_didnt_continue_cell;

    return (ErrorCode) (emit_break_check() != 0 || emit_continue_check() != 0 || emit_early_return_check() != 0);
}

ErrorCode emit_for(Expression expression){
    if(emit_context.in_recursive_function){
        return emit_for_stack(expression);
    } else {
        return emit_for_tape(expression);
    }
}

ErrorCode emit_for_stack(Expression expression){
    u1 was_breakable = emit_settings.can_break;
    u1 was_continuable = emit_settings.can_continue;
    JumpContext old_break_context = emit_settings.break_basicblock_context;
    JumpContext old_continue_context = emit_settings.continue_basicblock_context;

    u32 num_pre = operands[expression.ops];
    u32 num_post = operands[expression.ops + 2];
    u32 num_inside = operands[expression.ops + 3];

    u32 pre_start_statement = emit_context.current_statement + 1;
    u32 post_start_statement = pre_start_statement + num_pre;
    u32 inside_start_statement = post_start_statement + num_post;

    u32 pre_starting_cell_index = emit_context.current_cell_index;

    u32 condition_block = emit_settings.next_basicblock_id++;
    u32 body_block = emit_settings.next_basicblock_id++;
    u32 increment_block = emit_settings.next_basicblock_id++;
    u32 continuation_block = emit_settings.next_basicblock_id++;

    emit_settings.can_break = can_loop_break(emit_context.current_statement);
    emit_settings.can_continue = can_loop_continue(emit_context.current_statement);

    // Emit pre-statements
    if(emit_body(pre_start_statement, pre_start_statement + num_pre, false) != 0){
        return 1;
    }
    if(!emit_settings.in_basicblock){
        emit_settings.break_basicblock_context = old_break_context;
        emit_settings.continue_basicblock_context = old_continue_context;
        emit_settings.can_break = was_breakable;
        emit_settings.can_continue = was_continuable;
        return 0;
    }

    u32 pre_num_cells = emit_context.current_cell_index - pre_starting_cell_index;
    u32 pushed = emit_end_basicblock_jump(condition_block);

    if(emit_settings.can_break){
        emit_settings.break_basicblock_context = (JumpContext){
            .basicblock_id = continuation_block,
            .num_cells_input = pushed,
        };
    }

    if(emit_settings.can_continue){
        emit_settings.continue_basicblock_context = (JumpContext){
            .basicblock_id = increment_block,
            .num_cells_input = pushed,
        };
    }
    
    emit_start_basicblock_landing(condition_block, pushed);
    // Evaluate condition
    u32 condition_type = expression_emit(expressions[operands[expression.ops + 1]]);
    if(condition_type == TYPES_CAPACITY) return 1;

    if(condition_type != u1_type){
        printf("\nerror on line %d: Expected 'for' condition to be 'u1', got '", u24_unpack(expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return 1;
    }

    u32 after_condition_pushed = emit_end_basicblock_jump_conditional(body_block, continuation_block);
    if(after_condition_pushed != pushed){
        printf("\ninternal error: emit_for_stack() got bad push amount for jumping to body/continuation blocks (%d vs %d)\n", after_condition_pushed, pushed);

        if(emit_context.function < FUNCTIONS_CAPACITY){
            printf("\n  Inside of function: ");
            print_aux_cstr(functions[emit_context.function].name);
            printf("\n");
        }
        return 1;
    }

    emit_start_basicblock_landing(body_block, pushed);
    // Emit 'for' body
    if(emit_body_scoped(inside_start_statement, inside_start_statement + num_inside, false) != 0){
        return 1;
    }
    if(emit_settings.in_basicblock){
        emit_end_basicblock_jump_compatible(increment_block, pushed);
    } else {
        emit_settings.break_basicblock_context = old_break_context;
        emit_settings.continue_basicblock_context = old_continue_context;
        emit_settings.can_break = was_breakable;
        emit_settings.can_continue = was_continuable;
        return 0;
    }

    emit_start_basicblock_landing(increment_block, pushed);
    // Emit post-statements
    if(emit_body_scoped(post_start_statement, post_start_statement + num_post, false) != 0){
        return 1;
    }
    if(emit_settings.in_basicblock){
        emit_end_basicblock_jump_compatible(condition_block, pushed);
    } else {
        emit_settings.break_basicblock_context = old_break_context;
        emit_settings.continue_basicblock_context = old_continue_context;
        emit_settings.can_break = was_breakable;
        emit_settings.can_continue = was_continuable;
        return 0;
    }

    emit_start_basicblock_landing(continuation_block, pushed);

    // Deallocate pre-statement variables
    if(pre_num_cells != 0){
        printf("%d<", pre_num_cells);
        emit_context.current_cell_index -= pre_num_cells;
    }

    emit_settings.break_basicblock_context = old_break_context;
    emit_settings.continue_basicblock_context = old_continue_context;
    emit_settings.can_break = was_breakable;
    emit_settings.can_continue = was_continuable;
    return 0;
}

ErrorCode emit_for_tape(Expression expression){
    u1 was_breakable = emit_settings.can_break;
    u1 was_continuable = emit_settings.can_continue;
    u32 old_didnt_break_cell = emit_context.didnt_break_cell;
    u32 old_didnt_continue_cell = emit_context.didnt_continue_cell;

    u32 num_pre = operands[expression.ops];
    u32 num_post = operands[expression.ops + 2];
    u32 num_inside = operands[expression.ops + 3];

    u32 pre_start_statement = emit_context.current_statement + 1;
    u32 post_start_statement = pre_start_statement + num_pre;
    u32 inside_start_statement = post_start_statement + num_post;

    u32 pre_starting_cell_index = emit_context.current_cell_index;

    u32 for_statement_index = emit_context.current_statement;

    // Emit pre-statements
    if(emit_body(pre_start_statement, pre_start_statement + num_pre, false) != 0){
        return 1;
    }

    emit_context.current_statement = for_statement_index;
    enter_maybe_breakable_continuable_loop_tape(expression, 4);
    emit_context.current_statement = pre_start_statement + num_pre;

    u32 starting_cell_index = emit_context.current_cell_index;
    
    // Evaluate condition
    emit_pre_loop_condition_early_return_check();
    u32 condition_type = expression_emit(expressions[operands[expression.ops + 1]]);
    if(condition_type == TYPES_CAPACITY) return 1;
    emit_post_loop_condition_early_return_check();

    if(condition_type != u1_type){
        printf("\nerror on line %d: Expected 'for' condition to be 'u1', got '", u24_unpack(expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return 1;
    }

    // Go to 'condition' cell
    printf("<");
    emit_context.current_cell_index--;

    // While 'condition' cell
    printf("[");
    emit_reset_didnt_continue();

    // Emit 'for' body
    if(emit_body(inside_start_statement, inside_start_statement + num_inside, false) != 0){
        return 1;
    }

    // Emit post-statements
    u32 post_statements_closes_needed_waterline = num_closes_needed;

    if( emit_break_check() != 0
     || emit_early_return_check() != 0
     || emit_body(post_start_statement, post_start_statement + num_post, false) != 0
     || emit_close_checks_until(post_statements_closes_needed_waterline) != 0
    ){
        return 1;
    }

    // Deallocate variables
    if(emit_context.current_cell_index > starting_cell_index){
        printf("%d<", emit_context.current_cell_index - starting_cell_index);
        emit_context.current_cell_index = starting_cell_index;
    }

    // Re-evaluate condition (should never fail)
    emit_pre_loop_condition_early_return_check();
    emit_pre_loop_condition_break_check();
    (u0) expression_emit(expressions[operands[expression.ops + 1]]);
    emit_post_loop_condition_break_check();
    emit_post_loop_condition_early_return_check();

    // Go to 'condition' cell
    printf("<");
    emit_context.current_cell_index--;

    // End while
    printf("]");

    exit_maybe_breakable_continuable_loop();

    // Deallocate pre-statement variables
    if(emit_context.current_cell_index > pre_starting_cell_index){
        printf("%d<", emit_context.current_cell_index - pre_starting_cell_index);
        emit_context.current_cell_index = pre_starting_cell_index;
    }

    emit_settings.can_break = was_breakable;
    emit_settings.can_continue = was_continuable;
    emit_context.didnt_break_cell = old_didnt_break_cell;
    emit_context.didnt_continue_cell = old_didnt_continue_cell;

    return (ErrorCode) (emit_break_check() != 0 || emit_continue_check() != 0 || emit_early_return_check() != 0);
}

ErrorCode emit_conditionless_block(Expression expression){
    // Emit body
    if(emit_body_scoped(emit_context.current_statement + 1, emit_context.current_statement + expression.ops + 1, false) != 0){
        return 1;
    }

    return 0;
}

ErrorCode emit_switch(Expression expression){
    if(emit_context.in_recursive_function){
        return emit_switch_stack(expression);
    } else {
        return emit_switch_tape(expression);
    }
}

u32 emit_switch_eval_value(Expression switch_expression){
    // Returns size of value or -1 on error

    u32 condition_type = expression_emit(expressions[operands[switch_expression.ops]]);
    if(condition_type == TYPES_CAPACITY) return -1;

    u1 ok = false;

    if(condition_type == u8_type){
        ok = true;
    } else {
        u32 found_enum = find_enum_from_type(condition_type);
        
        if(found_enum <= TYPEDEFS_CAPACITY){
            TypeDef def = typedefs[found_enum];

            if(def.kind == TYPEDEF_ENUM && def.computed_size == 1){
                ok = true;
            }
        }
    }

    if(!ok){
        printf("\nerror on line %d: Expected 'switch' value to be 'u8', got '", u24_unpack(switch_expression.line));
        type_print(types[condition_type]);
        printf("'\n");
        return -1;
    }

    u32 condition_type_size = type_sizeof_or_max(condition_type, switch_expression.line);
    if(condition_type_size == -1) return -1;

    emit_context.switch_value_type = condition_type;
    emit_context.switch_value_type_cached_size = condition_type_size;
    return condition_type_size;
}

typedef struct {
    u32 num_cases;
    u1 has_default;
} SwitchInfo;

SwitchInfo get_switch_case_info(Expression switch_expression){
    SwitchInfo info;

    u32 length = operands[switch_expression.ops + 1];
    u32 start_statement = emit_context.current_statement + 1;
    u32 stop_statement = start_statement + length;

    for(u32 i = start_statement; i < stop_statement; i++){
        Expression expression = expressions[statements[i]];

        switch(expression.kind){
        case EXPRESSION_NONE:
        case EXPRESSION_RETURN:
        case EXPRESSION_DECLARE:
        case EXPRESSION_PRINT_LITERAL:
        case EXPRESSION_PRINT_ARRAY:
        case EXPRESSION_PRINTF:
        case EXPRESSION_MEMCMP:
        case EXPRESSION_MEMCPY:
        case EXPRESSION_CALL:
        case EXPRESSION_IMPLEMENT_PUT:
        case EXPRESSION_IMPLEMENT_PRINTU1:
        case EXPRESSION_IMPLEMENT_PRINTU8:
        case EXPRESSION_IMPLEMENT_GET:
        case EXPRESSION_IMPLEMENT_READU8:
        case EXPRESSION_U1:
        case EXPRESSION_U8:
        case EXPRESSION_U16:
        case EXPRESSION_U24:
        case EXPRESSION_U32:
        case EXPRESSION_INT:
        case EXPRESSION_VARIABLE:
        case EXPRESSION_CAST:
        case EXPRESSION_ASSIGN:
        case EXPRESSION_ADD:
        case EXPRESSION_SUBTRACT:
        case EXPRESSION_MULTIPLY:
        case EXPRESSION_DIVIDE:
        case EXPRESSION_MOD:
        case EXPRESSION_EQUALS:
        case EXPRESSION_NOT_EQUALS:
        case EXPRESSION_LESS_THAN:
        case EXPRESSION_GREATER_THAN:
        case EXPRESSION_LESS_THAN_OR_EQUAL:
        case EXPRESSION_GREATER_THAN_OR_EQUAL:
        case EXPRESSION_LSHIFT:
        case EXPRESSION_RSHIFT:
        case EXPRESSION_AND:
        case EXPRESSION_OR:
        case EXPRESSION_BIT_AND:
        case EXPRESSION_BIT_OR:
        case EXPRESSION_BIT_XOR:
        case EXPRESSION_NEGATE:
        case EXPRESSION_NOT:
        case EXPRESSION_BIT_COMPLEMENT:
        case EXPRESSION_INDEX:
        case EXPRESSION_PRE_INCREMENT:
        case EXPRESSION_PRE_DECREMENT:
        case EXPRESSION_POST_INCREMENT:
        case EXPRESSION_POST_DECREMENT:
        case EXPRESSION_NO_RESULT_INCREMENT:
        case EXPRESSION_NO_RESULT_DECREMENT:
        case EXPRESSION_TERNARY:
        case EXPRESSION_MEMBER:
        case EXPRESSION_STRING:
        case EXPRESSION_BREAK:
        case EXPRESSION_CONTINUE:
        case EXPRESSION_SIZEOF_TYPE:
        case EXPRESSION_SIZEOF_TYPE_U8:
        case EXPRESSION_SIZEOF_TYPE_U16:
        case EXPRESSION_SIZEOF_TYPE_U24:
        case EXPRESSION_SIZEOF_TYPE_U32:
        case EXPRESSION_SIZEOF_VALUE:
        case EXPRESSION_SIZEOF_VALUE_U8:
        case EXPRESSION_SIZEOF_VALUE_U16:
        case EXPRESSION_SIZEOF_VALUE_U24:
        case EXPRESSION_SIZEOF_VALUE_U32:
        case EXPRESSION_ARRAY_INITIALIZER:
        case EXPRESSION_STRUCT_INITIALIZER:
        case EXPRESSION_FIELD_INITIALIZER:
        case EXPRESSION_ENUM_VARIANT:
        case EXPRESSION_PANICLOOP:
            break;
        case EXPRESSION_IF:
        case EXPRESSION_WHILE:
        case EXPRESSION_DO_WHILE:
        case EXPRESSION_SWITCH:
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_IF_ELSE:
            i += operands[expression.ops + 1] + operands[expression.ops + 2];
            break;
        case EXPRESSION_CONDITIONLESS_BLOCK:
            i += expression.ops;
            break;
        case EXPRESSION_FOR:
            i += operands[expression.ops] + operands[expression.ops + 2] + operands[expression.ops + 3];
            break;
        case EXPRESSION_CASE:
            if(operands[expression.ops] == EXPRESSIONS_CAPACITY){
                info.has_default = true;
            } else {
                info.num_cases++;
            }
            break;
        }
    }

    return info;
}

ErrorCode emit_switch_stack(Expression expression){
    /*
    EXAMPLE SOURCE CODE:

        switch(value){
        case 100:
            a();
            break;
        case 75:
            b();
        default:
            c();
        }

    Each case testing gets it's own basicblock
    Each case gets it's own entry basicblock
    */

    SwitchInfo info = get_switch_case_info(expression);
    u32 num_cases = info.num_cases;
    u1 has_default_case = info.has_default;

    // Reserve Basicblock IDs for each test case
    u32 first_case_test_basicblock_id = emit_settings.next_basicblock_id;
    emit_settings.next_basicblock_id += num_cases;

    // Reserve Basicblock ID for default case (if it exists)
    u32 default_block = emit_settings.next_basicblock_id++;
    u32 continuation_block;

    if(has_default_case){
        continuation_block = emit_settings.next_basicblock_id++;
    } else {
        continuation_block = default_block;
    }

    // Reserve Basicblock IDs for each case body
    u32 first_case_body_basicblock_id = emit_settings.next_basicblock_id;
    emit_settings.next_basicblock_id += num_cases;

    u1 was_breakable = emit_settings.can_break;
    u32 old_switch_value_type = emit_context.switch_value_type;
    u32 old_switch_value_type_cached_size = emit_context.switch_value_type_cached_size;
    SwitchContext old_switch_context = emit_settings.switch_basicblock_context;
    JumpContext old_break_basicblock_context = emit_settings.break_basicblock_context;

    // Evaluate condition
    u32 condition_type_size = emit_switch_eval_value(expression);
    if(condition_type_size == -1){
        return 1;
    }

    u32 pushed = emit_end_basicblock_jump(first_case_test_basicblock_id);

    // Setup how-to-break information
    emit_settings.can_break = true;
    emit_settings.switch_basicblock_context = (SwitchContext){
        .num_cases = num_cases,
        .has_default_case = has_default_case,
        .pushed = pushed,
        .first_case_test_basicblock_id = first_case_test_basicblock_id,
        .first_case_body_basicblock_id = first_case_body_basicblock_id,
        .next_case = (u32) 0,
        .default_basicblock_id = default_block,
        .continuation_basicblock_id = continuation_block,
    };
    emit_settings.break_basicblock_context = (JumpContext){
        .basicblock_id = continuation_block,
        .num_cells_input = pushed,
    };

    // Emit 'switch' body
    if(emit_body(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 1] + 1, true) != 0){
        return 1;
    }

    if(emit_settings.in_basicblock){
        u32 extra = emit_context.current_cell_index - emit_settings.switch_basicblock_context.pushed - emit_settings.stack_driver_position;

        // Discard extra
        if(extra != 0){
            printf("%d<", extra);
            emit_context.current_cell_index -= extra;
        }

        emit_end_basicblock_jump_compatible(continuation_block, pushed);
    }

    emit_start_basicblock_landing(continuation_block, pushed);

    // Discard switch value
    printf("%d<", condition_type_size);
    emit_context.current_cell_index -= condition_type_size;

    emit_settings.can_break = was_breakable;
    emit_context.switch_value_type = old_switch_value_type;
    emit_context.switch_value_type_cached_size = old_switch_value_type_cached_size;
    emit_settings.switch_basicblock_context = old_switch_context;
    emit_settings.break_basicblock_context = old_break_basicblock_context;
    return 0;
}

ErrorCode emit_switch_tape(Expression expression){
    // Switches are implemented by leveraging existing break/continue/early-return infrastructure.
    
    /*
    EXAMPLE SOURCE CODE:

        switch(value){
        case 100:
            a();
            break;
        case 75:
            b();
        default:
            c();
        }

    PSEUDO CODE RESULT:

        {
            u8 value = value;
            u1 didnt_break = true;
            u1 fell_through = false;

            if(fell_through || value == 100){
                a();
                didnt_break = false;
            }

            if(didnt_break && didnt_continue && didnt_return_early){
                if(fell_through || value == 75){
                    b();
                    fell_through = true;
                }

                // NOTE: In practice these checks are omitted when previous code cannot cause them.
                if(didnt_break && didnt_continue && didnt_return_early){
                    // (default case)
                    c();
                }
            }
        }
    */

    u1 was_breakable = emit_settings.can_break;
    u32 old_didnt_break_cell = emit_context.didnt_break_cell;
    u32 old_switch_value_type = emit_context.switch_value_type;
    u32 old_switch_value_type_cached_size = emit_context.switch_value_type_cached_size;
    u32 old_switch_start_cell_index = emit_context.switch_start_cell_index;
    u32 old_fell_through_cell = emit_context.fell_through_cell;

    enter_switch();

    u32 starting_cell_index = emit_context.current_cell_index;
    emit_context.switch_start_cell_index = starting_cell_index;
    
    // Evaluate condition
    u32 condition_type_size = emit_switch_eval_value(expression);
    if(condition_type_size == -1){
        return 1;
    }

    // Emit 'switch' body
    if(emit_body(emit_context.current_statement + 1, emit_context.current_statement + operands[expression.ops + 1] + 1, true) != 0){
        return 1;
    }

    // Deallocate variables
    if(emit_context.current_cell_index > starting_cell_index){
        printf("%d<", emit_context.current_cell_index - starting_cell_index);
        emit_context.current_cell_index = starting_cell_index;
    }

    exit_switch();

    emit_settings.can_break = was_breakable;
    emit_context.didnt_break_cell = old_didnt_break_cell;
    emit_context.switch_value_type = old_switch_value_type;
    emit_context.switch_value_type_cached_size = old_switch_value_type_cached_size;
    emit_context.switch_start_cell_index = old_switch_start_cell_index;
    emit_context.fell_through_cell = old_fell_through_cell;

    return (ErrorCode) (emit_break_check() != 0 || emit_continue_check() != 0 || emit_early_return_check() != 0);
}

ErrorCode emit_case(Expression expression){
    if(emit_context.in_recursive_function){
        return emit_case_stack(expression);
    } else {
        return emit_case_tape(expression);
    }
}

ErrorCode emit_case_value_test(u32 value_expression){
    Expression expression = expressions[value_expression];

    // Evaluate test value
    u32 test_type = expression_emit(expression);
    if(test_type == TYPES_CAPACITY) return 1;

    if(test_type != emit_context.switch_value_type){
        printf("\nerror on line %d: Expected 'case' value to be '", u24_unpack(expression.line));
        type_print(types[emit_context.switch_value_type]);
        printf(", got '");
        type_print(types[test_type]);
        printf("'\n");
        return 1;
    }

    // Compare test value to switch value
    u1 ok = false;

    if(emit_context.switch_value_type == u8_type){
        emit_eq_u8();
        ok = true;
    } else {
        u32 found_enum = find_enum_from_type(emit_context.switch_value_type);
        
        if(found_enum <= TYPEDEFS_CAPACITY){
            TypeDef def = typedefs[found_enum];

            if(def.kind == TYPEDEF_ENUM && def.computed_size == 1){
                emit_eq_u8();
                ok = true;
            }
        }
    }

    if(!ok){
        printf("\nerror on line %d: Unsupported 'case' type '", u24_unpack(expression.line));
        type_print(types[test_type]);
        printf("'\n");
        return 1;
    }

    return 0;
}

ErrorCode emit_case_stack(Expression case_expression){
    u32 value_expression = operands[case_expression.ops];
    u32 test_block;
    u32 body_block;
    u32 else_block;

    if(value_expression == EXPRESSIONS_CAPACITY){
        // Default case
        test_block = -1;
        else_block = -1;
        body_block = emit_settings.switch_basicblock_context.default_basicblock_id;
    } else {
        u32 case_i = emit_settings.switch_basicblock_context.next_case++;
        test_block = emit_settings.switch_basicblock_context.first_case_test_basicblock_id + case_i;
        body_block = emit_settings.switch_basicblock_context.first_case_body_basicblock_id + case_i;
        else_block = test_block + 1;
    }

    // Fall through from previous case body if still open
    if(emit_settings.in_basicblock){
        u32 extra = emit_context.current_cell_index - emit_settings.switch_basicblock_context.pushed - emit_settings.stack_driver_position;

        // Discard extra
        if(extra != 0){
            printf("%d<", extra);
            emit_context.current_cell_index -= extra;
        }

        // Fall though to next block
        emit_end_basicblock_jump_compatible(body_block, emit_settings.switch_basicblock_context.pushed);
    }

    // Emit test value
    if(value_expression != EXPRESSIONS_CAPACITY){
        emit_start_basicblock_landing(test_block, emit_settings.switch_basicblock_context.pushed);

        // Dupe switch value
        copy_cells_static(emit_context.current_cell_index - emit_context.switch_value_type_cached_size, emit_context.switch_value_type_cached_size);

        if(emit_case_value_test(value_expression) != 0){
            return 1;
        }

        (u0) emit_end_basicblock_jump_conditional(body_block, else_block);
    }

    emit_start_basicblock_landing(body_block, emit_settings.switch_basicblock_context.pushed);

    // Emit 'case' body
    u32 len = operands[case_expression.ops + 1];
    if(emit_body(emit_context.current_statement + 1, emit_context.current_statement + len + 1, false) != 0){
        return 1;
    }

    // Don't end basicblock unless ended by user
    return 0;
}

ErrorCode emit_case_tape(Expression expression){
    // Emits code for case statements

    if(emit_context.switch_value_type == TYPES_CAPACITY){
        expression_print_cannot_use_case_here_error(expression);
        return 1;
    }

    u32 starting_cell_index = emit_context.current_cell_index;
    u32 value_expression = operands[expression.ops];

    if(value_expression != EXPRESSIONS_CAPACITY){
        emit_pre_case_fallthrough_check();

        // Dupe switch value
        copy_cells_static(emit_context.switch_start_cell_index, emit_context.switch_value_type_cached_size);

        if(emit_case_value_test(value_expression) != 0){
            return 1;
        }

        emit_post_case_fallthrough_check();

        // Go to condition
        printf("<");
        emit_context.current_cell_index--;

        // If condition
        printf("[");
    }

    // Emit 'case' body
    u32 len = operands[expression.ops + 1];
    if(emit_body(emit_context.current_statement + 1, emit_context.current_statement + len + 1, false) != 0){
        return 1;
    }

    // Deallocate variables
    if(emit_context.current_cell_index > starting_cell_index){
        printf("%d<", emit_context.current_cell_index - starting_cell_index);
        emit_context.current_cell_index = starting_cell_index;
    }

    if(value_expression != EXPRESSIONS_CAPACITY){
        ExpressionKind termination = expressions[statements[emit_context.current_statement]].kind;

        if(len == 0 || !(termination == EXPRESSION_BREAK || termination == EXPRESSION_CONTINUE || termination == EXPRESSION_RETURN)){
            // Fall through
            u32 offset = emit_context.current_cell_index - emit_context.fell_through_cell;
            printf("%d<[-]+%d>", offset, offset);
        }

        // End if
        printf("[-]]");
    }

    return (ErrorCode) (emit_break_check() != 0 || emit_continue_check() != 0 || emit_early_return_check() != 0);
}

u1 has_return_in_region(u32 start_statement_i, u32 stop_statement_i){
    for(u32 i = start_statement_i; i < stop_statement_i; i++){
        if(expressions[statements[i]].kind == EXPRESSION_RETURN){
            return true;
        }
    }

    return false;
}

u1 can_function_early_return(u32 function_index){
    Function function = functions[function_index];

    for(u32 i = function.begin; i < function.begin + function.num_stmts; i++){
        Expression expression = expressions[statements[i]];

        switch(expression.kind){
        case EXPRESSION_NONE:
        case EXPRESSION_DECLARE:
        case EXPRESSION_PRINT_LITERAL:
        case EXPRESSION_PRINT_ARRAY:
        case EXPRESSION_PRINTF:
        case EXPRESSION_MEMCMP:
        case EXPRESSION_MEMCPY:
        case EXPRESSION_CALL:
        case EXPRESSION_IMPLEMENT_PUT:
        case EXPRESSION_IMPLEMENT_PRINTU1:
        case EXPRESSION_IMPLEMENT_PRINTU8:
        case EXPRESSION_IMPLEMENT_GET:
        case EXPRESSION_IMPLEMENT_READU8:
        case EXPRESSION_U1:
        case EXPRESSION_U8:
        case EXPRESSION_U16:
        case EXPRESSION_U24:
        case EXPRESSION_U32:
        case EXPRESSION_INT:
        case EXPRESSION_VARIABLE:
        case EXPRESSION_CAST:
        case EXPRESSION_ASSIGN:
        case EXPRESSION_ADD:
        case EXPRESSION_SUBTRACT:
        case EXPRESSION_MULTIPLY:
        case EXPRESSION_DIVIDE:
        case EXPRESSION_MOD:
        case EXPRESSION_EQUALS:
        case EXPRESSION_NOT_EQUALS:
        case EXPRESSION_LESS_THAN:
        case EXPRESSION_GREATER_THAN:
        case EXPRESSION_LESS_THAN_OR_EQUAL:
        case EXPRESSION_GREATER_THAN_OR_EQUAL:
        case EXPRESSION_LSHIFT:
        case EXPRESSION_RSHIFT:
        case EXPRESSION_AND:
        case EXPRESSION_OR:
        case EXPRESSION_BIT_AND:
        case EXPRESSION_BIT_OR:
        case EXPRESSION_BIT_XOR:
        case EXPRESSION_NEGATE:
        case EXPRESSION_NOT:
        case EXPRESSION_BIT_COMPLEMENT:
        case EXPRESSION_INDEX:
        case EXPRESSION_PRE_INCREMENT:
        case EXPRESSION_PRE_DECREMENT:
        case EXPRESSION_POST_INCREMENT:
        case EXPRESSION_POST_DECREMENT:
        case EXPRESSION_NO_RESULT_INCREMENT:
        case EXPRESSION_NO_RESULT_DECREMENT:
        case EXPRESSION_TERNARY:
        case EXPRESSION_MEMBER:
        case EXPRESSION_STRING:
        case EXPRESSION_BREAK:
        case EXPRESSION_CONTINUE:
        case EXPRESSION_SIZEOF_TYPE:
        case EXPRESSION_SIZEOF_TYPE_U8:
        case EXPRESSION_SIZEOF_TYPE_U16:
        case EXPRESSION_SIZEOF_TYPE_U24:
        case EXPRESSION_SIZEOF_TYPE_U32:
        case EXPRESSION_SIZEOF_VALUE:
        case EXPRESSION_SIZEOF_VALUE_U8:
        case EXPRESSION_SIZEOF_VALUE_U16:
        case EXPRESSION_SIZEOF_VALUE_U24:
        case EXPRESSION_SIZEOF_VALUE_U32:
        case EXPRESSION_CASE:
        case EXPRESSION_ARRAY_INITIALIZER:
        case EXPRESSION_STRUCT_INITIALIZER:
        case EXPRESSION_FIELD_INITIALIZER:
        case EXPRESSION_ENUM_VARIANT:
        case EXPRESSION_PANICLOOP:
            break;

        case EXPRESSION_IF:
        case EXPRESSION_WHILE:
        case EXPRESSION_DO_WHILE:
            if(has_return_in_region(i + 1, i + operands[expression.ops + 1] + 1)) return true;
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_IF_ELSE: {
                u32 num_then = operands[expression.ops + 1];
                u32 num_else = operands[expression.ops + 2];
                if(has_return_in_region(i + 1, i + num_then + num_else + 1)) return true;
                i += num_then + num_else;
            }
            break;
        case EXPRESSION_CONDITIONLESS_BLOCK:
            if(has_return_in_region(i + 1, i + expression.ops + 1)) return true;
            i += expression.ops + 1;
            break;
        case EXPRESSION_FOR: {
                u32 num_pre = operands[expression.ops];
                u32 num_post = operands[expression.ops + 2];
                u32 len = operands[expression.ops + 3];

                if(has_return_in_region(i + 1, i + num_pre + num_post + len + 1)) return true;
                i += num_pre + num_post + len;
            }
            break;
        case EXPRESSION_SWITCH:
            if(has_return_in_region(i + 1, i + operands[expression.ops + 1] + 1)) return true;
            break;
        case EXPRESSION_RETURN:
            return false;
        }
    }

    return false;
}

u1 can_statements_break_current_level(u32 start_statement_i, u32 stop_statement_i){
    for(u32 i = start_statement_i; i < stop_statement_i; i++){
        Expression expression = expressions[statements[i]];

        switch(expression.kind){
        case EXPRESSION_WHILE:
        case EXPRESSION_DO_WHILE:
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_FOR:
            if(can_statement_break_current_level(i)){
                return true;
            }
            i += operands[expression.ops] + operands[expression.ops + 2] + operands[expression.ops + 3];
            break;
        default:
            if(can_statement_break_current_level(i)){
                return true;
            }
        }
    }

    return false;
}

u1 can_statement_break_current_level(u32 statement_index){
    Expression expression = expressions[statements[statement_index]];

    switch(expression.kind){
    case EXPRESSION_IF: {
            u32 num_then = operands[expression.ops + 1];
            return can_statements_break_current_level(statement_index + 1, statement_index + 1 + num_then);
        }
        break;
    case EXPRESSION_IF_ELSE: {
            u32 num_then = operands[expression.ops + 1];
            u32 num_else = operands[expression.ops + 2];
            return can_statements_break_current_level(statement_index + 1, statement_index + 1 + num_then + num_else);
        }
        break;
    case EXPRESSION_FOR: {
            u32 num_pre = operands[expression.ops];
            return can_statements_break_current_level(statement_index + 1, statement_index + num_pre + 1);
        }
        break;
    case EXPRESSION_BREAK:
        return true;
    default:
        return false;
    }
}

u1 can_loop_break(u32 statement_index){
    Expression container = expressions[statements[statement_index]];

    switch(container.kind){
    case EXPRESSION_WHILE:
    case EXPRESSION_DO_WHILE: {
            u32 num_inside = operands[container.ops + 1];
            return can_statements_break_current_level(statement_index + 1, statement_index + 1 + num_inside);
        }
        break;
    case EXPRESSION_FOR: {
            u32 num_pre = operands[container.ops];
            u32 num_post = operands[container.ops + 2];
            u32 num_inside = operands[container.ops + 3];

            u32 pre_start_statement = statement_index + 1;
            u32 post_start_statement = pre_start_statement + num_pre;
            u32 inside_start_statement = post_start_statement + num_post;

            return
                can_statements_break_current_level(inside_start_statement, inside_start_statement + num_inside)
             || can_statements_break_current_level(post_start_statement, post_start_statement + num_post);
        }
        break;
    default:
        return can_statement_break_current_level(statement_index);
    }
}

u1 can_statements_continue_current_level(u32 start_statement_i, u32 stop_statement_i){
    for(u32 i = start_statement_i; i < stop_statement_i; i++){
        Expression expression = expressions[statements[i]];

        switch(expression.kind){
        case EXPRESSION_WHILE:
        case EXPRESSION_DO_WHILE:
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_FOR:
            if(can_statement_continue_current_level(i)){
                return true;
            }
            i += operands[expression.ops] + operands[expression.ops + 2] + operands[expression.ops + 3];
            break;
        default:
            if(can_statement_continue_current_level(i)){
                return true;
            }
        }
    }

    return false;
}

u1 can_statement_continue_current_level(u32 statement_index){
    Expression expression = expressions[statements[statement_index]];

    switch(expression.kind){
    case EXPRESSION_IF: {
            u32 num_then = operands[expression.ops + 1];
            return can_statements_continue_current_level(statement_index + 1, statement_index + 1 + num_then);
        }
        break;
    case EXPRESSION_IF_ELSE: {
            u32 num_then = operands[expression.ops + 1];
            u32 num_else = operands[expression.ops + 2];
            return can_statements_continue_current_level(statement_index + 1, statement_index + 1 + num_then + num_else);
        }
        break;
    case EXPRESSION_FOR: {
            u32 num_pre = operands[expression.ops];
            return can_statements_continue_current_level(statement_index + 1, statement_index + num_pre + 1);
        }
        break;
    case EXPRESSION_CONTINUE:
        return true;
    default:
        return false;
    }
}

u1 can_loop_continue(u32 statement_index){
    Expression container = expressions[statements[statement_index]];

    switch(container.kind){
    case EXPRESSION_WHILE:
    case EXPRESSION_DO_WHILE: {
            u32 num_inside = operands[container.ops + 1];
            return can_statements_continue_current_level(statement_index + 1, statement_index + 1 + num_inside);
        }
        break;
    case EXPRESSION_FOR: {
            u32 num_pre = operands[container.ops];
            u32 num_post = operands[container.ops + 2];
            u32 num_inside = operands[container.ops + 3];

            u32 pre_start_statement = statement_index + 1;
            u32 post_start_statement = pre_start_statement + num_pre;
            u32 inside_start_statement = post_start_statement + num_post;

            return
                can_statements_continue_current_level(inside_start_statement, inside_start_statement + num_inside)
             || can_statements_continue_current_level(post_start_statement, post_start_statement + num_post);
        }
        break;
    default:
        return can_statement_continue_current_level(statement_index);
    }
}

ErrorCode emit_globals_initialization(){
    u32 global_variable_cell_offset = 0;
    for(u32 global_i = 0; global_i < num_globals; global_i++){
        Global global = globals[global_i];

        u32 size = type_sizeof_or_max(global.type, global.line);
        if(size == -1) return 1;

        if(global.initializer < EXPRESSIONS_CAPACITY){
            u32 type = expression_emit(expressions[global.initializer]);
            if(type == TYPES_CAPACITY) return 1;

            if(type != global.type){
                if(grow_type(type, global.type, 0) != 0){
                    printf("\nerror on line %d: Cannot assign '", u24_unpack(global.line));
                    type_print(types[type]);
                    printf("' to '");
                    type_print(types[global.type]);
                    printf("'\n");
                    return 1;
                }

                type = global.type;
            }

            printf("<");
            emit_context.current_cell_index--;

            move_cells_static(global_variable_cell_offset, size);
        }

        global_variable_cell_offset += size;
    }

    return 0;
}

ErrorCode function_emit(u32 function_index, u32 start_function_cell_index, u32 start_current_cell_index){
    Function function = functions[function_index];
    u1 can_early_return = can_function_early_return(function_index);

    EmitContext old_emit_context = emit_context;

    emit_context = (EmitContext){
        .function = function_index,
        .function_cell_index = start_function_cell_index,
        .current_cell_index = start_current_cell_index,
        .current_statement = function.begin,
        .in_recursive_function = function.is_recursive,
        .can_function_early_return = can_early_return,
        .incomplete_cell = -(u32) 1,
        .didnt_break_cell = -(u32) 1,
        .didnt_continue_cell = -(u32) 1,
        .switch_value_type = TYPES_CAPACITY,
        .switch_value_type_cached_size = -(u32) 1,
        .switch_start_cell_index = -(u32) 1,
        .fell_through_cell = -(u32) 1,
    };
    
    // Allocate 'incomplete' cell if function can return early
    if(can_early_return){
        printf("[-]+>");
        emit_context.incomplete_cell = emit_context.current_cell_index++;
    }

    if(function_index == emit_settings.main_function_index){
        if(function.return_type != u0_type){
            printf("\nerror on line %d: Main function must have the return type 'u0'\n", u24_unpack(function.line));
            return 1;
        }

        if(emit_globals_initialization() != 0){
            return 1;
        }
    }

    if(emit_body(function.begin + (u32) function.arity, function.begin + function.num_stmts, false) != 0){
        return 1;
    }

    if(emit_context.current_cell_index > start_function_cell_index){
        printf("%d<", emit_context.current_cell_index - start_function_cell_index);
    }

    emit_context = old_emit_context;
    emit_context.current_cell_index = start_function_cell_index;
    return 0;
}



u0 function_infer(u32 function_index){
    Function function = functions[function_index];

    for(u32 i = 0; i < function.num_stmts; i++){
        u32 statement = statements[function.begin + i];

        // For variable lookups
        emit_context.function = function_index;
        emit_context.current_statement = function.begin + i;

        expression_infer(statement, EXPRESSION_NONE);
    }
}



u0 indent(u32 indentation){
    for(u32 i = 0; i < indentation; i++){
        printf("    ");
    }
}

u0 print_body(u32 start_i, u32 stop_i, u32 indentation, u1 print_trailing_semicolon){
    for(u32 i = start_i; i < stop_i; i++){
        printf(" ");
        if(i < 10) printf("0");
        printf("%d ", i);
        if(indentation > 1){
            indent(indentation - 1);
        }

        Expression expression = expressions[statements[i]];

        switch(expression.kind){
        case EXPRESSION_IF:
        case EXPRESSION_IF_ELSE: {
                u32 when_true_len = operands[expression.ops + 1];

                printf("if(");
                expression_print(expressions[operands[expression.ops]]);
                printf("){\n");
                print_body(i + 1, i + when_true_len + 1, indentation + 1, true);
                i += when_true_len;

                indent(indentation);
                printf("}");

                if(expression.kind == EXPRESSION_IF_ELSE){
                    u32 when_false_len = operands[expression.ops + 2];
                    printf(" else {\n");
                    print_body(i + 1, i + when_false_len + 1, indentation + 1, true);
                    i += when_false_len;
                    indent(indentation);
                    printf("}");
                }

                printf("\n");
            }
            break;
        case EXPRESSION_WHILE: {
                u32 len = operands[expression.ops + 1];

                printf("while(");
                expression_print(expressions[operands[expression.ops]]);
                printf("){\n");
                print_body(i + 1, i + len + 1, indentation + 1, true);
                i += len;

                indent(indentation);
                printf("}\n");
            }
            break;
        case EXPRESSION_DO_WHILE: {
                u32 len = operands[expression.ops + 1];

                printf("do {\n");
                print_body(i + 1, i + len + 1, indentation + 1, true);
                i += len;

                indent(indentation);
                printf("} while(");
                expression_print(expressions[operands[expression.ops]]);
                printf(")");

                if(print_trailing_semicolon){
                    printf(";");
                }

                printf("\n");
            }
            break;
        case EXPRESSION_FOR: {
                u32 num_pre = operands[expression.ops + 0];
                u32 condition = operands[expression.ops + 1];
                u32 num_post = operands[expression.ops + 2];
                u32 len = operands[expression.ops + 3];

                printf("for(\n");
                indent(indentation);
                printf("{ // Pre-statements\n");
                print_body(i + 1, i + num_pre + 1, indentation + 1, true);
                i += num_pre;
                indent(indentation);
                printf("};\n");
                indent(indentation + 1);
                expression_print(expressions[condition]);
                printf(";\n");
                indent(indentation);
                printf("{ // Post-statements\n");
                print_body(i + 1, i + num_post + 1, indentation + 1, false);
                i += num_post;
                indent(indentation);
                printf("}\n");
                indent(indentation);
                printf("){\n");
                print_body(i + 1, i + len + 1, indentation + 1, true);
                i += len;
                indent(indentation);
                printf("}\n");
            }
            break;
        case EXPRESSION_CONDITIONLESS_BLOCK: {
                u32 len = expression.ops;

                printf("{\n");
                print_body(i + 1, i + len + 1, indentation + 1, true);
                i += len;

                indent(indentation);
                printf("}\n");
            }
            break;
        case EXPRESSION_SWITCH: {
                u32 len = operands[expression.ops + 1];

                printf("switch(");
                expression_print(expressions[operands[expression.ops]]);
                printf("){\n");
                print_body(i + 1, i + len + 1, indentation + 1, true);
                i += len;

                indent(indentation);
                printf("}\n");
            }
            break;
        case EXPRESSION_CASE:
            expression_print(expression);
            printf(":\n");
            break;
        default:
            expression_print(expression);
            if(print_trailing_semicolon){
                printf(";");
            }
            printf("\n");
        }
    }
}

u0 function_print(Function function){
    type_print(types[function.return_type]);
    printf(" ");
    print_aux_cstr(function.name);
    printf("(");

    u32 i = 0;

    while(i < function.num_stmts && i < (u32) function.arity){
        expression_print(expressions[statements[function.begin + i]]);
        i++;

        if(i != (u32) function.arity){
            printf(", ");
        }
    }

    printf("){\n");
    u32 start_i = function.begin + i;
    u32 stop_i = function.begin + function.num_stmts;
    print_body(start_i, stop_i, 1, true);
    printf("}");
}



u0 global_print(Global global){
    type_print(types[global.type]);
    printf(" ");
    print_aux_cstr(global.name);
    printf(";");
}



u32 infer(){
    for(u32 i = 0; i < num_globals; i++){
        Global global = globals[i];

        if(global.initializer < EXPRESSIONS_CAPACITY){
            expression_infer(global.initializer, type_to_expression_kind(global.type));
        }
    }

    for(u32 i = 0; i < num_functions; i++){
        function_infer(i);
    }
    return 0;
}



typedef struct {
    u8 c;
    TokenKind kind;
} SimpleToken;

SimpleToken simple_tokens[15] = {
    (SimpleToken){ .c = '{', .kind = TOKEN_BEGIN },
    (SimpleToken){ .c = '}', .kind = TOKEN_END },
    (SimpleToken){ .c = '(', .kind = TOKEN_OPEN },
    (SimpleToken){ .c = ')', .kind = TOKEN_CLOSE },
    (SimpleToken){ .c = ';', .kind = TOKEN_SEMICOLON },
    (SimpleToken){ .c = '[', .kind = TOKEN_OPEN_BRACKET },
    (SimpleToken){ .c = ']', .kind = TOKEN_CLOSE_BRACKET },
    (SimpleToken){ .c = ',', .kind = TOKEN_NEXT },
    (SimpleToken){ .c = '~', .kind = TOKEN_BIT_COMPLEMENT },
    (SimpleToken){ .c = '?', .kind = TOKEN_TERNARY },
    (SimpleToken){ .c = ':', .kind = TOKEN_COLON },
    (SimpleToken){ .c = '.', .kind = TOKEN_MEMBER },
    (SimpleToken){ .c = '#', .kind = TOKEN_HASH },
};

u1 is_ident(u8 c){
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9');
}

LexedToken lex_hex_integer(u32 i, u24 line){
    u32 value = 0;

    while(i < code_buffer_length){
        u8 lead = code_buffer[i];

        if(lead >= '0' && lead <= '9'){
            value = 16 * value + lead - '0';
        } else if(lead >= 'A' && lead <= 'F'){
            value = 16 * value + 10 + lead - 'A';
        } else if(lead >= 'a' && lead <= 'f'){
            value = 16 * value + 10 + lead - 'a';
        } else {
            break;
        }

        i++;
    }

    return (LexedToken){
        .token = (Token){
            .kind = TOKEN_INT,
            .data = value,
            .line = line,
        },
        .consumed = i,
    };
}

LexedToken lex_dec_integer(u32 i, u32 lead, u24 line){
    u32 value = lead - '0';

    while(i < code_buffer_length){
        lead = code_buffer[i];

        if(!(lead >= '0' && lead <= '9')){
            break;
        }

        value = 10 * value + lead - '0';
        i++;
    }

    return (LexedToken){
        .token = (Token){
            .kind = TOKEN_INT,
            .data = value,
            .line = line,
        },
        .consumed = i,
    };
}

LexedToken lex_integer(u8 lead, u24 line){
    u32 i = 1;

    if(i < code_buffer_length){
        u8 next_lead = code_buffer[i];

        if(next_lead == 'x' || next_lead == 'X'){
            return lex_hex_integer(i + 1, line);
        } else {
            return lex_dec_integer(i, lead, line);
        }
    }

    return (LexedToken){
        .token = (Token){
            .kind = TOKEN_INT,
            .data = lead - '0',
            .line = line,
        },
        .consumed = i,
    };
}

LexedToken lex_main(){
    LexedToken result = (LexedToken){
        .token = (Token){
            .kind = TOKEN_NONE,
            .data = 0,
            .line = u24_pack(lex_line_number),
        },
        .consumed = 0,
    };

    // Handle empty
    if(code_buffer_length == 0){
        result.token.kind = TOKEN_DONE;
        return result;
    }

    // Handle whitespace
    u32 whitespace = 0;
    for(u32 i = 0; i < code_buffer_length; i++){
        u8 c = code_buffer[i];

        if(c == ' ' || c == '\n' || c == '\t'){
            whitespace++;
        } else {
            break;
        }
    }

    if(whitespace){
        result.consumed = whitespace;
        return result;
    }

    // Handle simple tokens
    for(u32 i = 0; i < sizeof simple_tokens / sizeof(SimpleToken); i++){
        SimpleToken simple = simple_tokens[i];

        if(code_buffer[0] == simple.c){
            result.token.kind = simple.kind;
            result.consumed = 1;
            return result;
        }
    }

    u8 lead = code_buffer[0];

    // Handle strings
    if(lead == '"'){
        result.token.kind = TOKEN_STRING;
        result.consumed = 1;
        return result;
    }

    // Handle integers
    if(lead >= '0' && lead <= '9'){
        return lex_integer(lead, result.token.line);
    }

    // Handle identifiers
    if(is_ident(lead)){
        result.token.kind = TOKEN_WORD;
        u32 i = 1;

        while(i < code_buffer_length){
            if(is_ident(code_buffer[i])){
                i++;
            } else {
                break;
            }
        }

        // NOTE: Anything words longer than code buffer size will be split in two
        result.consumed = i;
        return result;
    }

    // Handle equals
    if(lead == '='){
        if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_EQUALS;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_ASSIGN;
            result.consumed = 1;
        }
        return result;
    }

    // Handle not
    if(lead == '!'){
        if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_NOT_EQUALS;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_NOT;
            result.consumed = 1;
        }
        return result;
    }


    // Handle add
    if(lead == '+'){
        if(code_buffer_length > 1 && code_buffer[1] == '+'){
            result.token.kind = TOKEN_INCREMENT;
            result.consumed = 2;
        } else if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_ADD_ASSIGN;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_ADD;
            result.consumed = 1;
        }
        return result;
    }

    // Handle subtract
    if(lead == '-'){
        if(code_buffer_length > 1 && code_buffer[1] == '-'){
            result.token.kind = TOKEN_DECREMENT;
            result.consumed = 2;
        } else if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_SUBTRACT_ASSIGN;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_SUBTRACT;
            result.consumed = 1;
        }
        return result;
    }

    // Handle multiply
    if(lead == '*'){
        if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_MULTIPLY_ASSIGN;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_MULTIPLY;
            result.consumed = 1;
        }
        return result;
    }

    // Handle divide or line comment
    if(lead == '/'){
        if(code_buffer_length > 1 && code_buffer[1] == '/'){
            result.token.kind = TOKEN_LINE_COMMENT;
            result.consumed = 2;
            return result;
        } else if(code_buffer_length > 1 && code_buffer[1] == '*'){
            result.token.kind = TOKEN_MULTILINE_COMMENT;
            result.consumed = 2;
            return result;
        } else if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_DIVIDE_ASSIGN;
            result.consumed = 2;
            return result;
        } else {
            result.token.kind = TOKEN_DIVIDE;
            result.consumed = 1;
            return result;
        }
    }

    // Handle mod
    if(lead == '%'){
        if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_MOD_ASSIGN;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_MOD;
            result.consumed = 1;
        }
        return result;
    }
    
    // Handle less than
    if(lead == '<'){
        if(code_buffer_length > 1 && code_buffer[1] == '<'){
            if(code_buffer_length > 2 && code_buffer[2] == '='){
                result.token.kind = TOKEN_LSHIFT_ASSIGN;
                result.consumed = 3;
            } else {
                result.token.kind = TOKEN_LSHIFT;
                result.consumed = 2;
            }
        } else if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_LESS_THAN_OR_EQUAL;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_LESS_THAN;
            result.consumed = 1;
        }
        return result;
    }

    // Handle greater than
    if(lead == '>'){
        if(code_buffer_length > 1 && code_buffer[1] == '>'){
            if(code_buffer_length > 2 && code_buffer[2] == '='){
                result.token.kind = TOKEN_RSHIFT_ASSIGN;
                result.consumed = 3;
            } else {
                result.token.kind = TOKEN_RSHIFT;
                result.consumed = 2;
            }
        } else if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_GREATER_THAN_OR_EQUAL;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_GREATER_THAN;
            result.consumed = 1;
        }
        return result;
    }

    // Handle 'and'
    if(lead == '&'){
        if(code_buffer_length > 1 && code_buffer[1] == '&'){
            result.token.kind = TOKEN_AND;
            result.consumed = 2;
        } else if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_BIT_AND_ASSIGN;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_BIT_AND;
            result.consumed = 1;
        }
        return result;
    }

    // Handle 'or'
    if(lead == '|'){
        if(code_buffer_length > 1 && code_buffer[1] == '|'){
            result.token.kind = TOKEN_OR;
            result.consumed = 2;
        } else if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_BIT_OR_ASSIGN;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_BIT_OR;
            result.consumed = 1;
        }
        return result;
    }

    // Handle xor
    if(lead == '^'){
        if(code_buffer_length > 1 && code_buffer[1] == '='){
            result.token.kind = TOKEN_BIT_XOR_ASSIGN;
            result.consumed = 2;
        } else {
            result.token.kind = TOKEN_BIT_XOR;
            result.consumed = 1;
        }
        return result;
    }

    // Handle character literal
    if(lead == '\''){
        return lex_character_literal();
    }

    printf("error on line %d: Unknown character `%c` (ASCII %d)\n", lex_line_number, code_buffer[0], code_buffer[0]);
    result.token.kind = TOKEN_ERROR;
    result.consumed = 1;
    return result;
}

u32 lex(){
    lex_line_number = 1;
    u8 c = 0;

    // Fill buffer
    while(code_buffer_length != CODE_BUFFER_CAPACITY){
        c = get();

        if(c == 0){
            break;
        }

        code_buffer[code_buffer_length++] = c;
    }

    if(code_buffer_length >= 8 && memcmp(code_buffer, "`stdlib\n", 8) == 0){
        // ---- memmove(code_buffer, &code_buffer[8], code_buffer_length - 8); ----
        for(u32 i = 0; i + 8 < code_buffer_length; i++){
            code_buffer[i] = code_buffer[i + 8];
        }
        code_buffer_length -= 8;
        
        // Compile as standard libary,
        // - Don't inject regular standard libary
        // - Print lexed construction once finished
        lex_peck_print_lexed_construction = true;
    } else {
        // Normal compilation
        inject_standard_library();
    }

    // Lex
    while(true){
        // (Re)-fill buffer
        while(code_buffer_length != CODE_BUFFER_CAPACITY && c != 0){
            c = get();

            if(c != 0){
                code_buffer[code_buffer_length++] = c;
            }
        }

        // Process one token
        LexedToken lexed = lex_main();
        Token token = lexed.token;

        if(token.kind != TOKEN_DONE){
            if(token.kind == TOKEN_ERROR) return 1;

            if(token.kind != TOKEN_NONE && token.kind != TOKEN_LINE_COMMENT && token.kind != TOKEN_MULTILINE_COMMENT){
                // Append created token
                if(num_tokens == TOKENS_CAPACITY){
                    printf("Out of memory: Too many tokens\n");
                    return 1;
                }
                tokens[num_tokens++] = token;
            } else {
                // Increase line number by skipped newlines
                for(u32 i = 0; i < lexed.consumed; i++){
                    if(code_buffer[i] == '\n') lex_line_number++;
                }
            }

            // If token is a word, remember content by injecting aux string
            if(token.kind == TOKEN_WORD){
                if(lexed.consumed == 4 && memcmp(code_buffer, "true", 4) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_TRUE;
                } else if(lexed.consumed == 5 && memcmp(code_buffer, "false", 5) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_FALSE;
                } else if(lexed.consumed == 2 && memcmp(code_buffer, "if", 2) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_IF;
                } else if(lexed.consumed == 4 && memcmp(code_buffer, "else", 4) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_ELSE;
                } else if(lexed.consumed == 5 && memcmp(code_buffer, "while", 5) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_WHILE;
                } else if(lexed.consumed == 2 && memcmp(code_buffer, "do", 2) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_DO;
                } else if(lexed.consumed == 7 && memcmp(code_buffer, "typedef", 7) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_TYPEDEF;
                } else if(lexed.consumed == 6 && memcmp(code_buffer, "struct", 6) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_STRUCT;
                } else if(lexed.consumed == 6 && memcmp(code_buffer, "return", 6) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_RETURN;
                } else if(lexed.consumed == 5 && memcmp(code_buffer, "break", 5) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_BREAK;
                } else if(lexed.consumed == 8 && memcmp(code_buffer, "continue", 8) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_CONTINUE;
                } else if(lexed.consumed == 3 && memcmp(code_buffer, "for", 3) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_FOR;
                } else if(lexed.consumed == 6 && memcmp(code_buffer, "sizeof", 6) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_SIZEOF;
                } else if(lexed.consumed == 6 && memcmp(code_buffer, "switch", 6) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_SWITCH;
                } else if(lexed.consumed == 4 && memcmp(code_buffer, "case", 4) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_CASE;
                } else if(lexed.consumed == 7 && memcmp(code_buffer, "default", 7) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_DEFAULT;
                } else if(lexed.consumed == 4 && memcmp(code_buffer, "enum", 4) == 0){
                    tokens[num_tokens - 1].kind = TOKEN_ENUM;
                } else {
                    tokens[num_tokens - 1].data = num_aux;

                    if(num_aux + lexed.consumed + 1 >= AUX_CAPACITY){
                        printf("Out of memory: Auxiliary memory used up\n");
                        return 1;
                    }

                    for(u32 i = 0; i < lexed.consumed; i++){
                        aux[num_aux++] = code_buffer[i];
                    }
                    aux[num_aux++] = '\0';
                }
            }

            // Advance code buffer
            for(u32 i = lexed.consumed; i < code_buffer_length; i++){
                code_buffer[i - lexed.consumed] = code_buffer[i];
            }
            code_buffer_length -= lexed.consumed;
        }
        
        if(token.kind == TOKEN_LINE_COMMENT){
            // Special code for line comments
            LexUnboundedResult result = lex_line_comment(c);
            if(result.error) return 1;
            c = result.new_c;
        } else if(token.kind == TOKEN_MULTILINE_COMMENT){
            // Special code for multi-line comments
            LexUnboundedResult result = lex_multiline_comment(c);
            if(result.error) return 1;
            c = result.new_c;
        } else if(token.kind == TOKEN_STRING){
            // Special code for lexing strings, so they are not limited to code buffer capacity
            LexUnboundedResult result = lex_string(c);
            if(result.error) return 1;
            c = result.new_c;
        }

        if(c == 0 && token.kind == TOKEN_DONE){
            break;
        }
    }

    return 0;
} 



LexedToken lex_character_literal(){
    LexedToken result = (LexedToken){
        .token = (Token){
            .line = u24_pack(lex_line_number),
            .kind = TOKEN_INT,
            .data = 0,
        },
        .consumed = 0,
    };

    if(code_buffer_length >= 4 && code_buffer[1] == '\\' && code_buffer[3] == '\''){
        switch(code_buffer[2]){
        case 't':
            result.token.data = '\t';
            break;
        case 'n':
            result.token.data = '\n';
            break;
        case '0':
            result.token.data = '\0';
            break;
        case '\\':
            result.token.data = '\\';
            break;
        case '\'':
            result.token.data = '\'';
            break;
        default:
            result.token.data = code_buffer[2];
        }

        result.consumed = 4;
    } else if(code_buffer_length >= 3 && code_buffer[2] == '\''){
        result.token.data = code_buffer[1];
        result.consumed = 3;
    }

    return result;
}



u32 lex_line_number;
u1 lex_peck_print_tokens;
u1 lex_peck_print_lexed_construction;



LexUnboundedResult lex_line_comment(u8 c){
    u32 read = 0;

    for(; read < code_buffer_length; read++){
        u8 comment_c = code_buffer[read];

        if(comment_c == '\n' || comment_c == 0){
            break;
        }
    }

    if(read == code_buffer_length){
        code_buffer_length = 0;

        do {
            c = get();
        } while(!(c == 0 || c == '\n'));

    } else {
        // Advance code buffer
        for(u32 i = read; i < code_buffer_length; i++){
            code_buffer[i - read] = code_buffer[i];
        }
        code_buffer_length -= read;
    }

    return (LexUnboundedResult){ .error = false, .new_c = c };
} 



LexUnboundedResult lex_multiline_comment(u8 c){
    u32 read = 0;
    u8 prev = '\0';
    u32 start_line = lex_line_number;
    u8 comment_c = '\0';

    for(; read < code_buffer_length; read++){
        comment_c = code_buffer[read];
        
        if(comment_c == 0){
            printf("\nerror on line %d: Multi-line comment never closed\n", start_line);
            return (LexUnboundedResult){ .error = true, .new_c = c };
        }

        if(comment_c == '\n'){
            lex_line_number++;
        }

        if(prev == '*' && comment_c == '/'){
            break;
        }

        prev = comment_c;
    }

    if(read < code_buffer_length){
        read++;

        // Advance code buffer
        for(u32 i = read; i < code_buffer_length; i++){
            code_buffer[i - read] = code_buffer[i];
        }
        code_buffer_length -= read;
    } else {
        // Not found in code buffer

        code_buffer_length = 0;
        c = get();

        while(!(c == 0 || (prev == '*' && c == '/'))){
            if(c == '\n'){
                lex_line_number++;
            }

            prev = c;
            c = get();
        }

        if(c == 0){
            printf("\nerror on line %d: Multi-line comment never closed\n", start_line);
            return (LexUnboundedResult){ .error = true, .new_c = c };
        }

        if(c == '/'){
            c = get();

            if(c == '\n'){
                lex_line_number++;
            }
        }
    }

    return (LexUnboundedResult){ .error = false, .new_c = c };
} 



LexUnboundedResult lex_string(u8 c){
    // TODO: Refactor to merge buffer-only and past-buffer cases

    tokens[num_tokens - 1].data = num_aux;

    u32 read = 0;
    u1 escape = false;

    for(; read < code_buffer_length; read++){
        u8 string_c = code_buffer[read];

        if(string_c == '\n'){
            lex_line_number++;
        }

        if(escape){
            escape = false;

            if(string_c == 'n'){
                string_c = '\n';
            } else if(string_c == 't'){
                string_c = '\t';
            }
        } else if(string_c == '"'){
            break;
        } else if(string_c == '\\'){
            escape = true;
            continue;
        }

        if(num_aux == AUX_CAPACITY){
            printf("Out of memory: Auxiliary memory used up\n");
            return (LexUnboundedResult){ .error = true };
        }

        aux[num_aux++] = string_c;
    }

    if(read == code_buffer_length){
        code_buffer_length = 0;

        while(true){
            c = get();

            if(c == 0){
                printf("error: Unterminated string\n");
                return (LexUnboundedResult){ .error = true };
            }

            if(c == '\n'){
                lex_line_number++;
            }

            if(escape){
                escape = false;

                if(c == 'n'){
                    c = '\n';
                } else if(c == 't'){
                    c = '\t';
                }
            } else if(c == '"'){
                c = get();
                break;
            } else if(c == '\\'){
                escape = true;
                continue;
            }

            if(num_aux == AUX_CAPACITY){
                printf("Out of memory: Auxiliary memory used up\n");
                return (LexUnboundedResult){ .error = true };
            }
            aux[num_aux++] = c;
        }
    } else {
        read += 1;
        for(u32 i = read; i < code_buffer_length; i++){
            code_buffer[i - read] = code_buffer[i];
        }
        code_buffer_length -= read;
    }

    if(num_aux == AUX_CAPACITY){
        printf("Out of memory: Auxiliary memory used up\n");
        return (LexUnboundedResult){ .error = true };
    }

    aux[num_aux++] = '\0';
    return (LexUnboundedResult){ .error = false, .new_c = c };
}




u0 main(){
    if(lex()) return 1;

    if(lex_peck_print_tokens){
        for(u32 i = 0; i < num_tokens; i++){
            token_print(tokens[i], true);
            printf("\n");
        }
        printf("\n");
    }

    if(lex_peck_print_lexed_construction){
        print_lexed_construction();
        return 0;
    }

    if(parse()) return 1;
    if(compute_typedef_sizes()) return 1;
    if(infer()) return 1;
    if(mark_recursive_functions()) return 1;

    /*
    for(u32 i = 0; i < num_typedefs; i++){
        typedef_print(typedefs[i]);
        printf("\n");
    }
    
    for(u32 i = 0; i < num_type_aliases; i++){
        type_alias_print(type_aliases[i]);
        printf("\n");
    }

    for(u32 i = 0; i < num_defines; i++){
        define_print(defines[i]);
        printf("\n");
    }

    for(u32 i = 0; i < num_functions; i++){
        function_print(functions[i]);
        printf("\n");
    }
    */

    printf("\nnum_functions = %d\n", num_functions);
    printf("\nnum_types = %d\n", num_types);
    printf("\nnum_expressions = %d\n", num_expressions);

    // Write

    // Find main function
    u32 main_function_index = FUNCTIONS_CAPACITY;
    for(u32 i = 0; i < FUNCTIONS_CAPACITY; i++){
        if(aux_cstr_equals_main(functions[i].name)){
            main_function_index = i;
            break;
        }
    }

    // Require main function
    if(main_function_index == FUNCTIONS_CAPACITY){
        printf("\nerror: No main function\n");
        return 1;
    }

    // Determine if recursion necessary
    if(functions[main_function_index].is_recursive){
        emit_settings.enable_stack = true;
    }

    // Emit globals
    u32 global_variables_cells = 0;
    for(u32 i = 0; i < num_globals; i++){
        u32 size = type_sizeof_or_max(globals[i].type, globals[i].line);
        if(size == -1) return 1;

        global_variables_cells += size;
    }

    // Set stack size
    emit_settings.stack_size = DEFAULT_STACK_SIZE;

    // Calculate stack footprint
    u32 stack_footprint = emit_settings.enable_stack ? emit_settings.stack_size : 0;

    // Allocate global variables and stack memory
    printf("%d>", global_variables_cells + stack_footprint);
    emit_settings.stack_begin = global_variables_cells;

    // Calculate starting cell index
    u32 start_cell_index = global_variables_cells + stack_footprint;
    emit_context.current_cell_index = start_cell_index;

    // Remember main function
    emit_settings.main_function_index = main_function_index;

    // If stack is disabled, just emit the `main` function
    if(!emit_settings.enable_stack){
        return function_emit(main_function_index, start_cell_index, start_cell_index);
    }

    // Otherwise, continue as normal and use stack
    emit_stack_driver_pre(main_function_index);
    if(emit_recursive_functions()) return 1;
    emit_stack_driver_post();
    return 0;
}



typedef struct {
    u32 from;
    u32 to;
} Arrow;

#define EXPRESSIONS_TO_PROCESS_CAPACITY MEMORY_MULTIPLIER * 1024

ErrorCode mark_recursive_functions(){
    Arrow arrows[ARROWS_CAPACITY];
    u32 num_arrows = 0;

    u32 expressions_to_process[EXPRESSIONS_TO_PROCESS_CAPACITY];
    u32 num_expressions_to_process = 0;

    // Create arrows for each function call
    for(u32 function_i = 0; function_i < num_functions; function_i++){
        Function function = functions[function_i];

        // Skip processing pre-known non-recursive functions
        if(!function.is_recursive) continue;

        u32 function_arrows_begin = num_arrows;
        u32 statements_start = function.begin + function.arity;
        u32 statements_end = function.begin + function.num_stmts;
        u32 statement_i = statements_start;

        // Find all calls made in this function
        while(true){
            Expression expression;

            // Get next expression to process
            if(num_expressions_to_process > 0){
                expression = expressions[expressions_to_process[--num_expressions_to_process]];
            } else if(statement_i < statements_end){
                expression = expressions[statements[statement_i++]];
            } else {
                break;
            }

            // Process expression to find all calls made
            switch(expression.kind){
            case EXPRESSION_CALL: {
                    u32 arity = operands[expression.ops + 1];

                    if(num_expressions_to_process + arity >= EXPRESSIONS_TO_PROCESS_CAPACITY){
                        printf("\nout of memory: Exceeded maximum number of expressions being processed during determination of recursive functions\n");
                        return 1;
                    }

                    for(u32 i = 0; i < arity; i++){
                        expressions_to_process[num_expressions_to_process++] = operands[expression.ops + 2 + i];
                    }

                    u32 to = find_function(operands[expression.ops]);

                    // If target function exists and is possibly recursive
                    if(to < FUNCTIONS_CAPACITY && functions[to].is_recursive){
                        if(num_arrows + 1 >= ARROWS_CAPACITY){
                            printf("\nout of memory: Exceeded maximum number of arrows during determination of recursive functions\n");
                            return 1;
                        }

                        // Check if arrow already exists
                        u1 already_exists = false;

                        for(u32 i = function_arrows_begin; i < num_arrows; i++){
                            if(arrows[i].to == to){
                                already_exists = true;
                                break;
                            }
                        }

                        // Add arrow if doesn't exist
                        if(!already_exists){
                            arrows[num_arrows++] = (Arrow){
                                .from = function_i,
                                .to = to,
                            };
                        }
                    }
                }
                break;
            case EXPRESSION_ASSIGN:
            case EXPRESSION_ADD:
            case EXPRESSION_SUBTRACT:
            case EXPRESSION_MULTIPLY:
            case EXPRESSION_DIVIDE:
            case EXPRESSION_MOD:
            case EXPRESSION_EQUALS:
            case EXPRESSION_NOT_EQUALS:
            case EXPRESSION_LESS_THAN:
            case EXPRESSION_GREATER_THAN:
            case EXPRESSION_LESS_THAN_OR_EQUAL:
            case EXPRESSION_GREATER_THAN_OR_EQUAL:
            case EXPRESSION_LSHIFT:
            case EXPRESSION_RSHIFT:
            case EXPRESSION_AND:
            case EXPRESSION_OR:
            case EXPRESSION_BIT_AND:
            case EXPRESSION_BIT_OR:
            case EXPRESSION_BIT_XOR:
            case EXPRESSION_INDEX:
                if(num_expressions_to_process + 2 >= EXPRESSIONS_TO_PROCESS_CAPACITY){
                    printf("\nout of memory: Exceeded maximum number of expressions being processed during determination of recursive functions\n");
                    return 1;
                }

                expressions_to_process[num_expressions_to_process++] = operands[expression.ops];
                expressions_to_process[num_expressions_to_process++] = operands[expression.ops + 1];
                break;
            case EXPRESSION_NOT:
            case EXPRESSION_BIT_COMPLEMENT:
            case EXPRESSION_NEGATE:
            case EXPRESSION_PRINT_ARRAY:
            case EXPRESSION_PRE_INCREMENT:
            case EXPRESSION_PRE_DECREMENT:
            case EXPRESSION_POST_INCREMENT:
            case EXPRESSION_POST_DECREMENT:
                if(num_expressions_to_process + 1 >= EXPRESSIONS_TO_PROCESS_CAPACITY){
                    printf("\nout of memory: Exceeded maximum number of expressions being processed during determination of recursive functions\n");
                    return 1;
                }

                expressions_to_process[num_expressions_to_process++] = expression.ops;
                break;
            case EXPRESSION_RETURN:
                if(num_expressions_to_process + 1 >= EXPRESSIONS_TO_PROCESS_CAPACITY){
                    printf("\nout of memory: Exceeded maximum number of expressions being processed during determination of recursive functions\n");
                    return 1;
                }

                if(expression.ops != EXPRESSIONS_CAPACITY){
                    expressions_to_process[num_expressions_to_process++] = expression.ops;
                }
                break;
            case EXPRESSION_TERNARY:
                if(num_expressions_to_process + 3 >= EXPRESSIONS_TO_PROCESS_CAPACITY){
                    printf("\nout of memory: Exceeded maximum number of expressions being processed during determination of recursive functions\n");
                    return 1;
                }

                expressions_to_process[num_expressions_to_process++] = operands[expression.ops];
                expressions_to_process[num_expressions_to_process++] = operands[expression.ops + 1];
                expressions_to_process[num_expressions_to_process++] = operands[expression.ops + 2];
                break;
            case EXPRESSION_CAST:
            case EXPRESSION_IF:
            case EXPRESSION_IF_ELSE:
            case EXPRESSION_WHILE:
            case EXPRESSION_DO_WHILE:
            case EXPRESSION_MEMBER:
                if(num_expressions_to_process + 1 >= EXPRESSIONS_TO_PROCESS_CAPACITY){
                    printf("\nout of memory: Exceeded maximum number of expressions being processed during determination of recursive functions\n");
                    return 1;
                }

                expressions_to_process[num_expressions_to_process++] = operands[expression.ops];
                break;
            case EXPRESSION_FOR:
                if(num_expressions_to_process + 1 >= EXPRESSIONS_TO_PROCESS_CAPACITY){
                    printf("\nout of memory: Exceeded maximum number of expressions being processed during determination of recursive functions\n");
                    return 1;
                }

                expressions_to_process[num_expressions_to_process++] = operands[expression.ops + 1];
                break;
            default:
                /* ignore */
                break;
            }

            // End while
        }

        // End for
    }

    // Done creating arrows

    /*
    // Try printing arrows
    for(u32 i = 0; i < num_arrows; i++){
        printf("\narrow: %d -> %d\n", arrows[i].from, arrows[i].to);
        printf("\n aka ");
        print_aux_cstr(functions[arrows[i].from].name);
        printf(" -> ");
        print_aux_cstr(functions[arrows[i].to].name);
        printf("\n");
    }
    */

    u16 outgoing[FUNCTIONS_CAPACITY] = {0};

    // Tally outgoing arrows for each function
    for(u32 i = 0; i < num_arrows; i++){
        outgoing[arrows[i].from]++;
    }

    // Eliminate each function that has zero remaining outgoing arrows (marking them as non-recursive),
    // until we can no longer do so.
    // When we remove a function, all functions that called it will have their
    // Outgoing arrows decremented.
    // The remaining group of functions require recursion, and will retain their 'is_recursive' mark.

    // We assume that all functions that might be recursive as pre-marked as recursive.

    u1 progress = true;

    while(progress){
        progress = false;

        for(u32 function_i = 0; function_i < num_functions; function_i++){
            if(functions[function_i].is_recursive && outgoing[function_i] == 0){
                // Proved this function doesn't need recursion

                progress = true;

                // Mark non-recursive
                functions[function_i].is_recursive = false;

                // Remove edge from functions who use this function
                for(u32 i = 0; i < num_arrows; i++){
                    if(arrows[i].to == function_i){
                        outgoing[arrows[i].from]--;
                    }
                }

                break;
            }
        }
    }

    /*
    // Try print which functions are recursive
    for(u32 i = 0; i < num_functions; i++){
        Function function = functions[i];

        printf("\n");
        print_aux_cstr(function.name);
        printf(" is ");

        if(function.is_recursive){
            printf("recursive\n");
        } else {
            printf("not recursive\n");
        }
    }
    */

    return 0;
}



u32 parse_function_body(Function function){
    // { ... }
    //       ^ ending token index
    //   ^  starting token index

    while(parse_i < num_tokens && !is_token(TOKEN_END)){
        if(parse_statement()) return 1;
    }

    return (u32) had_parse_error;
}

ErrorCode parse_function(u32 symbol_name, u32 symbol_type, u24 line_number){
    if(!eat_token(TOKEN_OPEN)){
        printf("error on line %d: Expected '(' after function name\n", current_line());
        instead_got();
        return 1;
    }

    u32 begin = num_statements;

    while(!is_token(TOKEN_CLOSE)){
        u24 line_number = current_line_packed();

        Type type = parse_type();
        if(had_parse_error) return 1;

        if(!is_token(TOKEN_WORD)){
            printf("error on line %d: Expected parameter name after parameter type\n", current_line());
            stop_parsing();
            return 1;
        }

        u32 parameter_name = eat_word();

        if(is_token(TOKEN_OPEN_BRACKET)){
            type.dimensions = parse_dimensions(dimensions[type.dimensions]);
            if(type.dimensions >= UNIQUE_DIMENSIONS_CAPACITY) return 1;
        }

        u32 parameter_type = add_type(type);
        if(parameter_type == TYPES_CAPACITY) return 1;

        u32 ops = add_operands2(parameter_type, parameter_name);
        if(ops >= OPERANDS_CAPACITY) return 1;

        if(add_statement_from_new((Expression){
            .kind = EXPRESSION_DECLARE,
            .line = line_number,
            .ops = ops,
        }) >= STATEMENTS_CAPACITY){
            stop_parsing();
            return 1;
        }

        if(!eat_token(TOKEN_NEXT)){
            if(!is_token(TOKEN_CLOSE)){
                printf("error on line %d: Expected ',' or ')' after function parameter\n", current_line());
                stop_parsing();
                return 1;
            }
        }
    }

    parse_i++;

    if(eat_token(TOKEN_SEMICOLON)){
        return 0;
    }

    if(!eat_token(TOKEN_BEGIN)){
        printf("error on line %d: Expected '{' after parameter list for function\n", current_line());
        instead_got();
        return 1;
    }

    Function function = (Function){
        .name = symbol_name,
        .arity = num_statements - begin,
        .begin = begin,
        .num_stmts = 0,
        .return_type = symbol_type,
        .is_recursive = true, // assume recursive until we prove otherwise
        .line = line_number,
    };

    if(parse_function_body(function)){
        return 1;
    }

    function.num_stmts = num_statements - begin;

    if(add_function(function) >= FUNCTIONS_CAPACITY){
        return 1;
    }

    if(!eat_token(TOKEN_END)){
        printf("error on line %d: Expected '}' after function body\n", current_line());
        instead_got();
        return 1;
    }

    return 0;
}

u32 parse(){
    parse_i = 0;
    had_parse_error = false;
    parse_trailing_semicolon = true;
    
    if(add_builtin_types()) return 1;
    if(add_builtin_functions()) return 1;

    while(parse_i < num_tokens){
        u24 line_number = tokens[parse_i].line;

        if(eat_token(TOKEN_TYPEDEF)){
            if(parse_typedef()) return 1;
            continue;
        }

        if(eat_token(TOKEN_HASH)){
            if(parse_macro()) return 1;
            continue;
        }

        // Parse type
        Type type = parse_type();
        if(had_parse_error) return 1;

        if(!is_token(TOKEN_WORD)){
            printf("error on line %d: Expected function name after type\n", current_line());
            instead_got();
            return 1;
        }

        u32 symbol_name = eat_word();

        // Global variable
        if(is_token(TOKEN_SEMICOLON) || is_token(TOKEN_OPEN_BRACKET) || is_token(TOKEN_ASSIGN)){
            type.dimensions = parse_dimensions(dimensions[type.dimensions]);
            if(type.dimensions >= UNIQUE_DIMENSIONS_CAPACITY) return 1;

            u32 symbol_type = add_type(type);
            if(symbol_type == TYPES_CAPACITY) return 1;

            u32 initializer = EXPRESSIONS_CAPACITY;

            if(eat_token(TOKEN_ASSIGN)){
                Expression initial = parse_expression();
                if(had_parse_error) return 1;

                initializer = add_expression(initial);
                if(initializer >= EXPRESSIONS_CAPACITY) return 1;
            }

            if(!eat_token(TOKEN_SEMICOLON)){
                printf("error on line %d: Expected ';' after global variable\n", current_line());
                instead_got();
                return 1;
            }

            u32 global = add_global((Global){
                .name = symbol_name,
                .type = symbol_type,
                .line = line_number,
                .initializer = initializer,
            });
            if(global >= GLOBALS_CAPACITY) return 1;
        } else {
            u32 symbol_type = add_type(type);
            if(symbol_type == TYPES_CAPACITY) return 1;

            // Function
            if(parse_function(symbol_name, symbol_type, line_number)){
                return 1;
            }
        }
    }

    return (u32) had_parse_error;
}



u32 parse_i;
u1 had_parse_error;
u1 parse_trailing_semicolon;

u0 instead_got(){
    if(parse_i < num_tokens){
        printf("  Instead got: `");
        token_print(tokens[parse_i], false);
        printf("`\n");
    }
}

u0 stop_parsing(){
    had_parse_error = true;
    parse_i = num_tokens;
}

u1 is_token(TokenKind kind){
    return parse_i < num_tokens && tokens[parse_i].kind == kind;
}

u32 current_line(){
    if(parse_i < num_tokens){
        return u24_unpack(tokens[parse_i].line);
    } else if(parse_i == num_tokens && num_tokens > 0){
        return u24_unpack(tokens[parse_i - 1].line);
    } else {
        return 0;
    }
}

u24 current_line_packed(){
    if(parse_i < num_tokens){
        return tokens[parse_i].line;
    } else if(parse_i == num_tokens && num_tokens > 0){
        return tokens[parse_i - 1].line;
    } else {
        return u24_pack(0);
    }
}

u32 eat_word(){
    // Expects `is_token(TOKEN_WORD)` to be true
    return tokens[parse_i++].data;
}

u32 eat_int(){
    // Expects `is_token(TOKEN_INT)` to be true
    return tokens[parse_i++].data;
}

u32 eat_string(){
    // Expects `is_token(TOKEN_STRING)` to be true
    return tokens[parse_i++].data;
}

u1 eat_token(TokenKind kind){
    if(parse_i < num_tokens && tokens[parse_i].kind == kind){
        parse_i++;
        return true;
    } else {
        return false;
    }
}



u32 parse_add_dimensions(u32 type_dimensions[4]){
    u32 dims = add_dimensions(type_dimensions);

    if(dims >= UNIQUE_DIMENSIONS_CAPACITY){
        printf("\nerror on line %d: Maximum number of unique dimension pairs exceeded. Use fewer or reconfigure your compiler.\n", current_line());
        stop_parsing();
        return UNIQUE_DIMENSIONS_CAPACITY;
    }
    
    return dims;
}

u32 parse_dimensions(u32 start_type_dimensions[4]){
    // Type dimensions is {0, 0, 0, 0} to start,
    // Unless some dimensions for the type already exist.

    u32 type_dimensions[4];
    memcpy(type_dimensions, start_type_dimensions, sizeof(u32) * 4);

    u32 next_dim = 0;

    // Find next dimension for type dimensions
    while(next_dim < UNIQUE_DIMENSIONS_CAPACITY && type_dimensions[next_dim] != 0){
        next_dim++;
    }

    while(eat_token(TOKEN_OPEN_BRACKET)){
        if(next_dim == 4){
            printf("\nerror on line %d: Cannot nest array dimensions more than 4 deep\n", current_line());
            stop_parsing();
            return UNIQUE_DIMENSIONS_CAPACITY;
        }

        u32 dim;

        if(is_token(TOKEN_INT)){
            dim = eat_int();
        } else if(is_token(TOKEN_WORD)){
            u32 definition_name = eat_word();

            u32 resolved = try_resolve_define(definition_name, false);
            if(resolved >= EXPRESSIONS_CAPACITY){
                printf("\nerror on line %d: Undeclared compile-time definition '", current_line());
                print_aux_cstr(definition_name);
                printf("'\n");
                stop_parsing();
                return UNIQUE_DIMENSIONS_CAPACITY;
            }

            Expression expression = expressions[resolved];
            if(!is_expression_kind_int_like(expression.kind)){
                printf("\nerror on line %d: Cannot use non-integer from compile-time definition '", current_line());
                print_aux_cstr(definition_name);
                printf("' as type dimension (is %d", resolved);
                printf(")\n");
                stop_parsing();
                return UNIQUE_DIMENSIONS_CAPACITY;
            }

            dim = expression.ops;
        } else {
            printf("\nerror on line %d: Expected number for dimension of type\n", current_line());
            instead_got();
            stop_parsing();
            return UNIQUE_DIMENSIONS_CAPACITY;
        }

        if(dim == 0){
            printf("\nerror on line %d: Cannot have array dimension of 0\n", current_line());
            stop_parsing();
            return UNIQUE_DIMENSIONS_CAPACITY;
        }

        type_dimensions[next_dim++] = dim;

        if(!eat_token(TOKEN_CLOSE_BRACKET)){
            printf("\nerror on line %d: Expected ']' after dimension in type\n", current_line());
            instead_got();
            stop_parsing();
            return UNIQUE_DIMENSIONS_CAPACITY;
        }
    }

    if(next_dim == 0){
        return 0;
    }

    return parse_add_dimensions(type_dimensions);
}



Expression parse_operator_expression(u8 precedence, Expression lhs);
Expression parse_unary_prefix(TokenKind operator, u24 line_number);
Expression parse_unary_postfix(Expression expression);
Expression parse_primary_base_expression();
Expression parse_primary_post_expression(Expression expression);
Expression parse_array_index_expression(Expression array, u24 line_number);
Expression parse_member_expression(Expression array, u24 line_number);

Expression parse_primary_expression(){
    Expression expression = parse_primary_base_expression();
    if(had_parse_error) return (Expression){0};

    expression = parse_primary_post_expression(expression);
    if(had_parse_error) return (Expression){0};

    return expression;
}

Expression parse_primary_post_expression(Expression lhs){
    while(true){
        u24 line_number = tokens[parse_i].line;

        switch(tokens[parse_i].kind){
        case TOKEN_OPEN_BRACKET:
            lhs = parse_array_index_expression(lhs, line_number);
            break;
        case TOKEN_MEMBER:
            lhs = parse_member_expression(lhs, line_number);
            break;
        case TOKEN_INCREMENT:
        case TOKEN_DECREMENT:
            lhs = parse_unary_postfix(lhs);
            break;
        default:
            return lhs;
        }
    }

    return lhs;
}

Expression parse_array_index_expression(Expression array, u24 line_number){
    // Skip over '[' operator
    parse_i++;

    Expression index = parse_expression();
    if(had_parse_error) return array;

    if(!eat_token(TOKEN_CLOSE_BRACKET)){
        printf("\nerror on line %d: Expected ']' after index expression\n", current_line());
        instead_got();
        stop_parsing();
        return array;
    }

    u32 a = add_expression(array);
    if(a >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return array;
    }

    u32 b = add_expression(index);
    if(b >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return array;
    }

    u32 ops = add_operands2(a, b);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return array;
    }

    return (Expression){
        .kind = EXPRESSION_INDEX,
        .line = line_number,
        .ops = ops,
    };
}

Expression parse_member_expression(Expression subject_expression, u24 line_number){
    // Skip over '.' operator
    parse_i++;

    u32 subject = add_expression(subject_expression);
    if(subject >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return subject_expression;
    }

    if(!is_token(TOKEN_WORD)){
        printf("\nerror on line %d: Expected member name after '.'\n", u24_unpack(line_number));
        instead_got();
        stop_parsing();
        return subject_expression;
    }

    u32 member_name = eat_word();

    u32 ops = add_operands2(subject, member_name);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return subject_expression;
    }

    return (Expression){
        .kind = EXPRESSION_MEMBER,
        .line = line_number,
        .ops = ops,
    };
}


Expression parse_expression_print(u24 line_number){
    Expression expression = (Expression){0};

    if(is_token(TOKEN_STRING)){
        expression = (Expression){
            .kind = EXPRESSION_PRINT_LITERAL,
            .line = line_number,
            .ops = eat_string(),
        };
    } else {
        Expression array = parse_expression();
        if(had_parse_error) return expression;

        u32 array_value = add_expression(array);
        if(array_value >= EXPRESSIONS_CAPACITY){
            stop_parsing();
            return expression;
        }
        
        expression = (Expression){
            .kind = EXPRESSION_PRINT_ARRAY,
            .line = line_number,
            .ops = array_value,
        };
    }

    if(!eat_token(TOKEN_CLOSE)){
        printf("\nerror on line %d: Expected ')' after expression in print statement\n", current_line());
        instead_got();
        stop_parsing();
        return expression;
    }

    return expression;
}

Expression parse_expression_panicloop(u24 line_number){
    if(!eat_token(TOKEN_CLOSE)){
        printf("\nerror on line %d: Expected ')' after expression in print statement\n", current_line());
        instead_got();
        stop_parsing();
        return (Expression){0};
    }

    return (Expression){
        .kind = EXPRESSION_PANICLOOP,
        .line = line_number,
        .ops = 0,
    };
}

Expression parse_expression_call(u32 name, u24 line_number){
    Expression expression = (Expression){
        .kind = EXPRESSION_CALL,
        .line = line_number,
        .ops = 0,
    };

    if(aux_cstr_equals_printf(name)){
        expression.kind = EXPRESSION_PRINTF;
    } else if(aux_cstr_equals_memcmp(name)){
        expression.kind = EXPRESSION_MEMCMP;
    } else if(aux_cstr_equals_memcpy(name)){
        expression.kind = EXPRESSION_MEMCPY;
    }

    u32 arguments[ARITY_CAPACITY];
    u8 arity = 0;

    while(!is_token(TOKEN_CLOSE)){
        Expression argument_expression = parse_expression();
        if(had_parse_error) return expression;

        u32 argument = add_expression(argument_expression);
        if(argument >= EXPRESSIONS_CAPACITY){
            stop_parsing();
            return expression;
        }

        if(arity >= ARITY_CAPACITY){
            printf("\nerror on line %d: Exceeded maximum number of arguments to function call (limit is %d)\n", current_line(), ARITY_CAPACITY);
            stop_parsing();
            return expression;
        }

        arguments[arity++] = argument;

        if(!eat_token(TOKEN_NEXT)){
            if(!is_token(TOKEN_CLOSE)){
                printf("\nerror on line %d: Expected ',' or ')' after argument in call\n", current_line());
                instead_got();
                stop_parsing();
                return expression;
            }
        }
    }

    if(!eat_token(TOKEN_CLOSE)){
        printf("\nerror on line %d: Expected ')' after argument in call\n", current_line());
        instead_got();
        stop_parsing();
        return expression;
    }

    /* Operands layout */
    /* { name, arity, arg1, arg2, ..., argN } */
    u32 ops = add_operand(name);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return expression;
    }

    u32 arity_location = add_operand(arity);
    if(arity_location >= OPERANDS_CAPACITY){
        stop_parsing();
        return expression;
    }

    for(u8 i = 0; i < arity; i++){
        if(add_operand(arguments[i]) >= OPERANDS_CAPACITY){
            stop_parsing();
            return expression;
        }
    }

    expression.ops = ops;
    return expression;
}

Expression parse_expression_sizeof(u24 line_number){
    // sizeof
    //        ^

    if(eat_token(TOKEN_OPEN)){
        Type type = parse_type();
        if(had_parse_error) return (Expression){0};

        if(!eat_token(TOKEN_CLOSE)){
            printf("\nerror on line %d: Expected ')' after type in 'sizeof'\n", current_line());
            instead_got();
            stop_parsing();
            return (Expression){0};
        }

        u32 type_index = add_type(type);
        if(type_index == TYPES_CAPACITY){
            stop_parsing();
            return (Expression){0};
        }

        return (Expression){
            .kind = EXPRESSION_SIZEOF_TYPE,
            .line = line_number,
            .ops = type_index,
        };
    } else {
        Expression target_expression = parse_primary_expression();
        if(had_parse_error) return (Expression){0};

        u32 target = add_expression(target_expression);
        if(target >= EXPRESSIONS_CAPACITY){
            stop_parsing();
            return target_expression;
        }

        return (Expression){
            .kind = EXPRESSION_SIZEOF_VALUE,
            .line = line_number,
            .ops = target,
        };
    }
}

u32 create_field_initializer(u32 field_name, u32 field_value, u24 line_number){
    // Creates and expression for `.field_name = field_value`

    u32 ops = add_operands2(field_name, field_value);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return EXPRESSIONS_CAPACITY;
    }

    Expression member_expression = (Expression){
        .kind = EXPRESSION_FIELD_INITIALIZER,
        .ops = ops,
        .line = line_number,
    };

    u32 member = add_expression(member_expression);
    if(member >= EXPRESSIONS_CAPACITY){
        stop_parsing();
    }

    return member;
}

Expression parse_struct_initializer(Type type, u24 line_number){
    // (Type) { 
    //          ^

    u32 length = 0;
    u32 temporary_storage[MAX_INITIALIZER_LIST_LENGTH];

    u1 skip = false;

    if(is_token(TOKEN_INT)){
        u32 value = eat_int();

        if(value == 0 && eat_token(TOKEN_END)){
            skip = true;
        } else {
            printf("\nerror on line %d: Expected '{0}' for zero-initializer\n", u24_unpack(line_number));
            stop_parsing();
            return (Expression){0};
        }
    }

    if(!skip) while(!eat_token(TOKEN_END)){
        if(!eat_token(TOKEN_MEMBER)){
            printf("\nerror on line %d: Expected '.' for field of struct literal\n", u24_unpack(line_number));
            stop_parsing();
            return (Expression){0};
        }

        if(!is_token(TOKEN_WORD)){
            printf("\nerror on line %d: Expected name of field after '.' in struct literal\n", u24_unpack(line_number));
            stop_parsing();
            return (Expression){0};
        }

        u32 field = eat_word();
        u24 line_number = current_line_packed();

        if(!eat_token(TOKEN_ASSIGN)){
            printf("\nerror on line %d: Expected '=' after name of field in struct literal\n", u24_unpack(line_number));
            stop_parsing();
            return (Expression){0};
        }

        Expression field_value_expression = parse_expression();
        if(had_parse_error) return (Expression){0};

        u32 field_value = add_expression(field_value_expression);
        if(field_value >= EXPRESSIONS_CAPACITY){
            stop_parsing();
            return (Expression){0};
        }

        if(length + 1 >= MAX_INITIALIZER_LIST_LENGTH){
            printf("\nerror on line %d: Exceeded maximum struct initializer length\n", u24_unpack(line_number));
            stop_parsing();
            return (Expression){0};
        }

        u32 member = create_field_initializer(field, field_value, line_number);
        if(member >= EXPRESSIONS_CAPACITY) return (Expression){0};

        temporary_storage[length++] = member;

        if(!eat_token(TOKEN_NEXT)){
            if(!is_token(TOKEN_END)){
                printf("\nerror on line %d: Expected '}' or ',' after item of array initializer list\n", u24_unpack(line_number));
                instead_got();
                stop_parsing();
                return (Expression){0};
            }
        }
    }

    if(num_operands + length + 2 >= OPERANDS_CAPACITY){
        printf("\nOut of memory: Exceeded maximum number of total expression operands\n");
        stop_parsing();
        return (Expression){0};
    }

    u32 type_index = add_type(type);
    if(type_index == TYPES_CAPACITY){
        stop_parsing();
        return (Expression){0};
    }

    u32 ops = num_operands;
    operands[num_operands++] = type_index;
    operands[num_operands++] = length;

    for(u32 i = 0; i < length; i++){
        operands[num_operands++] = temporary_storage[i];
    }

    return (Expression){
        .kind = EXPRESSION_STRUCT_INITIALIZER,
        .ops = ops,
        .line = line_number,
    };
}

Expression parse_array_initializer_expression(u24 line_number){
    // {
    //   ^

    u32 length = 0;
    u32 temporary_storage[MAX_INITIALIZER_LIST_LENGTH];

    while(!eat_token(TOKEN_END)){
        Expression item_expression = parse_expression();
        if(had_parse_error) return (Expression){0};

        u32 item = add_expression(item_expression);
        if(item >= EXPRESSIONS_CAPACITY){
            stop_parsing();
            return (Expression){0};
        }

        if(length + 1 >= MAX_INITIALIZER_LIST_LENGTH){
            printf("\nerror on line %d: Exceeded maximum array initializer length\n", u24_unpack(line_number));
            stop_parsing();
            return (Expression){0};
        }

        temporary_storage[length++] = item;

        if(!eat_token(TOKEN_NEXT)){
            if(!is_token(TOKEN_END)){
                printf("\nerror on line %d: Expected '}' or ',' after item of array initializer list\n", u24_unpack(line_number));
                instead_got();
                stop_parsing();
                return (Expression){0};
            }
        }
    }

    if(num_operands + length + 1 >= OPERANDS_CAPACITY){
        printf("\nOut of memory: Exceeded maximum number of total expression operands\n");
        stop_parsing();
        return (Expression){0};
    }

    u32 ops = num_operands;
    operands[num_operands++] = length;

    for(u32 i = 0; i < length; i++){
        operands[num_operands++] = temporary_storage[i];
    }

    return (Expression){
        .kind = EXPRESSION_ARRAY_INITIALIZER,
        .ops = ops,
        .line = line_number,
    };
}

Expression parse_primary_base_expression(){
    u24 line_number = current_line_packed();

    if(is_token(TOKEN_WORD)){
        u32 name = eat_word();

        if(eat_token(TOKEN_OPEN)){
            if(aux_cstr_equals_print(name)){
                // Print call?
                return parse_expression_print(line_number);
            }

            if(aux_cstr_equals_panicloop(name)){
                return parse_expression_panicloop(line_number);
            }

            // Regular call
            return parse_expression_call(name, line_number);
        }

        // Resolve '#define' constants
        u32 resolved = try_resolve_define(name, true);
        if(resolved < EXPRESSIONS_CAPACITY){
            return expressions[resolved];
        }

        // Else, normal variable
        return (Expression){
            .kind = EXPRESSION_VARIABLE,
            .line = line_number,
            .ops = name,
        };
    }

    if(is_token(TOKEN_INT)){
        return (Expression){
            .kind = EXPRESSION_INT,
            .line = line_number,
            .ops = eat_int(),
        };
    }

    if(eat_token(TOKEN_TRUE)){
        return (Expression){
            .kind = EXPRESSION_U1,
            .line = line_number,
            .ops = 1,
        };
    }

    if(eat_token(TOKEN_FALSE)){
        return (Expression){
            .kind = EXPRESSION_U1,
            .line = line_number,
            .ops = 0,
        };
    }

    if(is_token(TOKEN_STRING)){
        return (Expression){
            .kind = EXPRESSION_STRING,
            .line = line_number,
            .ops = eat_string(),
        };
    }

    if(eat_token(TOKEN_OPEN)){
        if(is_type_followed_by(TOKEN_CLOSE)){
            // Cast

            Type type = parse_type();
            if(had_parse_error){
                printf("\nerror on line %d: Expected type for cast\n", current_line());
                return (Expression){0};
            }

            if(!eat_token(TOKEN_CLOSE)){
                printf("\nerror on line %d: Expected ')' to close cast\n", current_line());
                instead_got();
                stop_parsing();
                return (Expression){0};
            }

            if(eat_token(TOKEN_BEGIN)){
                return parse_struct_initializer(type, line_number);
            } else {
                Expression expression = parse_primary_expression();
                if(had_parse_error) return (Expression){0};

                u32 type_index = add_type(type);
                if(type_index == TYPES_CAPACITY){
                    stop_parsing();
                    return (Expression){0};
                }

                u32 expression_index = add_expression(expression);
                if(expression_index >= EXPRESSIONS_CAPACITY){
                    stop_parsing();
                    return (Expression){0};
                }

                u32 ops = add_operands2(type_index, expression_index);
                if(ops >= OPERANDS_CAPACITY){
                    stop_parsing();
                    return (Expression){0};
                }

                return (Expression){
                    .kind = EXPRESSION_CAST,
                    .line = line_number,
                    .ops = ops,
                };
            }
        }

        // Normal nested expression
        Expression expression = parse_expression();
        if(had_parse_error) return (Expression){0};

        if(!eat_token(TOKEN_CLOSE)){
            printf("\nerror on line %d: Expected ')' to close cast\n", current_line());
            instead_got();
            stop_parsing();
            return (Expression){0};
        }

        return expression;
    }

    if(eat_token(TOKEN_BEGIN)){
        return parse_array_initializer_expression(line_number);
    }

    if( eat_token(TOKEN_SUBTRACT)
     || eat_token(TOKEN_NOT)
     || eat_token(TOKEN_BIT_COMPLEMENT)
     || eat_token(TOKEN_INCREMENT)
     || eat_token(TOKEN_DECREMENT)
    ){
        return parse_unary_prefix(tokens[parse_i - 1].kind, line_number);
    }

    if(eat_token(TOKEN_SIZEOF)){
        return parse_expression_sizeof(line_number);
    }
    
    printf("\nerror on line %d: Expected expression\n", current_line());
    instead_got();
    stop_parsing();
    return (Expression){0};
}

u1 is_terminating_token(TokenKind token_kind){
    switch(token_kind){
    case TOKEN_NEXT:
    case TOKEN_CLOSE:
    case TOKEN_SEMICOLON:
    case TOKEN_CLOSE_BRACKET:
    case TOKEN_COLON:
        return true;
    default:
        return false;
    }
}

u8 parse_get_precedence(u32 token_kind){
    switch(token_kind){
    case TOKEN_OPEN:
    case TOKEN_OPEN_BRACKET:
    case TOKEN_MEMBER:
        return 16;
    case TOKEN_INCREMENT:
    case TOKEN_DECREMENT:
        return 15;
    case TOKEN_NOT:
    case TOKEN_BIT_COMPLEMENT:
        return 14;
    case TOKEN_MULTIPLY:
    case TOKEN_DIVIDE:
    case TOKEN_MOD:
        return 12;
    case TOKEN_ADD:
    case TOKEN_SUBTRACT:
        return 11;
    case TOKEN_LSHIFT:
    case TOKEN_RSHIFT:
        return 10;
    case TOKEN_LESS_THAN:
    case TOKEN_GREATER_THAN:
    case TOKEN_LESS_THAN_OR_EQUAL:
    case TOKEN_GREATER_THAN_OR_EQUAL:
        return 9;
    case TOKEN_EQUALS:
    case TOKEN_NOT_EQUALS:
        return 8;
    case TOKEN_BIT_AND:
        return 7;
    case TOKEN_BIT_XOR:
        return 6;
    case TOKEN_BIT_OR:
        return 5;
    case TOKEN_AND:
        return 4;
    case TOKEN_OR:
        return 3;
    case TOKEN_TERNARY:
        return 2;
    case TOKEN_ASSIGN:
    case TOKEN_ADD_ASSIGN:
    case TOKEN_SUBTRACT_ASSIGN:
    case TOKEN_MULTIPLY_ASSIGN:
    case TOKEN_DIVIDE_ASSIGN:
    case TOKEN_MOD_ASSIGN:
    case TOKEN_LSHIFT_ASSIGN:
    case TOKEN_RSHIFT_ASSIGN:
    case TOKEN_BIT_AND_ASSIGN:
    case TOKEN_BIT_OR_ASSIGN:
    case TOKEN_BIT_XOR_ASSIGN:
        return 1;
    default:
        return 0;
    }
}

u1 is_right_associative(TokenKind operator){
    switch(operator){
    case TOKEN_ASSIGN:
    case TOKEN_TERNARY:
    case TOKEN_COLON:
        return true;
    default:
        return false;
    }
}

Expression parse_rhs(u32 operator_precedence){
    // Returns right hand side of expression

    // Skip over operator token
    if(++parse_i >= num_tokens){
        printf("\nerror on line %d: Expected right hand side of expression\n", current_line());
        instead_got();
        stop_parsing();
        return (Expression){0};
    }

    Expression rhs = parse_primary_expression();
    if(had_parse_error) return rhs;

    TokenKind next_operator = tokens[parse_i].kind;
    u8 next_precedence = parse_get_precedence(next_operator);

    if(!(next_precedence + is_right_associative(next_operator) < operator_precedence)){
        rhs = parse_operator_expression(operator_precedence + 1, rhs);
        if(had_parse_error) return rhs;
    }

    return rhs;
}

Expression parse_math(
    Expression lhs,
    TokenKind operator,
    u24 line_number,
    u8 operator_precedence
){
    Expression rhs = parse_rhs(operator_precedence);
    if(had_parse_error) return lhs;

    u32 a = add_expression(lhs);
    if(a >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return lhs;
    }

    u32 b = add_expression(rhs);
    if(b >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return lhs;
    }

    u32 ops = add_operands2(a, b);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return lhs;
    }

    ExpressionKind expression_kind = expression_kind_binary_from_token_kind(operator);
    if(expression_kind == EXPRESSION_NONE){
        printf("\nerror on line %d: Could not get math expression kind from token kind\n", u24_unpack(line_number));
        stop_parsing();
        return lhs;
    }

    return (Expression){
        .kind = expression_kind,
        .line = line_number,
        .ops = ops,
    };
}

Expression parse_unary_prefix(
    TokenKind operator,
    u24 line_number
){
    Expression expression = parse_primary_expression();
    if(had_parse_error) return (Expression){0};

    u32 value = add_expression(expression);
    if(value >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return (Expression){0};
    }

    ExpressionKind expression_kind = expression_kind_unary_prefix_from_token_kind(operator);
    if(expression_kind == EXPRESSION_NONE){
        printf("\nerror on line %d: Could not get unary prefix expression kind from token kind\n", u24_unpack(line_number));
        stop_parsing();
        return (Expression){0};
    }

    return (Expression){
        .kind = expression_kind,
        .line = line_number,
        .ops = value,
    };
}

Expression parse_unary_postfix(Expression expression){
    TokenKind operator = tokens[parse_i++].kind;

    u32 value = add_expression(expression);
    if(value >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return (Expression){0};
    }

    ExpressionKind expression_kind = expression_kind_unary_postfix_from_token_kind(operator);
    if(expression_kind == EXPRESSION_NONE){
        printf("\nerror on line %d: Could not get unary postfix expression kind from token kind\n", u24_unpack(expression.line));
        stop_parsing();
        return (Expression){0};
    }

    return (Expression){
        .kind = expression_kind,
        .line = expression.line,
        .ops = value,
    };
}

Expression parse_ternary(Expression condition_expression, u24 line){
    u32 condition = add_expression(condition_expression);
    if(condition >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return (Expression){0};
    }

    if(!eat_token(TOKEN_TERNARY)){
        printf("\nerror on line %d: Expected '?' after condition of ternary expression\n", current_line());
        instead_got();
        stop_parsing();
        return (Expression){0};
    }

    Expression when_true_expression = parse_expression();
    if(had_parse_error) return (Expression){0};

    if(!eat_token(TOKEN_COLON)){
        printf("\nerror on line %d: Expected ':' after true branch of ternary expression\n", current_line());
        instead_got();
        stop_parsing();
        return (Expression){0};
    }
    
    Expression when_false_expression = parse_expression();
    if(had_parse_error) return (Expression){0};

    u32 when_true = add_expression(when_true_expression);
    if(when_true >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return condition_expression;
    }

    u32 when_false = add_expression(when_false_expression);
    if(when_false >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return condition_expression;
    }

    u32 ops = add_operands3(condition, when_true, when_false);

    return (Expression){
        .kind = EXPRESSION_TERNARY,
        .line = line,
        .ops = ops,
    };
}

Expression parse_operator_assign(Expression lhs, TokenKind operator, u24 line_number, u8 operator_precedence){
    Expression rhs = parse_rhs(operator_precedence);
    if(had_parse_error) return lhs;

    u32 a = add_expression(lhs);
    if(a >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return lhs;
    }

    u32 b = add_expression(rhs);
    if(b >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return lhs;
    }

    u32 math_ops = add_operands2(a, b);
    if(math_ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return lhs;
    }

    ExpressionKind expression_kind = expression_kind_binary_from_assignment_token_kind(operator);
    if(expression_kind == EXPRESSION_NONE){
        printf("\nerror on line %d: Could not get math expression kind from token kind\n", u24_unpack(line_number));
        stop_parsing();
        return lhs;
    }

    Expression math_expression = (Expression){
        .kind = expression_kind,
        .line = line_number,
        .ops = math_ops,
    };

    u32 math = add_expression(math_expression);
    if(math >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return math_expression;
    }

    u32 ops = add_operands2(a, math);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return lhs;
    }

    return (Expression){
        .kind = EXPRESSION_ASSIGN,
        .ops = ops,
        .line = line_number,
    };
}

Expression parse_operator_expression(u8 precedence, Expression lhs){
    while(true){
        if(parse_i >= num_tokens){
            return lhs;
        }

        TokenKind operator = tokens[parse_i].kind;
        u8 next_precedence = parse_get_precedence(operator);
        u24 line_number = current_line_packed();

        if(is_terminating_token(operator) || next_precedence + is_right_associative(operator) < precedence){
            return lhs;
        }

        switch(operator){
        case TOKEN_ASSIGN:
        case TOKEN_ADD:
        case TOKEN_SUBTRACT:
        case TOKEN_MULTIPLY:
        case TOKEN_DIVIDE:
        case TOKEN_MOD:
        case TOKEN_LESS_THAN:
        case TOKEN_GREATER_THAN:
        case TOKEN_LESS_THAN_OR_EQUAL:
        case TOKEN_GREATER_THAN_OR_EQUAL:
        case TOKEN_LSHIFT:
        case TOKEN_RSHIFT:
        case TOKEN_EQUALS:
        case TOKEN_NOT_EQUALS:
        case TOKEN_AND:
        case TOKEN_OR:
        case TOKEN_BIT_AND:
        case TOKEN_BIT_OR:
        case TOKEN_BIT_XOR:
            lhs = parse_math(lhs, operator, line_number, next_precedence);
            break;
        case TOKEN_TERNARY:
            lhs = parse_ternary(lhs, line_number);
            break;
        case TOKEN_ADD_ASSIGN:
        case TOKEN_SUBTRACT_ASSIGN:
        case TOKEN_MULTIPLY_ASSIGN:
        case TOKEN_DIVIDE_ASSIGN:
        case TOKEN_MOD_ASSIGN:
        case TOKEN_LSHIFT_ASSIGN:
        case TOKEN_RSHIFT_ASSIGN:
        case TOKEN_BIT_AND_ASSIGN:
        case TOKEN_BIT_OR_ASSIGN:
        case TOKEN_BIT_XOR_ASSIGN:
            lhs = parse_operator_assign(lhs, operator, line_number, next_precedence);
            break;
        default:
            return lhs;
        }

        if(had_parse_error) return lhs;
    }

    return lhs;
}

Expression parse_expression(){
    Expression primary = parse_primary_expression();
    if(had_parse_error) return primary;

    return parse_operator_expression(0, primary);
}



ErrorCode parse_macro(){
    // # 
    //   ^

    u24 line_number = tokens[parse_i - 1].line;

    if(!is_token(TOKEN_WORD)){
        printf("\nerror on line %d: Expected macro name after '#'\n", u24_unpack(line_number));
        return 1;
    }

    u32 macro_name = eat_word();

    if(aux_cstr_equals_define(macro_name)){
        if(!is_token(TOKEN_WORD)){
            printf("\nerror on line %d: Expected definition name after '#define'\n", u24_unpack(line_number));
            return 1;
        }

        u32 name = eat_word();

        Expression expression = parse_expression();
        if(had_parse_error) return 1;

        Expression reduced_expression = perform_compile_time_math(expression);
        if(had_parse_error) return 1;

        u32 reduced = add_expression(reduced_expression);
        if(reduced >= EXPRESSIONS_CAPACITY) return 1;

        u32 define = add_define((Define){
            .name = name,
            .expression = reduced,
        });

        if(define >= DEFINES_CAPACITY){
            return 1;
        }
    } else {
        printf("\nerror on line %d: Unrecognized macro '#", u24_unpack(line_number));
        print_aux_cstr(macro_name);
        printf("'\n");
        return 1;
    }

    return 0;
}

u1 is_expression_kind_int_like(ExpressionKind kind){
    return kind == EXPRESSION_INT || kind == EXPRESSION_U8 || kind == EXPRESSION_U16 || kind == EXPRESSION_U24 || kind == EXPRESSION_U32;
}

Expression perform_compile_time_add(Expression expression){
    Expression a = perform_compile_time_math(expressions[operands[expression.ops]]);
    if(had_parse_error) return expression;

    Expression b = perform_compile_time_math(expressions[operands[expression.ops + 1]]);
    if(had_parse_error) return expression;

    if(!is_expression_kind_int_like(a.kind) || !is_expression_kind_int_like(b.kind)){
        printf("\nerror on line %d: Cannot perform compile-time add on values of different types\n", u24_unpack(expression.line));
        stop_parsing();
        return (Expression){0};
    }

    if(is_expression_kind_int_like(a.kind)){
        return (Expression){
            .kind = EXPRESSION_INT,
            .ops = a.ops + b.ops,
            .line = expression.line,
        };
    }

    printf("\nerror on line %d: Cannot perform compile-time add for that type\n", u24_unpack(expression.line));
    stop_parsing();
    return (Expression){0};
}

Expression perform_compile_time_subtract(Expression expression){
    Expression a = perform_compile_time_math(expressions[operands[expression.ops]]);
    if(had_parse_error) return expression;

    Expression b = perform_compile_time_math(expressions[operands[expression.ops + 1]]);
    if(had_parse_error) return expression;

    if(!is_expression_kind_int_like(a.kind) || !is_expression_kind_int_like(b.kind)){
        printf("\nerror on line %d: Cannot perform compile-time subtract on values of different types\n", u24_unpack(expression.line));
        stop_parsing();
        return (Expression){0};
    }

    if(is_expression_kind_int_like(a.kind)){
        return (Expression){
            .kind = EXPRESSION_INT,
            .ops = a.ops - b.ops,
            .line = expression.line,
        };
    }

    printf("\nerror on line %d: Cannot perform compile-time subtract for that type\n", u24_unpack(expression.line));
    stop_parsing();
    return (Expression){0};
}

Expression perform_compile_time_multiply(Expression expression){
    Expression a = perform_compile_time_math(expressions[operands[expression.ops]]);
    if(had_parse_error) return expression;

    Expression b = perform_compile_time_math(expressions[operands[expression.ops + 1]]);
    if(had_parse_error) return expression;

    if(!is_expression_kind_int_like(a.kind) || !is_expression_kind_int_like(b.kind)){
        printf("\nerror on line %d: Cannot perform compile-time multiply on values of different types\n", u24_unpack(expression.line));
        stop_parsing();
        return (Expression){0};
    }

    if(is_expression_kind_int_like(a.kind)){
        return (Expression){
            .kind = EXPRESSION_INT,
            .ops = a.ops * b.ops,
            .line = expression.line,
        };
    }

    printf("\nerror on line %d: Cannot perform compile-time multiply for that type\n", u24_unpack(expression.line));
    stop_parsing();
    return (Expression){0};
}

Expression perform_compile_time_divide(Expression expression){
    Expression a = perform_compile_time_math(expressions[operands[expression.ops]]);
    if(had_parse_error) return expression;

    Expression b = perform_compile_time_math(expressions[operands[expression.ops + 1]]);
    if(had_parse_error) return expression;

    if(!is_expression_kind_int_like(a.kind) || !is_expression_kind_int_like(b.kind)){
        printf("\nerror on line %d: Cannot perform compile-time divide on values of different types\n", u24_unpack(expression.line));
        stop_parsing();
        return (Expression){0};
    }

    if(is_expression_kind_int_like(a.kind)){
        return (Expression){
            .kind = EXPRESSION_INT,
            .ops = a.ops / b.ops,
            .line = expression.line,
        };
    }

    printf("\nerror on line %d: Cannot perform compile-time divide for that type\n", u24_unpack(expression.line));
    stop_parsing();
    return (Expression){0};
}

Expression perform_compile_time_modulo(Expression expression){
    Expression a = perform_compile_time_math(expressions[operands[expression.ops]]);
    if(had_parse_error) return expression;

    Expression b = perform_compile_time_math(expressions[operands[expression.ops + 1]]);
    if(had_parse_error) return expression;

    if(!is_expression_kind_int_like(a.kind) || !is_expression_kind_int_like(b.kind)){
        printf("\nerror on line %d: Cannot perform compile-time modulo on values of different types\n", u24_unpack(expression.line));
        stop_parsing();
        return (Expression){0};
    }

    if(is_expression_kind_int_like(a.kind)){
        return (Expression){
            .kind = EXPRESSION_INT,
            .ops = a.ops % b.ops,
            .line = expression.line,
        };
    }

    printf("\nerror on line %d: Cannot perform compile-time modulo for that type\n", u24_unpack(expression.line));
    stop_parsing();
    return (Expression){0};
}

Expression perform_compile_time_cast(Expression expression){
    u32 type = operands[expression.ops];

    Expression value = perform_compile_time_math(expressions[operands[expression.ops + 1]]);
    if(had_parse_error) return expression;

    if(is_expression_kind_int_like(value.kind)){
        if(type == u1_type){
            expression.kind = EXPRESSION_U1;
            return expression;
        } else if(type == u8_type){
            expression.kind = EXPRESSION_U8;
            return expression;
        } else if(type == u16_type){
            expression.kind = EXPRESSION_U16;
            return expression;
        } else if(type == u24_type){
            expression.kind = EXPRESSION_U24;
            return expression;
        } else if(type == u32_type){
            expression.kind = EXPRESSION_U32;
            return expression;
        }
    }

    printf("\nerror on line %d: Cannot perform compile-time cast from '", u24_unpack(expression.line));
    u32 from_type = expression_get_type(value, EXPRESSION_GET_TYPE_MODE_NONE);
    type_print(types[from_type]);
    printf("' to '");
    type_print(types[type]);
    printf("'\n");
    stop_parsing();
    return (Expression){0};
}

Expression perform_compile_time_math(Expression expression){
    switch(expression.kind){
    case EXPRESSION_U1:
    case EXPRESSION_U8:
    case EXPRESSION_U16:
    case EXPRESSION_U24:
    case EXPRESSION_U32:
    case EXPRESSION_INT:
    case EXPRESSION_STRING:
        return expression;
    case EXPRESSION_ADD:
        return perform_compile_time_add(expression);
    case EXPRESSION_SUBTRACT:
        return perform_compile_time_subtract(expression);
    case EXPRESSION_MULTIPLY:
        return perform_compile_time_multiply(expression);
    case EXPRESSION_DIVIDE:
        return perform_compile_time_divide(expression);
    case EXPRESSION_MOD:
        return perform_compile_time_modulo(expression);
    case EXPRESSION_CAST:
        return perform_compile_time_cast(expression);
    default:
        printf("\nerror on line %d: Cannot perform compile-time math on '#define' value\n", u24_unpack(expression.line));
        stop_parsing();
        return (Expression){0};
    }
}



u1 eat_semicolon();
u32 add_statement_else_print_error(Expression expression);
ErrorCode parse_declaration_assignment(u32 variable_name, u24 line_number);
ErrorCode parse_if();
ErrorCode parse_while();
ErrorCode parse_do_while();
ErrorCode parse_for();
ErrorCode parse_conditionless_block();
ErrorCode parse_return();
ErrorCode parse_break();
ErrorCode parse_continue();
ErrorCode parse_switch();
ErrorCode parse_case();
ErrorCode parse_default();

ErrorCode parse_statement(){
    if(is_type_followed_by(TOKEN_WORD)){
        if(parse_declaration(true)) return 1;
    } else if(eat_token(TOKEN_IF)){
        if(parse_if()) return 1;
    } else if(eat_token(TOKEN_WHILE)){
        if(parse_while()) return 1;
    } else if(eat_token(TOKEN_DO)){
        if(parse_do_while()) return 1;
    } else if(eat_token(TOKEN_FOR)){
        if(parse_for()) return 1;
    } else if(eat_token(TOKEN_RETURN)){
        if(parse_return()) return 1;
    } else if(eat_token(TOKEN_BREAK)){
        if(parse_break()) return 1;
    } else if(eat_token(TOKEN_CONTINUE)){
        if(parse_continue()) return 1;
    } else if(eat_token(TOKEN_SWITCH)){
        if(parse_switch()) return 1;
    } else if(eat_token(TOKEN_CASE)){
        if(parse_case()) return 1;
    } else if(eat_token(TOKEN_DEFAULT)){
        if(parse_default()) return 1;
    } else if(is_token(TOKEN_BEGIN)){
        if(parse_conditionless_block()) return 1;
    } else {
        Expression statement = parse_expression();
        if(had_parse_error) return 1;

        // Transform increments and decrements to expression with no result
        if(statement.kind == EXPRESSION_POST_INCREMENT || statement.kind == EXPRESSION_PRE_INCREMENT){
            statement.kind = EXPRESSION_NO_RESULT_INCREMENT;
        } else if(statement.kind == EXPRESSION_POST_DECREMENT || statement.kind == EXPRESSION_PRE_DECREMENT){
            statement.kind = EXPRESSION_NO_RESULT_DECREMENT;
        }

        if(had_parse_error || !eat_semicolon() || add_statement_else_print_error(statement) >= STATEMENTS_CAPACITY){
            return 1;
        }
    }

    return 0;
}

u1 eat_semicolon(){
    if(parse_trailing_semicolon && !eat_token(TOKEN_SEMICOLON)){
        u32 last_line;
        u32 this_line;

        if(parse_i > 0){
            parse_i--;
            last_line = current_line();
            parse_i++;
            this_line = current_line();
        } else {
            last_line = current_line();
            this_line = last_line;
        }


        if(this_line == last_line){
            printf("error on line %d: Expected ';' after statement\n", this_line);
            instead_got();
        } else {
            printf("error on line %d: Expected ';' after statement\n", last_line);
        }

        stop_parsing();
        return false;
    } else {
        return true;
    }
}

u32 add_statement_else_print_error(Expression expression){
    u32 statement = add_statement_from_new(expression);
    if(statement >= STATEMENTS_CAPACITY) stop_parsing();
    return statement;
}

ErrorCode parse_declaration_assignment(u32 variable_name, u24 line_number){
    if(!eat_token(TOKEN_ASSIGN)){
        printf("error on line %d: Expected '=' during assignment\n", current_line());
        stop_parsing();
        return 1;
    }

    Expression expression = parse_expression();
    if(had_parse_error) return 1;

    u32 new_value = add_expression(expression);
    if(new_value >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return 1;
    }

    u32 destination = add_expression((Expression){
        .kind = EXPRESSION_VARIABLE,
        .line = line_number,
        .ops = variable_name,
    });
    if(destination >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return 1;
    }

    u32 ops = add_operands2(destination, new_value);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return 1;
    }

    Expression statement = (Expression){
        .kind = EXPRESSION_ASSIGN,
        .line = line_number,
        .ops = ops,
    };

    return !eat_semicolon() || add_statement_else_print_error(statement) >= STATEMENTS_CAPACITY;
}

ErrorCode parse_declaration(u1 allow_assignment){
    u24 line_number = current_line_packed();

    Type type = parse_type();
    if(had_parse_error) return 1;

    if(!is_token(TOKEN_WORD)){
        printf("error on line %d: Expected variable name after type\n", current_line());
        instead_got();
        return 1;
    }

    u32 variable_name = eat_word();

    if(is_token(TOKEN_OPEN_BRACKET)){
        type.dimensions = parse_dimensions(dimensions[type.dimensions]);
        if(type.dimensions >= UNIQUE_DIMENSIONS_CAPACITY) return 1;
    }
    
    u32 variable_type = add_type(type);
    if(variable_type == TYPES_CAPACITY){
        stop_parsing();
        return 1;
    }

    u32 ops = add_operands2(variable_type, variable_name);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return 1;
    }

    Expression statement = (Expression){
        .kind = EXPRESSION_DECLARE,
        .line = line_number,
        .ops = ops,
    };

    if(allow_assignment && is_token(TOKEN_ASSIGN)){
        return add_statement_else_print_error(statement) >= STATEMENTS_CAPACITY || parse_declaration_assignment(variable_name, line_number);
    } else {
        return !eat_semicolon() || add_statement_else_print_error(statement) >= STATEMENTS_CAPACITY;
    }
}

u32 parse_block(u1 allow_cases){
    // Returns number of statements in block, otherwise STATEMENTS_CAPACITY if error

    u32 start = num_statements;
    u1 previous_parse_trailing_semicolon = parse_trailing_semicolon;
    parse_trailing_semicolon = true;

    u32 last_case = STATEMENTS_CAPACITY;
    
    // Traditional block
    if(eat_token(TOKEN_BEGIN)){
        while(parse_i < num_tokens && !is_token(TOKEN_END)){
            if(parse_statement()) return STATEMENTS_CAPACITY;

            Expression expression = expressions[statements[num_statements - 1]];

            if(expression.kind == EXPRESSION_CASE){
                if(allow_cases){
                    if(last_case < STATEMENTS_CAPACITY){
                        // Set number of statements for last 'case' statement
                        operands[expressions[statements[last_case]].ops + 1] = num_statements - last_case - 2;
                    }

                    last_case = num_statements - 1;
                } else {
                    expression_print_cannot_use_case_here_error(expression);
                    stop_parsing();
                    return STATEMENTS_CAPACITY;
                }
            }
        }

        if(last_case < STATEMENTS_CAPACITY){
            // Set number of statements for last 'case' statement
            // NOTE: We only have to subtract 1, since we don't create a final 'case' statement
            operands[expressions[statements[last_case]].ops + 1] = num_statements - last_case - 1;
        }

        if(!eat_token(TOKEN_END)){
            printf("\nerror on line %d: Expected '}' to end block\n", current_line());
            stop_parsing();
            return STATEMENTS_CAPACITY;
        }
    } else {
        if(allow_cases){
            printf("\nerror on line %d: Expected '{' after value of 'switch' statement\n", current_line());
            stop_parsing();
            return STATEMENTS_CAPACITY;
        }

        // Single statement block
        if(parse_statement()) return STATEMENTS_CAPACITY;
    }

    parse_trailing_semicolon = previous_parse_trailing_semicolon;
    return num_statements - start;
}

ErrorCode parse_if(){
    // if
    //    ^

    u24 line = tokens[parse_i - 1].line;

    if(!eat_token(TOKEN_OPEN)){
        printf("\nerror on line %d: Expected '(' after 'if' keyword\n", current_line());
        stop_parsing();
        return 1;
    }

    Expression condition_expression = parse_expression();
    if(had_parse_error) return 1;

    if(!eat_token(TOKEN_CLOSE)){
        printf("\nerror on line %d: Expected ')' after 'if' condition\n", current_line());
        stop_parsing();
        return 1;
    }

    u32 condition = add_expression(condition_expression);
    if(condition >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return 1;
    }

    Expression statement = (Expression){
        .kind = EXPRESSION_IF,
        .line = line,
        .ops = 0,
    };

    u32 begin = add_statement_else_print_error(statement);
    if(begin >= STATEMENTS_CAPACITY) return 1;

    u32 num_then = parse_block(false);
    if(num_then >= STATEMENTS_CAPACITY) return 1;

    u32 num_else = 0;

    // Handle else
    if(eat_token(TOKEN_ELSE)){
        num_else = parse_block(false);
        if(num_else >= STATEMENTS_CAPACITY) return 1;
    }

    u32 ops;

    if(num_else == 0){
        // If statement
        ops = add_operands2(condition, num_then);
    } else {
        // If statement with else
        expressions[statements[begin]].kind = EXPRESSION_IF_ELSE;
        ops = add_operands3(condition, num_then, num_else);
    }

    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return 1;
    }

    expressions[statements[begin]].ops = ops;
    return 0;
}

ErrorCode parse_while(){
    // while
    //       ^

    u24 line = tokens[parse_i - 1].line;

    if(!eat_token(TOKEN_OPEN)){
        printf("\nerror on line %d: Expected '(' after 'while' keyword\n", current_line());
        stop_parsing();
        return 1;
    }

    Expression condition_expression = parse_expression();
    if(had_parse_error) return 1;

    if(!eat_token(TOKEN_CLOSE)){
        printf("\nerror on line %d: Expected ')' after 'while' condition\n", current_line());
        stop_parsing();
        return 1;
    }

    u32 condition = add_expression(condition_expression);
    if(condition >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return 1;
    }

    u32 ops = add_operands3(condition, 0, 0);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return 1;
    }

    Expression statement = (Expression){
        .kind = EXPRESSION_WHILE,
        .line = line,
        .ops = ops,
    };

    u32 begin = add_statement_else_print_error(statement);
    if(begin >= STATEMENTS_CAPACITY) return 1;

    u32 num_inside = parse_block(false);
    if(num_inside >= STATEMENTS_CAPACITY) return 1;

    // Set number of statements
    operands[ops + 1] = num_inside;
    return 0;
}

ErrorCode parse_do_while(){
    // do
    //    ^

    u24 line = tokens[parse_i - 1].line;

    Expression statement = (Expression){
        .kind = EXPRESSION_DO_WHILE,
        .line = line,
        .ops = 0,
    };

    u32 begin = add_statement_else_print_error(statement);
    if(begin >= STATEMENTS_CAPACITY) return 1;

    u32 num_inside = parse_block(false);
    if(num_inside >= STATEMENTS_CAPACITY) return 1;

    if(!eat_token(TOKEN_WHILE)){
        printf("\nerror on line %d: Expected 'while' after 'do-while' body\n", current_line());
        stop_parsing();
        return 1;
    }

    if(!eat_token(TOKEN_OPEN)){
        printf("\nerror on line %d: Expected '(' after 'while' keyword\n", current_line());
        stop_parsing();
        return 1;
    }

    Expression condition_expression = parse_expression();
    if(had_parse_error) return 1;

    if(!eat_token(TOKEN_CLOSE)){
        printf("\nerror on line %d: Expected ')' after 'do-while' condition\n", current_line());
        stop_parsing();
        return 1;
    }

    if(!eat_semicolon()){
        return 1;
    }

    u32 condition = add_expression(condition_expression);
    if(condition >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return 1;
    }

    u32 ops = add_operands3(condition, num_inside, 0);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return 1;
    }

    expressions[statements[begin]].ops = ops;
    return 0;
}

ErrorCode parse_for(){
    // for
    //     ^

    u24 line = tokens[parse_i - 1].line;

    u32 ops = add_operands5(0, 0, 0, 0, 0);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return 1;
    }

    Expression statement = (Expression){
        .kind = EXPRESSION_FOR,
        .line = line,
        .ops = ops,
    };

    u32 begin = add_statement_else_print_error(statement);
    if(begin >= STATEMENTS_CAPACITY) return 1;

    if(!eat_token(TOKEN_OPEN)){
        printf("\nerror on line %d: Expected '(' after 'for' keyword\n", current_line());
        stop_parsing();
        return 1;
    }

    if(!eat_token(TOKEN_SEMICOLON)){
        if(parse_statement()) return 1;

        // Set number of pre-statements to be 1
        operands[ops] = num_statements - begin - 1;
    }

    Expression condition_expression;

    if(eat_token(TOKEN_SEMICOLON)){
        condition_expression = (Expression){
            .kind = EXPRESSION_U1,
            .line = current_line_packed(),
            .ops = 1,
        };
    } else {
        condition_expression = parse_expression();
        if(had_parse_error) return 1;

        if(!eat_token(TOKEN_SEMICOLON)){
            printf("\nerror on line %d: Expected ';' after condition in 'for' statement\n", current_line());
            stop_parsing();
            return 1;
        }
    }

    u32 condition = add_expression(condition_expression);
    if(condition >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return 1;
    }

    operands[ops + 1] = condition;

    if(!eat_token(TOKEN_SEMICOLON)){
        // Disable trailing semicolon parsing
        u1 previous_parse_trailing_semicolon = parse_trailing_semicolon;
        parse_trailing_semicolon = false;

        if(parse_statement()) return 1;

        // Restore previous trailing semicolon parsing setting
        parse_trailing_semicolon = previous_parse_trailing_semicolon;

        // Set number of post-statements to be 1
        operands[ops + 2] = num_statements - begin - 1 - operands[ops];
    }

    if(!eat_token(TOKEN_CLOSE)){
        printf("\nerror on line %d: Expected ')' after 'for' condition\n", current_line());
        stop_parsing();
        return 1;
    }

    u32 num_inside = parse_block(false);
    if(num_inside >= STATEMENTS_CAPACITY) return 1;

    // Set number of statements
    operands[ops + 3] = num_inside;
    return 0;
}

ErrorCode parse_conditionless_block(){
    // {
    // ^

    Expression statement = (Expression){
        .kind = EXPRESSION_CONDITIONLESS_BLOCK,
        .line = current_line_packed(),
        .ops = 0,
    };

    u32 block = add_statement_else_print_error(statement);
    if(block >= STATEMENTS_CAPACITY){
        return 1;
    }

    u32 length = parse_block(false);

    if(length >= STATEMENTS_CAPACITY){
        return 1;
    }

    expressions[statements[block]].ops = length;
    return 0;
}

ErrorCode parse_return(){
    // return 
    //         ^

    u24 line = tokens[parse_i - 1].line;
    u32 value = EXPRESSIONS_CAPACITY;

    // Parse return value if not followed by a ';'
    if(!is_token(TOKEN_SEMICOLON)){
        Expression value_expression = parse_expression();
        if(had_parse_error) return 1;

        value = add_expression(value_expression);
        if(value >= EXPRESSIONS_CAPACITY){
            stop_parsing();
            return 1;
        }
    }

    Expression statement = (Expression){
        .kind = EXPRESSION_RETURN,
        .line = line,
        .ops = value,
    };

    return !eat_semicolon() || add_statement_else_print_error(statement) >= STATEMENTS_CAPACITY;
}

ErrorCode parse_break(){
    // break
    //       ^

    Expression statement = (Expression){
        .kind = EXPRESSION_BREAK,
        .line = tokens[parse_i - 1].line,
        .ops = 0,
    };

    return !eat_semicolon() || add_statement_else_print_error(statement) >= STATEMENTS_CAPACITY;
}

ErrorCode parse_continue(){
    // continue
    //          ^

    Expression statement = (Expression){
        .kind = EXPRESSION_CONTINUE,
        .line = tokens[parse_i - 1].line,
        .ops = 0,
    };

    return !eat_semicolon() || add_statement_else_print_error(statement) >= STATEMENTS_CAPACITY;
}

ErrorCode parse_switch(){
    // switch
    //        ^

    u24 line = tokens[parse_i - 1].line;

    if(!eat_token(TOKEN_OPEN)){
        printf("\nerror on line %d: Expected '(' after 'switch' keyword\n", current_line());
        stop_parsing();
        return 1;
    }

    Expression condition_expression = parse_expression();
    if(had_parse_error) return 1;

    if(!eat_token(TOKEN_CLOSE)){
        printf("\nerror on line %d: Expected ')' after 'switch' condition\n", current_line());
        stop_parsing();
        return 1;
    }

    u32 condition = add_expression(condition_expression);
    if(condition >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return 1;
    }

    u32 ops = add_operands2(condition, 0);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return 1;
    }

    Expression statement = (Expression){
        .kind = EXPRESSION_SWITCH,
        .line = line,
        .ops = ops,
    };

    u32 begin = add_statement_else_print_error(statement);
    if(begin >= STATEMENTS_CAPACITY) return 1;

    u32 num_inside = parse_block(true);
    if(num_inside >= STATEMENTS_CAPACITY) return 1;

    // Set number of statements
    operands[ops + 1] = num_inside;
    return 0;
}

ErrorCode parse_case(){
    // case 
    //      ^

    u24 line = tokens[parse_i - 1].line;

    Expression value_expression = parse_expression();
    if(had_parse_error) return 1;

    u32 value = add_expression(value_expression);
    if(value >= EXPRESSIONS_CAPACITY){
        stop_parsing();
        return 1;
    }

    u32 ops = add_operands2(value, 0);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return 1;
    }

    Expression statement = (Expression){
        .kind = EXPRESSION_CASE,
        .line = line,
        .ops = ops,
    };

    if(!eat_token(TOKEN_COLON)){
        printf("error on line %d: Expected ':' after 'case' value\n", current_line());
        stop_parsing();
        return 1;
    }

    return add_statement_else_print_error(statement) >= STATEMENTS_CAPACITY;
}

ErrorCode parse_default(){
    // default 
    //         ^

    u24 line = tokens[parse_i - 1].line;

    u32 ops = add_operands2(EXPRESSIONS_CAPACITY, 0);
    if(ops >= OPERANDS_CAPACITY){
        stop_parsing();
        return 1;
    }

    // NOTE: 'default' is just a 'case' with an out of bounds expression id
    Expression statement = (Expression){
        .kind = EXPRESSION_CASE,
        .line = line,
        .ops = ops,
    };

    if(!eat_token(TOKEN_COLON)){
        printf("error on line %d: Expected ':' after 'default' value\n", current_line());
        stop_parsing();
        return 1;
    }

    return add_statement_else_print_error(statement) >= STATEMENTS_CAPACITY;
}



Type parse_type(){
    Type type = (Type){
        .name = 0,
        .dimensions = 0,
    };

    // Parse type name
    if(!is_token(TOKEN_WORD)){
        printf("\nerror on line %d: Expected type\n", current_line());
        instead_got();
        stop_parsing();
        return type;
    }

    type.name = eat_word();

    u32 unaliased = try_resolve_type_alias(type.name);

    if(unaliased < TYPES_CAPACITY){
        type = types[unaliased];
        type.dimensions = parse_dimensions(dimensions[type.dimensions]);
    } else {
        u32 starting[4] = {0, 0, 0, 0};
        type.dimensions = parse_dimensions(starting);
    }

    // Translate C integer types
    if(aux_cstr_equals_void(type.name)){
        type.name = types[u0_type].name;
    } else if(aux_cstr_equals_bool(type.name)){
        type.name  = types[u1_type].name;
    } else if(aux_cstr_equals_char(type.name)){
        type.name = types[u8_type].name;
    } else if(aux_cstr_equals_short(type.name)){
        type.name = types[u16_type].name;
    } else if(aux_cstr_equals_int(type.name)){
        type.name = types[u16_type].name;
    } else if(aux_cstr_equals_long(type.name)){
        type.name = types[u32_type].name;
    }

    return type;
}

u1 is_type_followed_by(TokenKind followed_by){
    u32 prev_parse_i = parse_i;
    u1 ok = eat_token(TOKEN_WORD);

    for(u8 i = 1; ok && is_token(TOKEN_OPEN_BRACKET); i++){
        if(
            !eat_token(TOKEN_OPEN_BRACKET)
         || !(eat_token(TOKEN_INT) || eat_token(TOKEN_WORD))
         || !eat_token(TOKEN_CLOSE_BRACKET)
         || i > 4
        ){
            ok = false;
            break;
        }
    }

    ok = ok && is_token(followed_by);
    parse_i = prev_parse_i;
    return ok;
}



ErrorCode parse_typedef_struct(u24 line_number){
    // typedef struct {
    //                ^

    if(!eat_token(TOKEN_BEGIN)){
        printf("error on line %d: Expected '{' after struct keyword in type definition\n", current_line());
        stop_parsing();
        return 1;
    }

    u32 begin = num_statements;

    while(parse_i < num_tokens && !is_token(TOKEN_END)){
        if(parse_statement()) return 1;
    }

    if(!eat_token(TOKEN_END)){
        printf("error on line %d: Expected '}' after function body\n", current_line());
        instead_got();
        stop_parsing();
        return 1;
    }

    if(!is_token(TOKEN_WORD)){
        printf("error on line %d: Expected typedef name after '}'\n", current_line());
        instead_got();
        stop_parsing();
        return 1;
    }

    u32 name = eat_word();

    if(!eat_token(TOKEN_SEMICOLON)){
        printf("error on line %d: Expected ';' after typedef name\n", current_line());
        instead_got();
        stop_parsing();
        return 1;
    }

    u32 def = add_typedef((TypeDef){
        .kind = TYPEDEF_STRUCT,
        .line = line_number,
        .name = name,
        .begin = begin,
        .num_fields = num_statements - begin,
        .computed_size = -1,
    });

    return def >= TYPEDEFS_CAPACITY;
}

ErrorCode parse_typedef_enum(u24 line_number){
    // typedef enum {
    //              ^

    if(!eat_token(TOKEN_BEGIN)){
        printf("error on line %d: Expected '{' after struct keyword in type definition\n", current_line());
        stop_parsing();
        return 1;
    }

    u32 begin = num_statements;

    while(parse_i < num_tokens && !is_token(TOKEN_END)){
        if(!is_token(TOKEN_WORD)){
            printf("error on line %d: Expected variant inside of enum\n", current_line());
            stop_parsing();
            return 1;
        }

        u24 variant_line_number = current_line_packed();
        u32 word = eat_word();

        u32 variant = add_statement_from_new((Expression){
            .kind = EXPRESSION_ENUM_VARIANT,
            .ops = word,
            .line = variant_line_number,
        });

        if(variant >= STATEMENTS_CAPACITY){
            stop_parsing();
            return 1;
        }

        // Optionally eat ','
        eat_token(TOKEN_NEXT);
    }

    if(!eat_token(TOKEN_END)){
        printf("error on line %d: Expected '}' after function body\n", current_line());
        instead_got();
        stop_parsing();
        return 1;
    }

    if(!is_token(TOKEN_WORD)){
        printf("error on line %d: Expected typedef name after '}'\n", current_line());
        instead_got();
        stop_parsing();
        return 1;
    }

    u32 name = eat_word();

    if(!eat_token(TOKEN_SEMICOLON)){
        printf("error on line %d: Expected ';' after typedef name\n", current_line());
        instead_got();
        stop_parsing();
        return 1;
    }

    u32 count = num_statements - begin;
    u32 size = -1;

    if(count <= 0xFF){
        size = 1;
    } else if(count <= 0xFFFF){
        size = 2;
    } else if(count <= 0xFFFFFF){
        size = 3;
    } else {
        size = 4;
    }

    u32 def = add_typedef((TypeDef){
        .kind = TYPEDEF_ENUM,
        .line = line_number,
        .name = name,
        .begin = begin,
        .num_fields = count,
        .computed_size = size,
    });

    return def >= TYPEDEFS_CAPACITY;
}

ErrorCode parse_typedef_alias(u24 line_number){
    // typedef substitution_type alias_name;
    //                 ^

    if(parse_declaration(false)){
        return 1;
    }

    num_statements--;
    Expression expression = expressions[--num_expressions];

    if(expression.kind != EXPRESSION_DECLARE){
        printf("\ninternal error on line %d: Expected declaration for typedef alias\n", u24_unpack(line_number));
        return 1;
    }

    u32 type = operands[expression.ops];
    u32 name = operands[expression.ops + 1];
    num_operands -= 2;

    u32 alias = add_type_alias((TypeAlias){
        .name = name,
        .rewritten_type = type,
    });

    return alias >= TYPE_ALIASES_CAPACITY;
}

ErrorCode parse_typedef(){
    // typedef 
    //         ^

    u24 line_number = tokens[parse_i - 1].line;

    if(eat_token(TOKEN_STRUCT)){
        return parse_typedef_struct(line_number);
    }

    if(eat_token(TOKEN_ENUM)){
        return parse_typedef_enum(line_number);
    }

    return parse_typedef_alias(line_number);
}



u0 print_lexed_construction(){
    u32 delta_aux = num_aux;
    u32 delta_tokens = num_tokens;

    printf("// Assume that num_aux + delta_aux < AUX_CAPACITY\n");
    for(u32 i = 0; i < num_aux; i++){
        printf("aux[(u32) %d] = %d;\n", i, aux[i]);
    }
    printf("num_aux += %d;\n", delta_aux);

    printf("// Assume that num_tokens + delta_tokens < AUX_CAPACITY\n");
    for(u32 i = 0; i < num_tokens; i++){
        u32 kind = tokens[i].kind;
        u32 data = tokens[i].data;
        printf("tokens[(u32) %d] = (Token){ .kind = (TokenKind) %d, .data = (u32) %u };\n", i, kind, (u32) data);
    }
    printf("num_tokens += (u32) %d;\n", delta_tokens);
}



u0 emit_stack_pointer(){
    copy_cells_static(emit_settings.stack_pointer, 4);
}

u0 emit_set_stack_pointer(){
    printf("<");
    emit_context.current_cell_index--;
    move_cells_static(emit_settings.stack_pointer, 4);
}

u0 emit_stack_driver_pre(u32 main_function_index){
    // Enable stack overflow checks
    emit_settings.stack_overflow_checks = true;
    emit_settings.stack_overflow_message = aux_cstr_alloc( "---- STACK OVERFLOW!!! ----\n");

    // Initialize `in_basicblock`
    emit_settings.in_basicblock = false;

    // Create stack pointer
    emit_settings.stack_pointer = emit_context.current_cell_index;
    emit_u32(8);

    // Add exit (basicblock 0) to stack
    emit_u32(0);
    printf("<");
    emit_context.current_cell_index--;
    move_cells_static(emit_settings.stack_begin, 4);

    // Add entry point to stack
    emit_u32(basicblock_id_for_function(main_function_index));
    printf("<");
    emit_context.current_cell_index--;
    move_cells_static(emit_settings.stack_begin + 4, 4);

    // Do while
    printf("[-]+[");

    // Read next basicblock to execute from stack
    emit_stack_pop_n(4);

    // Debug print new basicblock id
    /*
    dupe_cells(4);
    printf("3<");
    emit_printu8();
    printf("[-]++++++++++++++++++++++++++++++++.");
    printf("<");
    emit_context.current_cell_index -= 4;

    emit_stack_pointer();
    emit_printu8();
    printf("[-]++++++++++++++++++++++++++++++++.");
    printf("<");
    emit_printu8();
    printf("[-]++++++++++++++++++++++++++++++++.");
    printf("<");
    emit_printu8();
    printf("[-]++++++++++++++++++++++++++++++++.");
    printf("<");
    emit_printu8();
    printf("[-]++++++++++++++++++++++++++++++++.");
    printf("[-]++++++++++.");
    printf("<");
    emit_context.current_cell_index -= 4;
    */

    // Reserve number of basicblocks for exit basicblock as well as all functions
    emit_settings.next_basicblock_id = 1 + num_functions;

    // Retain stack driver start position
    emit_settings.stack_driver_position = emit_context.current_cell_index;

    // Switch basicblock id

    // (closed via emit_stack_driver_post)

    /*
    emit_start_basicblock(basicblock_id_for_function(main_function_index));
        printf("[-]>[-]>[-]>[-]>[-]>[-]>6<");
        printf(">++++++++[<+++++++++>-]<.>++++[<+++++++>-]<+.+++++++..+++.>>++++++[<+++++++>-]<++.------------.>++++++[<+++++++++>-]<+.<.+++.------.--------.>>>++++[<++++++++>-]<+.<<");
        printf("[-]++++++++++.");

        emit_u32(100);
        emit_stack_push_n(4);
    emit_end_basicblock();

    emit_start_basicblock(100);
        u32 aux_cstr = aux_cstr_alloc( "Bye world!!!\n");
        emit_print_aux_cstr(aux_cstr);
        emit_u32(basicblock_id_for_function(main_function_index));
        emit_stack_push_n(4);
    emit_end_basicblock();
    */
}

u32 basicblock_id_for_function(u32 function_id){
    return function_id + 1;
}

u0 emit_start_basicblock(u32 basicblock_id){
    dupe_cells(4);
    emit_u32(basicblock_id);
    emit_eq_u32();
    printf("<");
    emit_context.current_cell_index--;
    printf("[");

    emit_settings.in_basicblock = true;
}

u0 emit_end_basicblock(){
    printf("[-]]");
    emit_settings.in_basicblock = false;
}

u0 emit_start_basicblock_landing(u32 basicblock_id, u32 num_cells_to_pop){
    emit_start_basicblock(basicblock_id);
    emit_stack_pop_n(num_cells_to_pop);
}

u32 emit_jump(u32 target_basicblock_id){
    u32 pushed = emit_stack_driver_push_all();
    emit_u32(target_basicblock_id);
    emit_stack_push_n(4);
    return pushed;
}

u32 emit_jump_compatible(u32 target_basicblock_id, u32 expected_pushed_cells){
    u32 pushed = emit_jump(target_basicblock_id);

    if(pushed != expected_pushed_cells){
        printf("\ninternal error: emit_jump_compatible - tried to do incompatible jump (%d vs %d)\n", pushed, expected_pushed_cells);
    }

    return pushed;
}

u32 emit_end_basicblock_jump(u32 target_basicblock_id){
    u32 pushed = emit_jump(target_basicblock_id);

    emit_end_basicblock();
    return pushed;
}

u0 emit_end_basicblock_jump_compatible(u32 target_basicblock_id, u32 expected_pushed_cells){
    u32 amount = emit_end_basicblock_jump(target_basicblock_id);

    if(amount != expected_pushed_cells){
        printf("\ninternal error: emit_end_basicblock_jump_compatible - tried to end basicblock via incompatible jump (%d vs %d)\n", amount, expected_pushed_cells);

        if(emit_context.function < FUNCTIONS_CAPACITY){
            printf("\n  Inside of function: ");
            print_aux_cstr(functions[emit_context.function].name);
            printf("\n");
        }
    }
}

u32 emit_end_basicblock_jump_conditional(u32 then_basicblock_id, u32 else_basicblock_id){
    // condition
    //           ^

    // Allocate 'should_run_else' cell
    printf("[-]+");

    // Go to condition cell
    printf("<");
    emit_context.current_cell_index--;

    u32 condition_cell = emit_context.current_cell_index;

    // If condition
    printf("[");
        u32 pushed = emit_jump(then_basicblock_id);

        // Go back to 'condition' cell
        printf("%d>", condition_cell - emit_context.current_cell_index);
        emit_context.current_cell_index = condition_cell;

        // Zero 'should_run_else' cell
        printf(">[-]<");

    // End if
    printf("[-]]");

    // Go to 'should_run_else' cell
    printf(">");
    emit_context.current_cell_index++;

    u32 else_cell = emit_context.current_cell_index;

    // If 'should_run_else' cell
    printf("[");
        printf("<");
        emit_context.current_cell_index -= 1;

        emit_jump_compatible(else_basicblock_id, pushed);

        // Go back to 'condition' cell
        printf("%d>", else_cell - emit_context.current_cell_index);
        emit_context.current_cell_index = else_cell;

    // End if
    printf("[-]]");

    // Go to stack driver position
    printf("%d<", emit_context.current_cell_index - emit_settings.stack_driver_position);
    emit_context.current_cell_index = emit_settings.stack_driver_position;

    // End basicblock
    emit_end_basicblock();
    return pushed;
}

u0 emit_end_basicblock_jump_to(JumpContext context){
    u32 has = emit_context.current_cell_index - emit_settings.stack_driver_position;
    u32 remove = has - context.num_cells_input;

    if(remove != 0){
        printf("%d<", remove);
        emit_context.current_cell_index -= remove;
    }

    emit_end_basicblock_jump_compatible(context.basicblock_id, context.num_cells_input);
}

u0 emit_stack_driver_post(){
    // Keep looping until basicblock id is zero
    emit_u32(0);
    emit_neq_u32();
    printf("<");
    printf("]");
}

u0 emit_basicblock_pre(u32 basicblock_id){
    // Run basicblock if current basicblock id matches this basicblock id
    dupe_cells(4);
    emit_u32(basicblock_id);
    emit_eq_u32();
    printf("[");
}

u0 emit_basicblock_post(){
    if(emit_settings.stack_pointer != emit_settings.stack_driver_position){
        printf("\nerror: basicblock content corrupted stack driver position\n");
    }

    // End if
    printf("[-]]");
}

u32 emit_stack_driver_push_all(){
    u32 count = emit_context.current_cell_index - emit_settings.stack_driver_position;
    emit_stack_push_n(count);
    return count;
}

u0 emit_stack_driver_pop_all(){
    // Compute `stack_pointer - 4`
    copy_cells_static(emit_settings.stack_pointer, 4);
    emit_u32(4);
    emit_additive_u32(false);

    // Get number of local cells
    copy_cells_dynamic_u32(emit_settings.stack_begin, 4);

    /*
    i = 0;
    while(i != num_local_cells){
        stack_pointer();
        copy(i);
        emit_additive(true);
        copy_cell_dynamic_u32(emit_context.stack_begin, 4);
        i++;
    }
    */
}

u0 emit_stack_push_n(u32 num_cells){
    // data1 data2 data3 data4
    //                         ^

    if(num_cells != 0){
        if(emit_settings.stack_overflow_checks){
            emit_stack_pointer();
            emit_u32(num_cells);
            emit_additive_u32(true);
            emit_u32(emit_settings.stack_size);
            emit_gte_u32();
            printf("<");
            emit_context.current_cell_index--;
            printf("[");
                emit_print_aux_cstr(emit_settings.stack_overflow_message);
                printf("[-]+[]");
            printf("]");
        }

        // Move bytes onto stack
        emit_stack_pointer();
        printf("<");
        emit_context.current_cell_index--;
        move_cells_dynamic_u32(emit_settings.stack_begin, num_cells);

        // Increase stack pointer
        emit_stack_pointer();
        emit_u32(num_cells);
        emit_additive_u32(true);
        emit_set_stack_pointer();
    }
}

u0 emit_stack_pop_n(u32 num_cells){
    if(num_cells != 0){
        // Compute `stack_pointer - n`
        emit_stack_pointer();
        emit_u32(num_cells);
        emit_additive_u32(false);

        // Set stack pointer to `stack_pointer - num_cells`
        dupe_cells(4);
        emit_set_stack_pointer();

        // Read cells from stack
        copy_cells_dynamic_u32(emit_settings.stack_begin, num_cells);
    }
}

u32 emit_recursive_functions(){
    for(u32 function_i = 0; function_i < num_functions; function_i++){
        Function function = functions[function_i];

        if(!function.is_recursive){
            continue;
        }

        if(emit_settings.stack_driver_position != emit_context.current_cell_index){
            int off_by = (int) emit_context.current_cell_index - (int) emit_settings.stack_driver_position;
            printf("\ninternal error on line %d: Failed to generate recursive function as final resting cell index does not match expected stack driver position (%d cells off)\n", u24_unpack(function.line), off_by);
            return 1;
        }

        u32 args_size = function_args_size(function);
        if(args_size == -1) return 1;

        emit_start_basicblock_landing(basicblock_id_for_function(function_i), args_size);
        if(function_emit(function_i, emit_settings.stack_driver_position, emit_context.current_cell_index) != 0){
            return 1;
        }
        if(emit_settings.in_basicblock){
            emit_end_basicblock();
        }
    }

    return 0;
}


u0 inject_standard_library(){
    // Assume that num_aux + delta_aux < AUX_CAPACITY
    aux[(u32) 0] = 117;
    aux[(u32) 1] = 49;
    aux[(u32) 2] = 54;
    aux[(u32) 3] = 0;
    aux[(u32) 4] = 117;
    aux[(u32) 5] = 49;
    aux[(u32) 6] = 54;
    aux[(u32) 7] = 95;
    aux[(u32) 8] = 97;
    aux[(u32) 9] = 100;
    aux[(u32) 10] = 100;
    aux[(u32) 11] = 95;
    aux[(u32) 12] = 117;
    aux[(u32) 13] = 56;
    aux[(u32) 14] = 115;
    aux[(u32) 15] = 0;
    aux[(u32) 16] = 117;
    aux[(u32) 17] = 56;
    aux[(u32) 18] = 0;
    aux[(u32) 19] = 97;
    aux[(u32) 20] = 0;
    aux[(u32) 21] = 117;
    aux[(u32) 22] = 56;
    aux[(u32) 23] = 0;
    aux[(u32) 24] = 98;
    aux[(u32) 25] = 0;
    aux[(u32) 26] = 117;
    aux[(u32) 27] = 49;
    aux[(u32) 28] = 54;
    aux[(u32) 29] = 0;
    aux[(u32) 30] = 114;
    aux[(u32) 31] = 101;
    aux[(u32) 32] = 115;
    aux[(u32) 33] = 117;
    aux[(u32) 34] = 108;
    aux[(u32) 35] = 116;
    aux[(u32) 36] = 0;
    aux[(u32) 37] = 117;
    aux[(u32) 38] = 56;
    aux[(u32) 39] = 0;
    aux[(u32) 40] = 108;
    aux[(u32) 41] = 111;
    aux[(u32) 42] = 119;
    aux[(u32) 43] = 101;
    aux[(u32) 44] = 114;
    aux[(u32) 45] = 0;
    aux[(u32) 46] = 97;
    aux[(u32) 47] = 0;
    aux[(u32) 48] = 98;
    aux[(u32) 49] = 0;
    aux[(u32) 50] = 114;
    aux[(u32) 51] = 101;
    aux[(u32) 52] = 115;
    aux[(u32) 53] = 117;
    aux[(u32) 54] = 108;
    aux[(u32) 55] = 116;
    aux[(u32) 56] = 0;
    aux[(u32) 57] = 95;
    aux[(u32) 58] = 48;
    aux[(u32) 59] = 0;
    aux[(u32) 60] = 108;
    aux[(u32) 61] = 111;
    aux[(u32) 62] = 119;
    aux[(u32) 63] = 101;
    aux[(u32) 64] = 114;
    aux[(u32) 65] = 0;
    aux[(u32) 66] = 114;
    aux[(u32) 67] = 101;
    aux[(u32) 68] = 115;
    aux[(u32) 69] = 117;
    aux[(u32) 70] = 108;
    aux[(u32) 71] = 116;
    aux[(u32) 72] = 0;
    aux[(u32) 73] = 95;
    aux[(u32) 74] = 49;
    aux[(u32) 75] = 0;
    aux[(u32) 76] = 117;
    aux[(u32) 77] = 56;
    aux[(u32) 78] = 0;
    aux[(u32) 79] = 108;
    aux[(u32) 80] = 111;
    aux[(u32) 81] = 119;
    aux[(u32) 82] = 101;
    aux[(u32) 83] = 114;
    aux[(u32) 84] = 0;
    aux[(u32) 85] = 97;
    aux[(u32) 86] = 0;
    aux[(u32) 87] = 108;
    aux[(u32) 88] = 111;
    aux[(u32) 89] = 119;
    aux[(u32) 90] = 101;
    aux[(u32) 91] = 114;
    aux[(u32) 92] = 0;
    aux[(u32) 93] = 98;
    aux[(u32) 94] = 0;
    aux[(u32) 95] = 114;
    aux[(u32) 96] = 101;
    aux[(u32) 97] = 115;
    aux[(u32) 98] = 117;
    aux[(u32) 99] = 108;
    aux[(u32) 100] = 116;
    aux[(u32) 101] = 0;
    aux[(u32) 102] = 117;
    aux[(u32) 103] = 49;
    aux[(u32) 104] = 54;
    aux[(u32) 105] = 0;
    aux[(u32) 106] = 117;
    aux[(u32) 107] = 49;
    aux[(u32) 108] = 54;
    aux[(u32) 109] = 95;
    aux[(u32) 110] = 97;
    aux[(u32) 111] = 100;
    aux[(u32) 112] = 100;
    aux[(u32) 113] = 0;
    aux[(u32) 114] = 117;
    aux[(u32) 115] = 49;
    aux[(u32) 116] = 54;
    aux[(u32) 117] = 0;
    aux[(u32) 118] = 97;
    aux[(u32) 119] = 0;
    aux[(u32) 120] = 117;
    aux[(u32) 121] = 49;
    aux[(u32) 122] = 54;
    aux[(u32) 123] = 0;
    aux[(u32) 124] = 98;
    aux[(u32) 125] = 0;
    aux[(u32) 126] = 117;
    aux[(u32) 127] = 49;
    aux[(u32) 128] = 54;
    aux[(u32) 129] = 0;
    aux[(u32) 130] = 114;
    aux[(u32) 131] = 101;
    aux[(u32) 132] = 115;
    aux[(u32) 133] = 117;
    aux[(u32) 134] = 108;
    aux[(u32) 135] = 116;
    aux[(u32) 136] = 0;
    aux[(u32) 137] = 117;
    aux[(u32) 138] = 49;
    aux[(u32) 139] = 54;
    aux[(u32) 140] = 95;
    aux[(u32) 141] = 97;
    aux[(u32) 142] = 100;
    aux[(u32) 143] = 100;
    aux[(u32) 144] = 95;
    aux[(u32) 145] = 117;
    aux[(u32) 146] = 56;
    aux[(u32) 147] = 115;
    aux[(u32) 148] = 0;
    aux[(u32) 149] = 97;
    aux[(u32) 150] = 0;
    aux[(u32) 151] = 95;
    aux[(u32) 152] = 48;
    aux[(u32) 153] = 0;
    aux[(u32) 154] = 98;
    aux[(u32) 155] = 0;
    aux[(u32) 156] = 95;
    aux[(u32) 157] = 48;
    aux[(u32) 158] = 0;
    aux[(u32) 159] = 114;
    aux[(u32) 160] = 101;
    aux[(u32) 161] = 115;
    aux[(u32) 162] = 117;
    aux[(u32) 163] = 108;
    aux[(u32) 164] = 116;
    aux[(u32) 165] = 0;
    aux[(u32) 166] = 95;
    aux[(u32) 167] = 49;
    aux[(u32) 168] = 0;
    aux[(u32) 169] = 97;
    aux[(u32) 170] = 0;
    aux[(u32) 171] = 95;
    aux[(u32) 172] = 49;
    aux[(u32) 173] = 0;
    aux[(u32) 174] = 98;
    aux[(u32) 175] = 0;
    aux[(u32) 176] = 95;
    aux[(u32) 177] = 49;
    aux[(u32) 178] = 0;
    aux[(u32) 179] = 114;
    aux[(u32) 180] = 101;
    aux[(u32) 181] = 115;
    aux[(u32) 182] = 117;
    aux[(u32) 183] = 108;
    aux[(u32) 184] = 116;
    aux[(u32) 185] = 0;
    aux[(u32) 186] = 117;
    aux[(u32) 187] = 49;
    aux[(u32) 188] = 54;
    aux[(u32) 189] = 0;
    aux[(u32) 190] = 117;
    aux[(u32) 191] = 49;
    aux[(u32) 192] = 54;
    aux[(u32) 193] = 95;
    aux[(u32) 194] = 115;
    aux[(u32) 195] = 117;
    aux[(u32) 196] = 98;
    aux[(u32) 197] = 0;
    aux[(u32) 198] = 117;
    aux[(u32) 199] = 49;
    aux[(u32) 200] = 54;
    aux[(u32) 201] = 0;
    aux[(u32) 202] = 97;
    aux[(u32) 203] = 0;
    aux[(u32) 204] = 117;
    aux[(u32) 205] = 49;
    aux[(u32) 206] = 54;
    aux[(u32) 207] = 0;
    aux[(u32) 208] = 98;
    aux[(u32) 209] = 0;
    aux[(u32) 210] = 117;
    aux[(u32) 211] = 49;
    aux[(u32) 212] = 54;
    aux[(u32) 213] = 0;
    aux[(u32) 214] = 110;
    aux[(u32) 215] = 101;
    aux[(u32) 216] = 103;
    aux[(u32) 217] = 97;
    aux[(u32) 218] = 116;
    aux[(u32) 219] = 105;
    aux[(u32) 220] = 118;
    aux[(u32) 221] = 101;
    aux[(u32) 222] = 95;
    aux[(u32) 223] = 98;
    aux[(u32) 224] = 0;
    aux[(u32) 225] = 117;
    aux[(u32) 226] = 49;
    aux[(u32) 227] = 54;
    aux[(u32) 228] = 95;
    aux[(u32) 229] = 97;
    aux[(u32) 230] = 100;
    aux[(u32) 231] = 100;
    aux[(u32) 232] = 0;
    aux[(u32) 233] = 117;
    aux[(u32) 234] = 49;
    aux[(u32) 235] = 54;
    aux[(u32) 236] = 95;
    aux[(u32) 237] = 98;
    aux[(u32) 238] = 105;
    aux[(u32) 239] = 116;
    aux[(u32) 240] = 95;
    aux[(u32) 241] = 110;
    aux[(u32) 242] = 101;
    aux[(u32) 243] = 103;
    aux[(u32) 244] = 0;
    aux[(u32) 245] = 98;
    aux[(u32) 246] = 0;
    aux[(u32) 247] = 117;
    aux[(u32) 248] = 49;
    aux[(u32) 249] = 54;
    aux[(u32) 250] = 95;
    aux[(u32) 251] = 97;
    aux[(u32) 252] = 100;
    aux[(u32) 253] = 100;
    aux[(u32) 254] = 0;
    aux[(u32) 255] = 97;
    aux[(u32) 256] = 0;
    aux[(u32) 257] = 110;
    aux[(u32) 258] = 101;
    aux[(u32) 259] = 103;
    aux[(u32) 260] = 97;
    aux[(u32) 261] = 116;
    aux[(u32) 262] = 105;
    aux[(u32) 263] = 118;
    aux[(u32) 264] = 101;
    aux[(u32) 265] = 95;
    aux[(u32) 266] = 98;
    aux[(u32) 267] = 0;
    aux[(u32) 268] = 117;
    aux[(u32) 269] = 49;
    aux[(u32) 270] = 54;
    aux[(u32) 271] = 0;
    aux[(u32) 272] = 117;
    aux[(u32) 273] = 49;
    aux[(u32) 274] = 54;
    aux[(u32) 275] = 95;
    aux[(u32) 276] = 98;
    aux[(u32) 277] = 105;
    aux[(u32) 278] = 116;
    aux[(u32) 279] = 95;
    aux[(u32) 280] = 97;
    aux[(u32) 281] = 110;
    aux[(u32) 282] = 100;
    aux[(u32) 283] = 0;
    aux[(u32) 284] = 117;
    aux[(u32) 285] = 49;
    aux[(u32) 286] = 54;
    aux[(u32) 287] = 0;
    aux[(u32) 288] = 97;
    aux[(u32) 289] = 0;
    aux[(u32) 290] = 117;
    aux[(u32) 291] = 49;
    aux[(u32) 292] = 54;
    aux[(u32) 293] = 0;
    aux[(u32) 294] = 98;
    aux[(u32) 295] = 0;
    aux[(u32) 296] = 117;
    aux[(u32) 297] = 49;
    aux[(u32) 298] = 54;
    aux[(u32) 299] = 0;
    aux[(u32) 300] = 114;
    aux[(u32) 301] = 101;
    aux[(u32) 302] = 115;
    aux[(u32) 303] = 117;
    aux[(u32) 304] = 108;
    aux[(u32) 305] = 116;
    aux[(u32) 306] = 0;
    aux[(u32) 307] = 114;
    aux[(u32) 308] = 101;
    aux[(u32) 309] = 115;
    aux[(u32) 310] = 117;
    aux[(u32) 311] = 108;
    aux[(u32) 312] = 116;
    aux[(u32) 313] = 0;
    aux[(u32) 314] = 95;
    aux[(u32) 315] = 49;
    aux[(u32) 316] = 0;
    aux[(u32) 317] = 97;
    aux[(u32) 318] = 0;
    aux[(u32) 319] = 95;
    aux[(u32) 320] = 49;
    aux[(u32) 321] = 0;
    aux[(u32) 322] = 98;
    aux[(u32) 323] = 0;
    aux[(u32) 324] = 95;
    aux[(u32) 325] = 49;
    aux[(u32) 326] = 0;
    aux[(u32) 327] = 114;
    aux[(u32) 328] = 101;
    aux[(u32) 329] = 115;
    aux[(u32) 330] = 117;
    aux[(u32) 331] = 108;
    aux[(u32) 332] = 116;
    aux[(u32) 333] = 0;
    aux[(u32) 334] = 95;
    aux[(u32) 335] = 48;
    aux[(u32) 336] = 0;
    aux[(u32) 337] = 97;
    aux[(u32) 338] = 0;
    aux[(u32) 339] = 95;
    aux[(u32) 340] = 48;
    aux[(u32) 341] = 0;
    aux[(u32) 342] = 98;
    aux[(u32) 343] = 0;
    aux[(u32) 344] = 95;
    aux[(u32) 345] = 48;
    aux[(u32) 346] = 0;
    aux[(u32) 347] = 114;
    aux[(u32) 348] = 101;
    aux[(u32) 349] = 115;
    aux[(u32) 350] = 117;
    aux[(u32) 351] = 108;
    aux[(u32) 352] = 116;
    aux[(u32) 353] = 0;
    aux[(u32) 354] = 117;
    aux[(u32) 355] = 49;
    aux[(u32) 356] = 54;
    aux[(u32) 357] = 0;
    aux[(u32) 358] = 117;
    aux[(u32) 359] = 49;
    aux[(u32) 360] = 54;
    aux[(u32) 361] = 95;
    aux[(u32) 362] = 98;
    aux[(u32) 363] = 105;
    aux[(u32) 364] = 116;
    aux[(u32) 365] = 95;
    aux[(u32) 366] = 111;
    aux[(u32) 367] = 114;
    aux[(u32) 368] = 0;
    aux[(u32) 369] = 117;
    aux[(u32) 370] = 49;
    aux[(u32) 371] = 54;
    aux[(u32) 372] = 0;
    aux[(u32) 373] = 97;
    aux[(u32) 374] = 0;
    aux[(u32) 375] = 117;
    aux[(u32) 376] = 49;
    aux[(u32) 377] = 54;
    aux[(u32) 378] = 0;
    aux[(u32) 379] = 98;
    aux[(u32) 380] = 0;
    aux[(u32) 381] = 117;
    aux[(u32) 382] = 49;
    aux[(u32) 383] = 54;
    aux[(u32) 384] = 0;
    aux[(u32) 385] = 114;
    aux[(u32) 386] = 101;
    aux[(u32) 387] = 115;
    aux[(u32) 388] = 117;
    aux[(u32) 389] = 108;
    aux[(u32) 390] = 116;
    aux[(u32) 391] = 0;
    aux[(u32) 392] = 114;
    aux[(u32) 393] = 101;
    aux[(u32) 394] = 115;
    aux[(u32) 395] = 117;
    aux[(u32) 396] = 108;
    aux[(u32) 397] = 116;
    aux[(u32) 398] = 0;
    aux[(u32) 399] = 95;
    aux[(u32) 400] = 49;
    aux[(u32) 401] = 0;
    aux[(u32) 402] = 97;
    aux[(u32) 403] = 0;
    aux[(u32) 404] = 95;
    aux[(u32) 405] = 49;
    aux[(u32) 406] = 0;
    aux[(u32) 407] = 98;
    aux[(u32) 408] = 0;
    aux[(u32) 409] = 95;
    aux[(u32) 410] = 49;
    aux[(u32) 411] = 0;
    aux[(u32) 412] = 114;
    aux[(u32) 413] = 101;
    aux[(u32) 414] = 115;
    aux[(u32) 415] = 117;
    aux[(u32) 416] = 108;
    aux[(u32) 417] = 116;
    aux[(u32) 418] = 0;
    aux[(u32) 419] = 95;
    aux[(u32) 420] = 48;
    aux[(u32) 421] = 0;
    aux[(u32) 422] = 97;
    aux[(u32) 423] = 0;
    aux[(u32) 424] = 95;
    aux[(u32) 425] = 48;
    aux[(u32) 426] = 0;
    aux[(u32) 427] = 98;
    aux[(u32) 428] = 0;
    aux[(u32) 429] = 95;
    aux[(u32) 430] = 48;
    aux[(u32) 431] = 0;
    aux[(u32) 432] = 114;
    aux[(u32) 433] = 101;
    aux[(u32) 434] = 115;
    aux[(u32) 435] = 117;
    aux[(u32) 436] = 108;
    aux[(u32) 437] = 116;
    aux[(u32) 438] = 0;
    aux[(u32) 439] = 117;
    aux[(u32) 440] = 49;
    aux[(u32) 441] = 54;
    aux[(u32) 442] = 0;
    aux[(u32) 443] = 117;
    aux[(u32) 444] = 49;
    aux[(u32) 445] = 54;
    aux[(u32) 446] = 95;
    aux[(u32) 447] = 98;
    aux[(u32) 448] = 105;
    aux[(u32) 449] = 116;
    aux[(u32) 450] = 95;
    aux[(u32) 451] = 120;
    aux[(u32) 452] = 111;
    aux[(u32) 453] = 114;
    aux[(u32) 454] = 0;
    aux[(u32) 455] = 117;
    aux[(u32) 456] = 49;
    aux[(u32) 457] = 54;
    aux[(u32) 458] = 0;
    aux[(u32) 459] = 97;
    aux[(u32) 460] = 0;
    aux[(u32) 461] = 117;
    aux[(u32) 462] = 49;
    aux[(u32) 463] = 54;
    aux[(u32) 464] = 0;
    aux[(u32) 465] = 98;
    aux[(u32) 466] = 0;
    aux[(u32) 467] = 117;
    aux[(u32) 468] = 49;
    aux[(u32) 469] = 54;
    aux[(u32) 470] = 0;
    aux[(u32) 471] = 114;
    aux[(u32) 472] = 101;
    aux[(u32) 473] = 115;
    aux[(u32) 474] = 117;
    aux[(u32) 475] = 108;
    aux[(u32) 476] = 116;
    aux[(u32) 477] = 0;
    aux[(u32) 478] = 114;
    aux[(u32) 479] = 101;
    aux[(u32) 480] = 115;
    aux[(u32) 481] = 117;
    aux[(u32) 482] = 108;
    aux[(u32) 483] = 116;
    aux[(u32) 484] = 0;
    aux[(u32) 485] = 95;
    aux[(u32) 486] = 49;
    aux[(u32) 487] = 0;
    aux[(u32) 488] = 97;
    aux[(u32) 489] = 0;
    aux[(u32) 490] = 95;
    aux[(u32) 491] = 49;
    aux[(u32) 492] = 0;
    aux[(u32) 493] = 98;
    aux[(u32) 494] = 0;
    aux[(u32) 495] = 95;
    aux[(u32) 496] = 49;
    aux[(u32) 497] = 0;
    aux[(u32) 498] = 114;
    aux[(u32) 499] = 101;
    aux[(u32) 500] = 115;
    aux[(u32) 501] = 117;
    aux[(u32) 502] = 108;
    aux[(u32) 503] = 116;
    aux[(u32) 504] = 0;
    aux[(u32) 505] = 95;
    aux[(u32) 506] = 48;
    aux[(u32) 507] = 0;
    aux[(u32) 508] = 97;
    aux[(u32) 509] = 0;
    aux[(u32) 510] = 95;
    aux[(u32) 511] = 48;
    aux[(u32) 512] = 0;
    aux[(u32) 513] = 98;
    aux[(u32) 514] = 0;
    aux[(u32) 515] = 95;
    aux[(u32) 516] = 48;
    aux[(u32) 517] = 0;
    aux[(u32) 518] = 114;
    aux[(u32) 519] = 101;
    aux[(u32) 520] = 115;
    aux[(u32) 521] = 117;
    aux[(u32) 522] = 108;
    aux[(u32) 523] = 116;
    aux[(u32) 524] = 0;
    aux[(u32) 525] = 117;
    aux[(u32) 526] = 49;
    aux[(u32) 527] = 54;
    aux[(u32) 528] = 0;
    aux[(u32) 529] = 117;
    aux[(u32) 530] = 49;
    aux[(u32) 531] = 54;
    aux[(u32) 532] = 95;
    aux[(u32) 533] = 98;
    aux[(u32) 534] = 105;
    aux[(u32) 535] = 116;
    aux[(u32) 536] = 95;
    aux[(u32) 537] = 110;
    aux[(u32) 538] = 101;
    aux[(u32) 539] = 103;
    aux[(u32) 540] = 0;
    aux[(u32) 541] = 117;
    aux[(u32) 542] = 49;
    aux[(u32) 543] = 54;
    aux[(u32) 544] = 0;
    aux[(u32) 545] = 118;
    aux[(u32) 546] = 97;
    aux[(u32) 547] = 108;
    aux[(u32) 548] = 117;
    aux[(u32) 549] = 101;
    aux[(u32) 550] = 0;
    aux[(u32) 551] = 118;
    aux[(u32) 552] = 97;
    aux[(u32) 553] = 108;
    aux[(u32) 554] = 117;
    aux[(u32) 555] = 101;
    aux[(u32) 556] = 0;
    aux[(u32) 557] = 95;
    aux[(u32) 558] = 48;
    aux[(u32) 559] = 0;
    aux[(u32) 560] = 118;
    aux[(u32) 561] = 97;
    aux[(u32) 562] = 108;
    aux[(u32) 563] = 117;
    aux[(u32) 564] = 101;
    aux[(u32) 565] = 0;
    aux[(u32) 566] = 95;
    aux[(u32) 567] = 48;
    aux[(u32) 568] = 0;
    aux[(u32) 569] = 118;
    aux[(u32) 570] = 97;
    aux[(u32) 571] = 108;
    aux[(u32) 572] = 117;
    aux[(u32) 573] = 101;
    aux[(u32) 574] = 0;
    aux[(u32) 575] = 95;
    aux[(u32) 576] = 49;
    aux[(u32) 577] = 0;
    aux[(u32) 578] = 118;
    aux[(u32) 579] = 97;
    aux[(u32) 580] = 108;
    aux[(u32) 581] = 117;
    aux[(u32) 582] = 101;
    aux[(u32) 583] = 0;
    aux[(u32) 584] = 95;
    aux[(u32) 585] = 49;
    aux[(u32) 586] = 0;
    aux[(u32) 587] = 118;
    aux[(u32) 588] = 97;
    aux[(u32) 589] = 108;
    aux[(u32) 590] = 117;
    aux[(u32) 591] = 101;
    aux[(u32) 592] = 0;
    aux[(u32) 593] = 117;
    aux[(u32) 594] = 49;
    aux[(u32) 595] = 54;
    aux[(u32) 596] = 0;
    aux[(u32) 597] = 117;
    aux[(u32) 598] = 49;
    aux[(u32) 599] = 54;
    aux[(u32) 600] = 95;
    aux[(u32) 601] = 115;
    aux[(u32) 602] = 108;
    aux[(u32) 603] = 108;
    aux[(u32) 604] = 0;
    aux[(u32) 605] = 117;
    aux[(u32) 606] = 49;
    aux[(u32) 607] = 54;
    aux[(u32) 608] = 0;
    aux[(u32) 609] = 118;
    aux[(u32) 610] = 97;
    aux[(u32) 611] = 108;
    aux[(u32) 612] = 117;
    aux[(u32) 613] = 101;
    aux[(u32) 614] = 0;
    aux[(u32) 615] = 117;
    aux[(u32) 616] = 56;
    aux[(u32) 617] = 0;
    aux[(u32) 618] = 97;
    aux[(u32) 619] = 109;
    aux[(u32) 620] = 111;
    aux[(u32) 621] = 117;
    aux[(u32) 622] = 110;
    aux[(u32) 623] = 116;
    aux[(u32) 624] = 0;
    aux[(u32) 625] = 117;
    aux[(u32) 626] = 49;
    aux[(u32) 627] = 54;
    aux[(u32) 628] = 0;
    aux[(u32) 629] = 114;
    aux[(u32) 630] = 101;
    aux[(u32) 631] = 115;
    aux[(u32) 632] = 117;
    aux[(u32) 633] = 108;
    aux[(u32) 634] = 116;
    aux[(u32) 635] = 0;
    aux[(u32) 636] = 97;
    aux[(u32) 637] = 109;
    aux[(u32) 638] = 111;
    aux[(u32) 639] = 117;
    aux[(u32) 640] = 110;
    aux[(u32) 641] = 116;
    aux[(u32) 642] = 0;
    aux[(u32) 643] = 117;
    aux[(u32) 644] = 56;
    aux[(u32) 645] = 0;
    aux[(u32) 646] = 98;
    aux[(u32) 647] = 101;
    aux[(u32) 648] = 116;
    aux[(u32) 649] = 119;
    aux[(u32) 650] = 101;
    aux[(u32) 651] = 101;
    aux[(u32) 652] = 110;
    aux[(u32) 653] = 0;
    aux[(u32) 654] = 118;
    aux[(u32) 655] = 97;
    aux[(u32) 656] = 108;
    aux[(u32) 657] = 117;
    aux[(u32) 658] = 101;
    aux[(u32) 659] = 0;
    aux[(u32) 660] = 95;
    aux[(u32) 661] = 48;
    aux[(u32) 662] = 0;
    aux[(u32) 663] = 97;
    aux[(u32) 664] = 109;
    aux[(u32) 665] = 111;
    aux[(u32) 666] = 117;
    aux[(u32) 667] = 110;
    aux[(u32) 668] = 116;
    aux[(u32) 669] = 0;
    aux[(u32) 670] = 114;
    aux[(u32) 671] = 101;
    aux[(u32) 672] = 115;
    aux[(u32) 673] = 117;
    aux[(u32) 674] = 108;
    aux[(u32) 675] = 116;
    aux[(u32) 676] = 0;
    aux[(u32) 677] = 95;
    aux[(u32) 678] = 49;
    aux[(u32) 679] = 0;
    aux[(u32) 680] = 118;
    aux[(u32) 681] = 97;
    aux[(u32) 682] = 108;
    aux[(u32) 683] = 117;
    aux[(u32) 684] = 101;
    aux[(u32) 685] = 0;
    aux[(u32) 686] = 95;
    aux[(u32) 687] = 49;
    aux[(u32) 688] = 0;
    aux[(u32) 689] = 97;
    aux[(u32) 690] = 109;
    aux[(u32) 691] = 111;
    aux[(u32) 692] = 117;
    aux[(u32) 693] = 110;
    aux[(u32) 694] = 116;
    aux[(u32) 695] = 0;
    aux[(u32) 696] = 98;
    aux[(u32) 697] = 101;
    aux[(u32) 698] = 116;
    aux[(u32) 699] = 119;
    aux[(u32) 700] = 101;
    aux[(u32) 701] = 101;
    aux[(u32) 702] = 110;
    aux[(u32) 703] = 0;
    aux[(u32) 704] = 114;
    aux[(u32) 705] = 101;
    aux[(u32) 706] = 115;
    aux[(u32) 707] = 117;
    aux[(u32) 708] = 108;
    aux[(u32) 709] = 116;
    aux[(u32) 710] = 0;
    aux[(u32) 711] = 95;
    aux[(u32) 712] = 48;
    aux[(u32) 713] = 0;
    aux[(u32) 714] = 118;
    aux[(u32) 715] = 97;
    aux[(u32) 716] = 108;
    aux[(u32) 717] = 117;
    aux[(u32) 718] = 101;
    aux[(u32) 719] = 0;
    aux[(u32) 720] = 95;
    aux[(u32) 721] = 48;
    aux[(u32) 722] = 0;
    aux[(u32) 723] = 97;
    aux[(u32) 724] = 109;
    aux[(u32) 725] = 111;
    aux[(u32) 726] = 117;
    aux[(u32) 727] = 110;
    aux[(u32) 728] = 116;
    aux[(u32) 729] = 0;
    aux[(u32) 730] = 97;
    aux[(u32) 731] = 109;
    aux[(u32) 732] = 111;
    aux[(u32) 733] = 117;
    aux[(u32) 734] = 110;
    aux[(u32) 735] = 116;
    aux[(u32) 736] = 0;
    aux[(u32) 737] = 117;
    aux[(u32) 738] = 56;
    aux[(u32) 739] = 0;
    aux[(u32) 740] = 99;
    aux[(u32) 741] = 111;
    aux[(u32) 742] = 117;
    aux[(u32) 743] = 110;
    aux[(u32) 744] = 116;
    aux[(u32) 745] = 0;
    aux[(u32) 746] = 97;
    aux[(u32) 747] = 109;
    aux[(u32) 748] = 111;
    aux[(u32) 749] = 117;
    aux[(u32) 750] = 110;
    aux[(u32) 751] = 116;
    aux[(u32) 752] = 0;
    aux[(u32) 753] = 114;
    aux[(u32) 754] = 101;
    aux[(u32) 755] = 115;
    aux[(u32) 756] = 117;
    aux[(u32) 757] = 108;
    aux[(u32) 758] = 116;
    aux[(u32) 759] = 0;
    aux[(u32) 760] = 95;
    aux[(u32) 761] = 49;
    aux[(u32) 762] = 0;
    aux[(u32) 763] = 118;
    aux[(u32) 764] = 97;
    aux[(u32) 765] = 108;
    aux[(u32) 766] = 117;
    aux[(u32) 767] = 101;
    aux[(u32) 768] = 0;
    aux[(u32) 769] = 95;
    aux[(u32) 770] = 48;
    aux[(u32) 771] = 0;
    aux[(u32) 772] = 99;
    aux[(u32) 773] = 111;
    aux[(u32) 774] = 117;
    aux[(u32) 775] = 110;
    aux[(u32) 776] = 116;
    aux[(u32) 777] = 0;
    aux[(u32) 778] = 114;
    aux[(u32) 779] = 101;
    aux[(u32) 780] = 115;
    aux[(u32) 781] = 117;
    aux[(u32) 782] = 108;
    aux[(u32) 783] = 116;
    aux[(u32) 784] = 0;
    aux[(u32) 785] = 95;
    aux[(u32) 786] = 48;
    aux[(u32) 787] = 0;
    aux[(u32) 788] = 114;
    aux[(u32) 789] = 101;
    aux[(u32) 790] = 115;
    aux[(u32) 791] = 117;
    aux[(u32) 792] = 108;
    aux[(u32) 793] = 116;
    aux[(u32) 794] = 0;
    aux[(u32) 795] = 95;
    aux[(u32) 796] = 49;
    aux[(u32) 797] = 0;
    aux[(u32) 798] = 114;
    aux[(u32) 799] = 101;
    aux[(u32) 800] = 115;
    aux[(u32) 801] = 117;
    aux[(u32) 802] = 108;
    aux[(u32) 803] = 116;
    aux[(u32) 804] = 0;
    aux[(u32) 805] = 95;
    aux[(u32) 806] = 48;
    aux[(u32) 807] = 0;
    aux[(u32) 808] = 114;
    aux[(u32) 809] = 101;
    aux[(u32) 810] = 115;
    aux[(u32) 811] = 117;
    aux[(u32) 812] = 108;
    aux[(u32) 813] = 116;
    aux[(u32) 814] = 0;
    aux[(u32) 815] = 117;
    aux[(u32) 816] = 49;
    aux[(u32) 817] = 54;
    aux[(u32) 818] = 0;
    aux[(u32) 819] = 117;
    aux[(u32) 820] = 49;
    aux[(u32) 821] = 54;
    aux[(u32) 822] = 95;
    aux[(u32) 823] = 115;
    aux[(u32) 824] = 114;
    aux[(u32) 825] = 108;
    aux[(u32) 826] = 0;
    aux[(u32) 827] = 117;
    aux[(u32) 828] = 49;
    aux[(u32) 829] = 54;
    aux[(u32) 830] = 0;
    aux[(u32) 831] = 118;
    aux[(u32) 832] = 97;
    aux[(u32) 833] = 108;
    aux[(u32) 834] = 117;
    aux[(u32) 835] = 101;
    aux[(u32) 836] = 0;
    aux[(u32) 837] = 117;
    aux[(u32) 838] = 56;
    aux[(u32) 839] = 0;
    aux[(u32) 840] = 97;
    aux[(u32) 841] = 109;
    aux[(u32) 842] = 111;
    aux[(u32) 843] = 117;
    aux[(u32) 844] = 110;
    aux[(u32) 845] = 116;
    aux[(u32) 846] = 0;
    aux[(u32) 847] = 117;
    aux[(u32) 848] = 49;
    aux[(u32) 849] = 54;
    aux[(u32) 850] = 0;
    aux[(u32) 851] = 114;
    aux[(u32) 852] = 101;
    aux[(u32) 853] = 115;
    aux[(u32) 854] = 117;
    aux[(u32) 855] = 108;
    aux[(u32) 856] = 116;
    aux[(u32) 857] = 0;
    aux[(u32) 858] = 97;
    aux[(u32) 859] = 109;
    aux[(u32) 860] = 111;
    aux[(u32) 861] = 117;
    aux[(u32) 862] = 110;
    aux[(u32) 863] = 116;
    aux[(u32) 864] = 0;
    aux[(u32) 865] = 117;
    aux[(u32) 866] = 56;
    aux[(u32) 867] = 0;
    aux[(u32) 868] = 98;
    aux[(u32) 869] = 101;
    aux[(u32) 870] = 116;
    aux[(u32) 871] = 119;
    aux[(u32) 872] = 101;
    aux[(u32) 873] = 101;
    aux[(u32) 874] = 110;
    aux[(u32) 875] = 0;
    aux[(u32) 876] = 118;
    aux[(u32) 877] = 97;
    aux[(u32) 878] = 108;
    aux[(u32) 879] = 117;
    aux[(u32) 880] = 101;
    aux[(u32) 881] = 0;
    aux[(u32) 882] = 95;
    aux[(u32) 883] = 49;
    aux[(u32) 884] = 0;
    aux[(u32) 885] = 97;
    aux[(u32) 886] = 109;
    aux[(u32) 887] = 111;
    aux[(u32) 888] = 117;
    aux[(u32) 889] = 110;
    aux[(u32) 890] = 116;
    aux[(u32) 891] = 0;
    aux[(u32) 892] = 114;
    aux[(u32) 893] = 101;
    aux[(u32) 894] = 115;
    aux[(u32) 895] = 117;
    aux[(u32) 896] = 108;
    aux[(u32) 897] = 116;
    aux[(u32) 898] = 0;
    aux[(u32) 899] = 95;
    aux[(u32) 900] = 49;
    aux[(u32) 901] = 0;
    aux[(u32) 902] = 118;
    aux[(u32) 903] = 97;
    aux[(u32) 904] = 108;
    aux[(u32) 905] = 117;
    aux[(u32) 906] = 101;
    aux[(u32) 907] = 0;
    aux[(u32) 908] = 95;
    aux[(u32) 909] = 49;
    aux[(u32) 910] = 0;
    aux[(u32) 911] = 97;
    aux[(u32) 912] = 109;
    aux[(u32) 913] = 111;
    aux[(u32) 914] = 117;
    aux[(u32) 915] = 110;
    aux[(u32) 916] = 116;
    aux[(u32) 917] = 0;
    aux[(u32) 918] = 114;
    aux[(u32) 919] = 101;
    aux[(u32) 920] = 115;
    aux[(u32) 921] = 117;
    aux[(u32) 922] = 108;
    aux[(u32) 923] = 116;
    aux[(u32) 924] = 0;
    aux[(u32) 925] = 95;
    aux[(u32) 926] = 48;
    aux[(u32) 927] = 0;
    aux[(u32) 928] = 118;
    aux[(u32) 929] = 97;
    aux[(u32) 930] = 108;
    aux[(u32) 931] = 117;
    aux[(u32) 932] = 101;
    aux[(u32) 933] = 0;
    aux[(u32) 934] = 95;
    aux[(u32) 935] = 48;
    aux[(u32) 936] = 0;
    aux[(u32) 937] = 97;
    aux[(u32) 938] = 109;
    aux[(u32) 939] = 111;
    aux[(u32) 940] = 117;
    aux[(u32) 941] = 110;
    aux[(u32) 942] = 116;
    aux[(u32) 943] = 0;
    aux[(u32) 944] = 98;
    aux[(u32) 945] = 101;
    aux[(u32) 946] = 116;
    aux[(u32) 947] = 119;
    aux[(u32) 948] = 101;
    aux[(u32) 949] = 101;
    aux[(u32) 950] = 110;
    aux[(u32) 951] = 0;
    aux[(u32) 952] = 97;
    aux[(u32) 953] = 109;
    aux[(u32) 954] = 111;
    aux[(u32) 955] = 117;
    aux[(u32) 956] = 110;
    aux[(u32) 957] = 116;
    aux[(u32) 958] = 0;
    aux[(u32) 959] = 117;
    aux[(u32) 960] = 56;
    aux[(u32) 961] = 0;
    aux[(u32) 962] = 99;
    aux[(u32) 963] = 111;
    aux[(u32) 964] = 117;
    aux[(u32) 965] = 110;
    aux[(u32) 966] = 116;
    aux[(u32) 967] = 0;
    aux[(u32) 968] = 97;
    aux[(u32) 969] = 109;
    aux[(u32) 970] = 111;
    aux[(u32) 971] = 117;
    aux[(u32) 972] = 110;
    aux[(u32) 973] = 116;
    aux[(u32) 974] = 0;
    aux[(u32) 975] = 114;
    aux[(u32) 976] = 101;
    aux[(u32) 977] = 115;
    aux[(u32) 978] = 117;
    aux[(u32) 979] = 108;
    aux[(u32) 980] = 116;
    aux[(u32) 981] = 0;
    aux[(u32) 982] = 95;
    aux[(u32) 983] = 49;
    aux[(u32) 984] = 0;
    aux[(u32) 985] = 114;
    aux[(u32) 986] = 101;
    aux[(u32) 987] = 115;
    aux[(u32) 988] = 117;
    aux[(u32) 989] = 108;
    aux[(u32) 990] = 116;
    aux[(u32) 991] = 0;
    aux[(u32) 992] = 95;
    aux[(u32) 993] = 48;
    aux[(u32) 994] = 0;
    aux[(u32) 995] = 118;
    aux[(u32) 996] = 97;
    aux[(u32) 997] = 108;
    aux[(u32) 998] = 117;
    aux[(u32) 999] = 101;
    aux[(u32) 1000] = 0;
    aux[(u32) 1001] = 95;
    aux[(u32) 1002] = 49;
    aux[(u32) 1003] = 0;
    aux[(u32) 1004] = 99;
    aux[(u32) 1005] = 111;
    aux[(u32) 1006] = 117;
    aux[(u32) 1007] = 110;
    aux[(u32) 1008] = 116;
    aux[(u32) 1009] = 0;
    aux[(u32) 1010] = 114;
    aux[(u32) 1011] = 101;
    aux[(u32) 1012] = 115;
    aux[(u32) 1013] = 117;
    aux[(u32) 1014] = 108;
    aux[(u32) 1015] = 116;
    aux[(u32) 1016] = 0;
    aux[(u32) 1017] = 95;
    aux[(u32) 1018] = 49;
    aux[(u32) 1019] = 0;
    aux[(u32) 1020] = 114;
    aux[(u32) 1021] = 101;
    aux[(u32) 1022] = 115;
    aux[(u32) 1023] = 117;
    aux[(u32) 1024] = 108;
    aux[(u32) 1025] = 116;
    aux[(u32) 1026] = 0;
    aux[(u32) 1027] = 95;
    aux[(u32) 1028] = 48;
    aux[(u32) 1029] = 0;
    aux[(u32) 1030] = 114;
    aux[(u32) 1031] = 101;
    aux[(u32) 1032] = 115;
    aux[(u32) 1033] = 117;
    aux[(u32) 1034] = 108;
    aux[(u32) 1035] = 116;
    aux[(u32) 1036] = 0;
    aux[(u32) 1037] = 117;
    aux[(u32) 1038] = 49;
    aux[(u32) 1039] = 54;
    aux[(u32) 1040] = 0;
    aux[(u32) 1041] = 117;
    aux[(u32) 1042] = 49;
    aux[(u32) 1043] = 54;
    aux[(u32) 1044] = 95;
    aux[(u32) 1045] = 109;
    aux[(u32) 1046] = 117;
    aux[(u32) 1047] = 108;
    aux[(u32) 1048] = 0;
    aux[(u32) 1049] = 117;
    aux[(u32) 1050] = 49;
    aux[(u32) 1051] = 54;
    aux[(u32) 1052] = 0;
    aux[(u32) 1053] = 97;
    aux[(u32) 1054] = 0;
    aux[(u32) 1055] = 117;
    aux[(u32) 1056] = 49;
    aux[(u32) 1057] = 54;
    aux[(u32) 1058] = 0;
    aux[(u32) 1059] = 98;
    aux[(u32) 1060] = 0;
    aux[(u32) 1061] = 117;
    aux[(u32) 1062] = 49;
    aux[(u32) 1063] = 0;
    aux[(u32) 1064] = 97;
    aux[(u32) 1065] = 95;
    aux[(u32) 1066] = 98;
    aux[(u32) 1067] = 105;
    aux[(u32) 1068] = 116;
    aux[(u32) 1069] = 115;
    aux[(u32) 1070] = 0;
    aux[(u32) 1071] = 117;
    aux[(u32) 1072] = 56;
    aux[(u32) 1073] = 0;
    aux[(u32) 1074] = 105;
    aux[(u32) 1075] = 0;
    aux[(u32) 1076] = 105;
    aux[(u32) 1077] = 0;
    aux[(u32) 1078] = 105;
    aux[(u32) 1079] = 0;
    aux[(u32) 1080] = 97;
    aux[(u32) 1081] = 95;
    aux[(u32) 1082] = 98;
    aux[(u32) 1083] = 105;
    aux[(u32) 1084] = 116;
    aux[(u32) 1085] = 115;
    aux[(u32) 1086] = 0;
    aux[(u32) 1087] = 97;
    aux[(u32) 1088] = 95;
    aux[(u32) 1089] = 98;
    aux[(u32) 1090] = 105;
    aux[(u32) 1091] = 116;
    aux[(u32) 1092] = 115;
    aux[(u32) 1093] = 0;
    aux[(u32) 1094] = 105;
    aux[(u32) 1095] = 0;
    aux[(u32) 1096] = 117;
    aux[(u32) 1097] = 49;
    aux[(u32) 1098] = 0;
    aux[(u32) 1099] = 97;
    aux[(u32) 1100] = 0;
    aux[(u32) 1101] = 95;
    aux[(u32) 1102] = 49;
    aux[(u32) 1103] = 0;
    aux[(u32) 1104] = 105;
    aux[(u32) 1105] = 0;
    aux[(u32) 1106] = 117;
    aux[(u32) 1107] = 56;
    aux[(u32) 1108] = 0;
    aux[(u32) 1109] = 105;
    aux[(u32) 1110] = 0;
    aux[(u32) 1111] = 105;
    aux[(u32) 1112] = 0;
    aux[(u32) 1113] = 105;
    aux[(u32) 1114] = 0;
    aux[(u32) 1115] = 97;
    aux[(u32) 1116] = 95;
    aux[(u32) 1117] = 98;
    aux[(u32) 1118] = 105;
    aux[(u32) 1119] = 116;
    aux[(u32) 1120] = 115;
    aux[(u32) 1121] = 0;
    aux[(u32) 1122] = 97;
    aux[(u32) 1123] = 95;
    aux[(u32) 1124] = 98;
    aux[(u32) 1125] = 105;
    aux[(u32) 1126] = 116;
    aux[(u32) 1127] = 115;
    aux[(u32) 1128] = 0;
    aux[(u32) 1129] = 105;
    aux[(u32) 1130] = 0;
    aux[(u32) 1131] = 117;
    aux[(u32) 1132] = 49;
    aux[(u32) 1133] = 0;
    aux[(u32) 1134] = 97;
    aux[(u32) 1135] = 0;
    aux[(u32) 1136] = 95;
    aux[(u32) 1137] = 48;
    aux[(u32) 1138] = 0;
    aux[(u32) 1139] = 105;
    aux[(u32) 1140] = 0;
    aux[(u32) 1141] = 117;
    aux[(u32) 1142] = 49;
    aux[(u32) 1143] = 54;
    aux[(u32) 1144] = 0;
    aux[(u32) 1145] = 114;
    aux[(u32) 1146] = 0;
    aux[(u32) 1147] = 117;
    aux[(u32) 1148] = 56;
    aux[(u32) 1149] = 0;
    aux[(u32) 1150] = 105;
    aux[(u32) 1151] = 0;
    aux[(u32) 1152] = 105;
    aux[(u32) 1153] = 0;
    aux[(u32) 1154] = 105;
    aux[(u32) 1155] = 0;
    aux[(u32) 1156] = 97;
    aux[(u32) 1157] = 95;
    aux[(u32) 1158] = 98;
    aux[(u32) 1159] = 105;
    aux[(u32) 1160] = 116;
    aux[(u32) 1161] = 115;
    aux[(u32) 1162] = 0;
    aux[(u32) 1163] = 105;
    aux[(u32) 1164] = 0;
    aux[(u32) 1165] = 114;
    aux[(u32) 1166] = 0;
    aux[(u32) 1167] = 117;
    aux[(u32) 1168] = 49;
    aux[(u32) 1169] = 54;
    aux[(u32) 1170] = 95;
    aux[(u32) 1171] = 97;
    aux[(u32) 1172] = 100;
    aux[(u32) 1173] = 100;
    aux[(u32) 1174] = 0;
    aux[(u32) 1175] = 114;
    aux[(u32) 1176] = 0;
    aux[(u32) 1177] = 117;
    aux[(u32) 1178] = 49;
    aux[(u32) 1179] = 54;
    aux[(u32) 1180] = 95;
    aux[(u32) 1181] = 115;
    aux[(u32) 1182] = 108;
    aux[(u32) 1183] = 108;
    aux[(u32) 1184] = 0;
    aux[(u32) 1185] = 98;
    aux[(u32) 1186] = 0;
    aux[(u32) 1187] = 105;
    aux[(u32) 1188] = 0;
    aux[(u32) 1189] = 114;
    aux[(u32) 1190] = 0;
    aux[(u32) 1191] = 117;
    aux[(u32) 1192] = 49;
    aux[(u32) 1193] = 0;
    aux[(u32) 1194] = 117;
    aux[(u32) 1195] = 49;
    aux[(u32) 1196] = 54;
    aux[(u32) 1197] = 95;
    aux[(u32) 1198] = 101;
    aux[(u32) 1199] = 113;
    aux[(u32) 1200] = 0;
    aux[(u32) 1201] = 117;
    aux[(u32) 1202] = 49;
    aux[(u32) 1203] = 54;
    aux[(u32) 1204] = 0;
    aux[(u32) 1205] = 97;
    aux[(u32) 1206] = 0;
    aux[(u32) 1207] = 117;
    aux[(u32) 1208] = 49;
    aux[(u32) 1209] = 54;
    aux[(u32) 1210] = 0;
    aux[(u32) 1211] = 98;
    aux[(u32) 1212] = 0;
    aux[(u32) 1213] = 97;
    aux[(u32) 1214] = 0;
    aux[(u32) 1215] = 95;
    aux[(u32) 1216] = 48;
    aux[(u32) 1217] = 0;
    aux[(u32) 1218] = 98;
    aux[(u32) 1219] = 0;
    aux[(u32) 1220] = 95;
    aux[(u32) 1221] = 48;
    aux[(u32) 1222] = 0;
    aux[(u32) 1223] = 97;
    aux[(u32) 1224] = 0;
    aux[(u32) 1225] = 95;
    aux[(u32) 1226] = 49;
    aux[(u32) 1227] = 0;
    aux[(u32) 1228] = 98;
    aux[(u32) 1229] = 0;
    aux[(u32) 1230] = 95;
    aux[(u32) 1231] = 49;
    aux[(u32) 1232] = 0;
    aux[(u32) 1233] = 117;
    aux[(u32) 1234] = 49;
    aux[(u32) 1235] = 54;
    aux[(u32) 1236] = 0;
    aux[(u32) 1237] = 117;
    aux[(u32) 1238] = 49;
    aux[(u32) 1239] = 54;
    aux[(u32) 1240] = 95;
    aux[(u32) 1241] = 100;
    aux[(u32) 1242] = 105;
    aux[(u32) 1243] = 118;
    aux[(u32) 1244] = 0;
    aux[(u32) 1245] = 117;
    aux[(u32) 1246] = 49;
    aux[(u32) 1247] = 54;
    aux[(u32) 1248] = 0;
    aux[(u32) 1249] = 97;
    aux[(u32) 1250] = 0;
    aux[(u32) 1251] = 117;
    aux[(u32) 1252] = 49;
    aux[(u32) 1253] = 54;
    aux[(u32) 1254] = 0;
    aux[(u32) 1255] = 98;
    aux[(u32) 1256] = 0;
    aux[(u32) 1257] = 117;
    aux[(u32) 1258] = 49;
    aux[(u32) 1259] = 54;
    aux[(u32) 1260] = 0;
    aux[(u32) 1261] = 114;
    aux[(u32) 1262] = 0;
    aux[(u32) 1263] = 117;
    aux[(u32) 1264] = 49;
    aux[(u32) 1265] = 54;
    aux[(u32) 1266] = 95;
    aux[(u32) 1267] = 101;
    aux[(u32) 1268] = 113;
    aux[(u32) 1269] = 0;
    aux[(u32) 1270] = 98;
    aux[(u32) 1271] = 0;
    aux[(u32) 1272] = 114;
    aux[(u32) 1273] = 0;
    aux[(u32) 1274] = 97;
    aux[(u32) 1275] = 0;
    aux[(u32) 1276] = 117;
    aux[(u32) 1277] = 49;
    aux[(u32) 1278] = 54;
    aux[(u32) 1279] = 95;
    aux[(u32) 1280] = 101;
    aux[(u32) 1281] = 113;
    aux[(u32) 1282] = 0;
    aux[(u32) 1283] = 98;
    aux[(u32) 1284] = 0;
    aux[(u32) 1285] = 114;
    aux[(u32) 1286] = 0;
    aux[(u32) 1287] = 97;
    aux[(u32) 1288] = 0;
    aux[(u32) 1289] = 97;
    aux[(u32) 1290] = 0;
    aux[(u32) 1291] = 117;
    aux[(u32) 1292] = 49;
    aux[(u32) 1293] = 54;
    aux[(u32) 1294] = 0;
    aux[(u32) 1295] = 108;
    aux[(u32) 1296] = 105;
    aux[(u32) 1297] = 109;
    aux[(u32) 1298] = 105;
    aux[(u32) 1299] = 116;
    aux[(u32) 1300] = 115;
    aux[(u32) 1301] = 0;
    aux[(u32) 1302] = 117;
    aux[(u32) 1303] = 49;
    aux[(u32) 1304] = 54;
    aux[(u32) 1305] = 0;
    aux[(u32) 1306] = 109;
    aux[(u32) 1307] = 117;
    aux[(u32) 1308] = 108;
    aux[(u32) 1309] = 116;
    aux[(u32) 1310] = 105;
    aux[(u32) 1311] = 112;
    aux[(u32) 1312] = 108;
    aux[(u32) 1313] = 105;
    aux[(u32) 1314] = 101;
    aux[(u32) 1315] = 114;
    aux[(u32) 1316] = 115;
    aux[(u32) 1317] = 0;
    aux[(u32) 1318] = 108;
    aux[(u32) 1319] = 105;
    aux[(u32) 1320] = 109;
    aux[(u32) 1321] = 105;
    aux[(u32) 1322] = 116;
    aux[(u32) 1323] = 115;
    aux[(u32) 1324] = 0;
    aux[(u32) 1325] = 109;
    aux[(u32) 1326] = 117;
    aux[(u32) 1327] = 108;
    aux[(u32) 1328] = 116;
    aux[(u32) 1329] = 105;
    aux[(u32) 1330] = 112;
    aux[(u32) 1331] = 108;
    aux[(u32) 1332] = 105;
    aux[(u32) 1333] = 101;
    aux[(u32) 1334] = 114;
    aux[(u32) 1335] = 115;
    aux[(u32) 1336] = 0;
    aux[(u32) 1337] = 108;
    aux[(u32) 1338] = 105;
    aux[(u32) 1339] = 109;
    aux[(u32) 1340] = 105;
    aux[(u32) 1341] = 116;
    aux[(u32) 1342] = 115;
    aux[(u32) 1343] = 0;
    aux[(u32) 1344] = 109;
    aux[(u32) 1345] = 117;
    aux[(u32) 1346] = 108;
    aux[(u32) 1347] = 116;
    aux[(u32) 1348] = 105;
    aux[(u32) 1349] = 112;
    aux[(u32) 1350] = 108;
    aux[(u32) 1351] = 105;
    aux[(u32) 1352] = 101;
    aux[(u32) 1353] = 114;
    aux[(u32) 1354] = 115;
    aux[(u32) 1355] = 0;
    aux[(u32) 1356] = 108;
    aux[(u32) 1357] = 105;
    aux[(u32) 1358] = 109;
    aux[(u32) 1359] = 105;
    aux[(u32) 1360] = 116;
    aux[(u32) 1361] = 115;
    aux[(u32) 1362] = 0;
    aux[(u32) 1363] = 109;
    aux[(u32) 1364] = 117;
    aux[(u32) 1365] = 108;
    aux[(u32) 1366] = 116;
    aux[(u32) 1367] = 105;
    aux[(u32) 1368] = 112;
    aux[(u32) 1369] = 108;
    aux[(u32) 1370] = 105;
    aux[(u32) 1371] = 101;
    aux[(u32) 1372] = 114;
    aux[(u32) 1373] = 115;
    aux[(u32) 1374] = 0;
    aux[(u32) 1375] = 108;
    aux[(u32) 1376] = 105;
    aux[(u32) 1377] = 109;
    aux[(u32) 1378] = 105;
    aux[(u32) 1379] = 116;
    aux[(u32) 1380] = 115;
    aux[(u32) 1381] = 0;
    aux[(u32) 1382] = 109;
    aux[(u32) 1383] = 117;
    aux[(u32) 1384] = 108;
    aux[(u32) 1385] = 116;
    aux[(u32) 1386] = 105;
    aux[(u32) 1387] = 112;
    aux[(u32) 1388] = 108;
    aux[(u32) 1389] = 105;
    aux[(u32) 1390] = 101;
    aux[(u32) 1391] = 114;
    aux[(u32) 1392] = 115;
    aux[(u32) 1393] = 0;
    aux[(u32) 1394] = 108;
    aux[(u32) 1395] = 105;
    aux[(u32) 1396] = 109;
    aux[(u32) 1397] = 105;
    aux[(u32) 1398] = 116;
    aux[(u32) 1399] = 115;
    aux[(u32) 1400] = 0;
    aux[(u32) 1401] = 109;
    aux[(u32) 1402] = 117;
    aux[(u32) 1403] = 108;
    aux[(u32) 1404] = 116;
    aux[(u32) 1405] = 105;
    aux[(u32) 1406] = 112;
    aux[(u32) 1407] = 108;
    aux[(u32) 1408] = 105;
    aux[(u32) 1409] = 101;
    aux[(u32) 1410] = 114;
    aux[(u32) 1411] = 115;
    aux[(u32) 1412] = 0;
    aux[(u32) 1413] = 108;
    aux[(u32) 1414] = 105;
    aux[(u32) 1415] = 109;
    aux[(u32) 1416] = 105;
    aux[(u32) 1417] = 116;
    aux[(u32) 1418] = 115;
    aux[(u32) 1419] = 0;
    aux[(u32) 1420] = 109;
    aux[(u32) 1421] = 117;
    aux[(u32) 1422] = 108;
    aux[(u32) 1423] = 116;
    aux[(u32) 1424] = 105;
    aux[(u32) 1425] = 112;
    aux[(u32) 1426] = 108;
    aux[(u32) 1427] = 105;
    aux[(u32) 1428] = 101;
    aux[(u32) 1429] = 114;
    aux[(u32) 1430] = 115;
    aux[(u32) 1431] = 0;
    aux[(u32) 1432] = 108;
    aux[(u32) 1433] = 105;
    aux[(u32) 1434] = 109;
    aux[(u32) 1435] = 105;
    aux[(u32) 1436] = 116;
    aux[(u32) 1437] = 115;
    aux[(u32) 1438] = 0;
    aux[(u32) 1439] = 109;
    aux[(u32) 1440] = 117;
    aux[(u32) 1441] = 108;
    aux[(u32) 1442] = 116;
    aux[(u32) 1443] = 105;
    aux[(u32) 1444] = 112;
    aux[(u32) 1445] = 108;
    aux[(u32) 1446] = 105;
    aux[(u32) 1447] = 101;
    aux[(u32) 1448] = 114;
    aux[(u32) 1449] = 115;
    aux[(u32) 1450] = 0;
    aux[(u32) 1451] = 108;
    aux[(u32) 1452] = 105;
    aux[(u32) 1453] = 109;
    aux[(u32) 1454] = 105;
    aux[(u32) 1455] = 116;
    aux[(u32) 1456] = 115;
    aux[(u32) 1457] = 0;
    aux[(u32) 1458] = 109;
    aux[(u32) 1459] = 117;
    aux[(u32) 1460] = 108;
    aux[(u32) 1461] = 116;
    aux[(u32) 1462] = 105;
    aux[(u32) 1463] = 112;
    aux[(u32) 1464] = 108;
    aux[(u32) 1465] = 105;
    aux[(u32) 1466] = 101;
    aux[(u32) 1467] = 114;
    aux[(u32) 1468] = 115;
    aux[(u32) 1469] = 0;
    aux[(u32) 1470] = 108;
    aux[(u32) 1471] = 105;
    aux[(u32) 1472] = 109;
    aux[(u32) 1473] = 105;
    aux[(u32) 1474] = 116;
    aux[(u32) 1475] = 115;
    aux[(u32) 1476] = 0;
    aux[(u32) 1477] = 109;
    aux[(u32) 1478] = 117;
    aux[(u32) 1479] = 108;
    aux[(u32) 1480] = 116;
    aux[(u32) 1481] = 105;
    aux[(u32) 1482] = 112;
    aux[(u32) 1483] = 108;
    aux[(u32) 1484] = 105;
    aux[(u32) 1485] = 101;
    aux[(u32) 1486] = 114;
    aux[(u32) 1487] = 115;
    aux[(u32) 1488] = 0;
    aux[(u32) 1489] = 108;
    aux[(u32) 1490] = 105;
    aux[(u32) 1491] = 109;
    aux[(u32) 1492] = 105;
    aux[(u32) 1493] = 116;
    aux[(u32) 1494] = 115;
    aux[(u32) 1495] = 0;
    aux[(u32) 1496] = 109;
    aux[(u32) 1497] = 117;
    aux[(u32) 1498] = 108;
    aux[(u32) 1499] = 116;
    aux[(u32) 1500] = 105;
    aux[(u32) 1501] = 112;
    aux[(u32) 1502] = 108;
    aux[(u32) 1503] = 105;
    aux[(u32) 1504] = 101;
    aux[(u32) 1505] = 114;
    aux[(u32) 1506] = 115;
    aux[(u32) 1507] = 0;
    aux[(u32) 1508] = 108;
    aux[(u32) 1509] = 105;
    aux[(u32) 1510] = 109;
    aux[(u32) 1511] = 105;
    aux[(u32) 1512] = 116;
    aux[(u32) 1513] = 115;
    aux[(u32) 1514] = 0;
    aux[(u32) 1515] = 109;
    aux[(u32) 1516] = 117;
    aux[(u32) 1517] = 108;
    aux[(u32) 1518] = 116;
    aux[(u32) 1519] = 105;
    aux[(u32) 1520] = 112;
    aux[(u32) 1521] = 108;
    aux[(u32) 1522] = 105;
    aux[(u32) 1523] = 101;
    aux[(u32) 1524] = 114;
    aux[(u32) 1525] = 115;
    aux[(u32) 1526] = 0;
    aux[(u32) 1527] = 108;
    aux[(u32) 1528] = 105;
    aux[(u32) 1529] = 109;
    aux[(u32) 1530] = 105;
    aux[(u32) 1531] = 116;
    aux[(u32) 1532] = 115;
    aux[(u32) 1533] = 0;
    aux[(u32) 1534] = 109;
    aux[(u32) 1535] = 117;
    aux[(u32) 1536] = 108;
    aux[(u32) 1537] = 116;
    aux[(u32) 1538] = 105;
    aux[(u32) 1539] = 112;
    aux[(u32) 1540] = 108;
    aux[(u32) 1541] = 105;
    aux[(u32) 1542] = 101;
    aux[(u32) 1543] = 114;
    aux[(u32) 1544] = 115;
    aux[(u32) 1545] = 0;
    aux[(u32) 1546] = 108;
    aux[(u32) 1547] = 105;
    aux[(u32) 1548] = 109;
    aux[(u32) 1549] = 105;
    aux[(u32) 1550] = 116;
    aux[(u32) 1551] = 115;
    aux[(u32) 1552] = 0;
    aux[(u32) 1553] = 109;
    aux[(u32) 1554] = 117;
    aux[(u32) 1555] = 108;
    aux[(u32) 1556] = 116;
    aux[(u32) 1557] = 105;
    aux[(u32) 1558] = 112;
    aux[(u32) 1559] = 108;
    aux[(u32) 1560] = 105;
    aux[(u32) 1561] = 101;
    aux[(u32) 1562] = 114;
    aux[(u32) 1563] = 115;
    aux[(u32) 1564] = 0;
    aux[(u32) 1565] = 108;
    aux[(u32) 1566] = 105;
    aux[(u32) 1567] = 109;
    aux[(u32) 1568] = 105;
    aux[(u32) 1569] = 116;
    aux[(u32) 1570] = 115;
    aux[(u32) 1571] = 0;
    aux[(u32) 1572] = 109;
    aux[(u32) 1573] = 117;
    aux[(u32) 1574] = 108;
    aux[(u32) 1575] = 116;
    aux[(u32) 1576] = 105;
    aux[(u32) 1577] = 112;
    aux[(u32) 1578] = 108;
    aux[(u32) 1579] = 105;
    aux[(u32) 1580] = 101;
    aux[(u32) 1581] = 114;
    aux[(u32) 1582] = 115;
    aux[(u32) 1583] = 0;
    aux[(u32) 1584] = 117;
    aux[(u32) 1585] = 56;
    aux[(u32) 1586] = 0;
    aux[(u32) 1587] = 105;
    aux[(u32) 1588] = 0;
    aux[(u32) 1589] = 105;
    aux[(u32) 1590] = 0;
    aux[(u32) 1591] = 105;
    aux[(u32) 1592] = 0;
    aux[(u32) 1593] = 117;
    aux[(u32) 1594] = 49;
    aux[(u32) 1595] = 54;
    aux[(u32) 1596] = 95;
    aux[(u32) 1597] = 108;
    aux[(u32) 1598] = 116;
    aux[(u32) 1599] = 0;
    aux[(u32) 1600] = 98;
    aux[(u32) 1601] = 0;
    aux[(u32) 1602] = 108;
    aux[(u32) 1603] = 105;
    aux[(u32) 1604] = 109;
    aux[(u32) 1605] = 105;
    aux[(u32) 1606] = 116;
    aux[(u32) 1607] = 115;
    aux[(u32) 1608] = 0;
    aux[(u32) 1609] = 105;
    aux[(u32) 1610] = 0;
    aux[(u32) 1611] = 117;
    aux[(u32) 1612] = 49;
    aux[(u32) 1613] = 54;
    aux[(u32) 1614] = 0;
    aux[(u32) 1615] = 109;
    aux[(u32) 1616] = 117;
    aux[(u32) 1617] = 108;
    aux[(u32) 1618] = 116;
    aux[(u32) 1619] = 105;
    aux[(u32) 1620] = 112;
    aux[(u32) 1621] = 108;
    aux[(u32) 1622] = 105;
    aux[(u32) 1623] = 101;
    aux[(u32) 1624] = 114;
    aux[(u32) 1625] = 0;
    aux[(u32) 1626] = 109;
    aux[(u32) 1627] = 117;
    aux[(u32) 1628] = 108;
    aux[(u32) 1629] = 116;
    aux[(u32) 1630] = 105;
    aux[(u32) 1631] = 112;
    aux[(u32) 1632] = 108;
    aux[(u32) 1633] = 105;
    aux[(u32) 1634] = 101;
    aux[(u32) 1635] = 114;
    aux[(u32) 1636] = 115;
    aux[(u32) 1637] = 0;
    aux[(u32) 1638] = 105;
    aux[(u32) 1639] = 0;
    aux[(u32) 1640] = 117;
    aux[(u32) 1641] = 49;
    aux[(u32) 1642] = 54;
    aux[(u32) 1643] = 0;
    aux[(u32) 1644] = 115;
    aux[(u32) 1645] = 99;
    aux[(u32) 1646] = 97;
    aux[(u32) 1647] = 108;
    aux[(u32) 1648] = 101;
    aux[(u32) 1649] = 100;
    aux[(u32) 1650] = 0;
    aux[(u32) 1651] = 117;
    aux[(u32) 1652] = 49;
    aux[(u32) 1653] = 54;
    aux[(u32) 1654] = 95;
    aux[(u32) 1655] = 109;
    aux[(u32) 1656] = 117;
    aux[(u32) 1657] = 108;
    aux[(u32) 1658] = 0;
    aux[(u32) 1659] = 109;
    aux[(u32) 1660] = 117;
    aux[(u32) 1661] = 108;
    aux[(u32) 1662] = 116;
    aux[(u32) 1663] = 105;
    aux[(u32) 1664] = 112;
    aux[(u32) 1665] = 108;
    aux[(u32) 1666] = 105;
    aux[(u32) 1667] = 101;
    aux[(u32) 1668] = 114;
    aux[(u32) 1669] = 0;
    aux[(u32) 1670] = 98;
    aux[(u32) 1671] = 0;
    aux[(u32) 1672] = 117;
    aux[(u32) 1673] = 49;
    aux[(u32) 1674] = 54;
    aux[(u32) 1675] = 95;
    aux[(u32) 1676] = 103;
    aux[(u32) 1677] = 116;
    aux[(u32) 1678] = 101;
    aux[(u32) 1679] = 0;
    aux[(u32) 1680] = 97;
    aux[(u32) 1681] = 0;
    aux[(u32) 1682] = 115;
    aux[(u32) 1683] = 99;
    aux[(u32) 1684] = 97;
    aux[(u32) 1685] = 108;
    aux[(u32) 1686] = 101;
    aux[(u32) 1687] = 100;
    aux[(u32) 1688] = 0;
    aux[(u32) 1689] = 97;
    aux[(u32) 1690] = 0;
    aux[(u32) 1691] = 117;
    aux[(u32) 1692] = 49;
    aux[(u32) 1693] = 54;
    aux[(u32) 1694] = 95;
    aux[(u32) 1695] = 115;
    aux[(u32) 1696] = 117;
    aux[(u32) 1697] = 98;
    aux[(u32) 1698] = 0;
    aux[(u32) 1699] = 97;
    aux[(u32) 1700] = 0;
    aux[(u32) 1701] = 115;
    aux[(u32) 1702] = 99;
    aux[(u32) 1703] = 97;
    aux[(u32) 1704] = 108;
    aux[(u32) 1705] = 101;
    aux[(u32) 1706] = 100;
    aux[(u32) 1707] = 0;
    aux[(u32) 1708] = 114;
    aux[(u32) 1709] = 0;
    aux[(u32) 1710] = 117;
    aux[(u32) 1711] = 49;
    aux[(u32) 1712] = 54;
    aux[(u32) 1713] = 95;
    aux[(u32) 1714] = 97;
    aux[(u32) 1715] = 100;
    aux[(u32) 1716] = 100;
    aux[(u32) 1717] = 0;
    aux[(u32) 1718] = 114;
    aux[(u32) 1719] = 0;
    aux[(u32) 1720] = 109;
    aux[(u32) 1721] = 117;
    aux[(u32) 1722] = 108;
    aux[(u32) 1723] = 116;
    aux[(u32) 1724] = 105;
    aux[(u32) 1725] = 112;
    aux[(u32) 1726] = 108;
    aux[(u32) 1727] = 105;
    aux[(u32) 1728] = 101;
    aux[(u32) 1729] = 114;
    aux[(u32) 1730] = 0;
    aux[(u32) 1731] = 117;
    aux[(u32) 1732] = 49;
    aux[(u32) 1733] = 54;
    aux[(u32) 1734] = 95;
    aux[(u32) 1735] = 103;
    aux[(u32) 1736] = 116;
    aux[(u32) 1737] = 101;
    aux[(u32) 1738] = 0;
    aux[(u32) 1739] = 97;
    aux[(u32) 1740] = 0;
    aux[(u32) 1741] = 98;
    aux[(u32) 1742] = 0;
    aux[(u32) 1743] = 97;
    aux[(u32) 1744] = 0;
    aux[(u32) 1745] = 117;
    aux[(u32) 1746] = 49;
    aux[(u32) 1747] = 54;
    aux[(u32) 1748] = 95;
    aux[(u32) 1749] = 115;
    aux[(u32) 1750] = 117;
    aux[(u32) 1751] = 98;
    aux[(u32) 1752] = 0;
    aux[(u32) 1753] = 97;
    aux[(u32) 1754] = 0;
    aux[(u32) 1755] = 98;
    aux[(u32) 1756] = 0;
    aux[(u32) 1757] = 114;
    aux[(u32) 1758] = 0;
    aux[(u32) 1759] = 117;
    aux[(u32) 1760] = 49;
    aux[(u32) 1761] = 54;
    aux[(u32) 1762] = 95;
    aux[(u32) 1763] = 97;
    aux[(u32) 1764] = 100;
    aux[(u32) 1765] = 100;
    aux[(u32) 1766] = 0;
    aux[(u32) 1767] = 114;
    aux[(u32) 1768] = 0;
    aux[(u32) 1769] = 114;
    aux[(u32) 1770] = 0;
    aux[(u32) 1771] = 117;
    aux[(u32) 1772] = 49;
    aux[(u32) 1773] = 54;
    aux[(u32) 1774] = 0;
    aux[(u32) 1775] = 117;
    aux[(u32) 1776] = 49;
    aux[(u32) 1777] = 54;
    aux[(u32) 1778] = 95;
    aux[(u32) 1779] = 109;
    aux[(u32) 1780] = 111;
    aux[(u32) 1781] = 100;
    aux[(u32) 1782] = 0;
    aux[(u32) 1783] = 117;
    aux[(u32) 1784] = 49;
    aux[(u32) 1785] = 54;
    aux[(u32) 1786] = 0;
    aux[(u32) 1787] = 97;
    aux[(u32) 1788] = 0;
    aux[(u32) 1789] = 117;
    aux[(u32) 1790] = 49;
    aux[(u32) 1791] = 54;
    aux[(u32) 1792] = 0;
    aux[(u32) 1793] = 98;
    aux[(u32) 1794] = 0;
    aux[(u32) 1795] = 117;
    aux[(u32) 1796] = 49;
    aux[(u32) 1797] = 54;
    aux[(u32) 1798] = 95;
    aux[(u32) 1799] = 115;
    aux[(u32) 1800] = 117;
    aux[(u32) 1801] = 98;
    aux[(u32) 1802] = 0;
    aux[(u32) 1803] = 97;
    aux[(u32) 1804] = 0;
    aux[(u32) 1805] = 117;
    aux[(u32) 1806] = 49;
    aux[(u32) 1807] = 54;
    aux[(u32) 1808] = 95;
    aux[(u32) 1809] = 109;
    aux[(u32) 1810] = 117;
    aux[(u32) 1811] = 108;
    aux[(u32) 1812] = 0;
    aux[(u32) 1813] = 117;
    aux[(u32) 1814] = 49;
    aux[(u32) 1815] = 54;
    aux[(u32) 1816] = 95;
    aux[(u32) 1817] = 100;
    aux[(u32) 1818] = 105;
    aux[(u32) 1819] = 118;
    aux[(u32) 1820] = 0;
    aux[(u32) 1821] = 97;
    aux[(u32) 1822] = 0;
    aux[(u32) 1823] = 98;
    aux[(u32) 1824] = 0;
    aux[(u32) 1825] = 98;
    aux[(u32) 1826] = 0;
    aux[(u32) 1827] = 117;
    aux[(u32) 1828] = 49;
    aux[(u32) 1829] = 0;
    aux[(u32) 1830] = 117;
    aux[(u32) 1831] = 49;
    aux[(u32) 1832] = 54;
    aux[(u32) 1833] = 95;
    aux[(u32) 1834] = 103;
    aux[(u32) 1835] = 116;
    aux[(u32) 1836] = 0;
    aux[(u32) 1837] = 117;
    aux[(u32) 1838] = 49;
    aux[(u32) 1839] = 54;
    aux[(u32) 1840] = 0;
    aux[(u32) 1841] = 97;
    aux[(u32) 1842] = 0;
    aux[(u32) 1843] = 117;
    aux[(u32) 1844] = 49;
    aux[(u32) 1845] = 54;
    aux[(u32) 1846] = 0;
    aux[(u32) 1847] = 98;
    aux[(u32) 1848] = 0;
    aux[(u32) 1849] = 97;
    aux[(u32) 1850] = 0;
    aux[(u32) 1851] = 95;
    aux[(u32) 1852] = 49;
    aux[(u32) 1853] = 0;
    aux[(u32) 1854] = 98;
    aux[(u32) 1855] = 0;
    aux[(u32) 1856] = 95;
    aux[(u32) 1857] = 49;
    aux[(u32) 1858] = 0;
    aux[(u32) 1859] = 97;
    aux[(u32) 1860] = 0;
    aux[(u32) 1861] = 95;
    aux[(u32) 1862] = 49;
    aux[(u32) 1863] = 0;
    aux[(u32) 1864] = 98;
    aux[(u32) 1865] = 0;
    aux[(u32) 1866] = 95;
    aux[(u32) 1867] = 49;
    aux[(u32) 1868] = 0;
    aux[(u32) 1869] = 97;
    aux[(u32) 1870] = 0;
    aux[(u32) 1871] = 95;
    aux[(u32) 1872] = 48;
    aux[(u32) 1873] = 0;
    aux[(u32) 1874] = 98;
    aux[(u32) 1875] = 0;
    aux[(u32) 1876] = 95;
    aux[(u32) 1877] = 48;
    aux[(u32) 1878] = 0;
    aux[(u32) 1879] = 117;
    aux[(u32) 1880] = 49;
    aux[(u32) 1881] = 0;
    aux[(u32) 1882] = 117;
    aux[(u32) 1883] = 49;
    aux[(u32) 1884] = 54;
    aux[(u32) 1885] = 95;
    aux[(u32) 1886] = 103;
    aux[(u32) 1887] = 116;
    aux[(u32) 1888] = 101;
    aux[(u32) 1889] = 0;
    aux[(u32) 1890] = 117;
    aux[(u32) 1891] = 49;
    aux[(u32) 1892] = 54;
    aux[(u32) 1893] = 0;
    aux[(u32) 1894] = 97;
    aux[(u32) 1895] = 0;
    aux[(u32) 1896] = 117;
    aux[(u32) 1897] = 49;
    aux[(u32) 1898] = 54;
    aux[(u32) 1899] = 0;
    aux[(u32) 1900] = 98;
    aux[(u32) 1901] = 0;
    aux[(u32) 1902] = 97;
    aux[(u32) 1903] = 0;
    aux[(u32) 1904] = 95;
    aux[(u32) 1905] = 49;
    aux[(u32) 1906] = 0;
    aux[(u32) 1907] = 98;
    aux[(u32) 1908] = 0;
    aux[(u32) 1909] = 95;
    aux[(u32) 1910] = 49;
    aux[(u32) 1911] = 0;
    aux[(u32) 1912] = 97;
    aux[(u32) 1913] = 0;
    aux[(u32) 1914] = 95;
    aux[(u32) 1915] = 49;
    aux[(u32) 1916] = 0;
    aux[(u32) 1917] = 98;
    aux[(u32) 1918] = 0;
    aux[(u32) 1919] = 95;
    aux[(u32) 1920] = 49;
    aux[(u32) 1921] = 0;
    aux[(u32) 1922] = 97;
    aux[(u32) 1923] = 0;
    aux[(u32) 1924] = 95;
    aux[(u32) 1925] = 48;
    aux[(u32) 1926] = 0;
    aux[(u32) 1927] = 98;
    aux[(u32) 1928] = 0;
    aux[(u32) 1929] = 95;
    aux[(u32) 1930] = 48;
    aux[(u32) 1931] = 0;
    aux[(u32) 1932] = 117;
    aux[(u32) 1933] = 49;
    aux[(u32) 1934] = 0;
    aux[(u32) 1935] = 117;
    aux[(u32) 1936] = 49;
    aux[(u32) 1937] = 54;
    aux[(u32) 1938] = 95;
    aux[(u32) 1939] = 108;
    aux[(u32) 1940] = 116;
    aux[(u32) 1941] = 0;
    aux[(u32) 1942] = 117;
    aux[(u32) 1943] = 49;
    aux[(u32) 1944] = 54;
    aux[(u32) 1945] = 0;
    aux[(u32) 1946] = 97;
    aux[(u32) 1947] = 0;
    aux[(u32) 1948] = 117;
    aux[(u32) 1949] = 49;
    aux[(u32) 1950] = 54;
    aux[(u32) 1951] = 0;
    aux[(u32) 1952] = 98;
    aux[(u32) 1953] = 0;
    aux[(u32) 1954] = 97;
    aux[(u32) 1955] = 0;
    aux[(u32) 1956] = 95;
    aux[(u32) 1957] = 49;
    aux[(u32) 1958] = 0;
    aux[(u32) 1959] = 98;
    aux[(u32) 1960] = 0;
    aux[(u32) 1961] = 95;
    aux[(u32) 1962] = 49;
    aux[(u32) 1963] = 0;
    aux[(u32) 1964] = 97;
    aux[(u32) 1965] = 0;
    aux[(u32) 1966] = 95;
    aux[(u32) 1967] = 49;
    aux[(u32) 1968] = 0;
    aux[(u32) 1969] = 98;
    aux[(u32) 1970] = 0;
    aux[(u32) 1971] = 95;
    aux[(u32) 1972] = 49;
    aux[(u32) 1973] = 0;
    aux[(u32) 1974] = 97;
    aux[(u32) 1975] = 0;
    aux[(u32) 1976] = 95;
    aux[(u32) 1977] = 48;
    aux[(u32) 1978] = 0;
    aux[(u32) 1979] = 98;
    aux[(u32) 1980] = 0;
    aux[(u32) 1981] = 95;
    aux[(u32) 1982] = 48;
    aux[(u32) 1983] = 0;
    aux[(u32) 1984] = 117;
    aux[(u32) 1985] = 49;
    aux[(u32) 1986] = 0;
    aux[(u32) 1987] = 117;
    aux[(u32) 1988] = 49;
    aux[(u32) 1989] = 54;
    aux[(u32) 1990] = 95;
    aux[(u32) 1991] = 108;
    aux[(u32) 1992] = 116;
    aux[(u32) 1993] = 101;
    aux[(u32) 1994] = 0;
    aux[(u32) 1995] = 117;
    aux[(u32) 1996] = 49;
    aux[(u32) 1997] = 54;
    aux[(u32) 1998] = 0;
    aux[(u32) 1999] = 97;
    aux[(u32) 2000] = 0;
    aux[(u32) 2001] = 117;
    aux[(u32) 2002] = 49;
    aux[(u32) 2003] = 54;
    aux[(u32) 2004] = 0;
    aux[(u32) 2005] = 98;
    aux[(u32) 2006] = 0;
    aux[(u32) 2007] = 97;
    aux[(u32) 2008] = 0;
    aux[(u32) 2009] = 95;
    aux[(u32) 2010] = 49;
    aux[(u32) 2011] = 0;
    aux[(u32) 2012] = 98;
    aux[(u32) 2013] = 0;
    aux[(u32) 2014] = 95;
    aux[(u32) 2015] = 49;
    aux[(u32) 2016] = 0;
    aux[(u32) 2017] = 97;
    aux[(u32) 2018] = 0;
    aux[(u32) 2019] = 95;
    aux[(u32) 2020] = 49;
    aux[(u32) 2021] = 0;
    aux[(u32) 2022] = 98;
    aux[(u32) 2023] = 0;
    aux[(u32) 2024] = 95;
    aux[(u32) 2025] = 49;
    aux[(u32) 2026] = 0;
    aux[(u32) 2027] = 97;
    aux[(u32) 2028] = 0;
    aux[(u32) 2029] = 95;
    aux[(u32) 2030] = 48;
    aux[(u32) 2031] = 0;
    aux[(u32) 2032] = 98;
    aux[(u32) 2033] = 0;
    aux[(u32) 2034] = 95;
    aux[(u32) 2035] = 48;
    aux[(u32) 2036] = 0;
    aux[(u32) 2037] = 117;
    aux[(u32) 2038] = 48;
    aux[(u32) 2039] = 0;
    aux[(u32) 2040] = 112;
    aux[(u32) 2041] = 114;
    aux[(u32) 2042] = 105;
    aux[(u32) 2043] = 110;
    aux[(u32) 2044] = 116;
    aux[(u32) 2045] = 104;
    aux[(u32) 2046] = 101;
    aux[(u32) 2047] = 120;
    aux[(u32) 2048] = 100;
    aux[(u32) 2049] = 105;
    aux[(u32) 2050] = 103;
    aux[(u32) 2051] = 105;
    aux[(u32) 2052] = 116;
    aux[(u32) 2053] = 0;
    aux[(u32) 2054] = 117;
    aux[(u32) 2055] = 56;
    aux[(u32) 2056] = 0;
    aux[(u32) 2057] = 100;
    aux[(u32) 2058] = 105;
    aux[(u32) 2059] = 103;
    aux[(u32) 2060] = 105;
    aux[(u32) 2061] = 116;
    aux[(u32) 2062] = 0;
    aux[(u32) 2063] = 100;
    aux[(u32) 2064] = 105;
    aux[(u32) 2065] = 103;
    aux[(u32) 2066] = 105;
    aux[(u32) 2067] = 116;
    aux[(u32) 2068] = 0;
    aux[(u32) 2069] = 112;
    aux[(u32) 2070] = 117;
    aux[(u32) 2071] = 116;
    aux[(u32) 2072] = 0;
    aux[(u32) 2073] = 100;
    aux[(u32) 2074] = 105;
    aux[(u32) 2075] = 103;
    aux[(u32) 2076] = 105;
    aux[(u32) 2077] = 116;
    aux[(u32) 2078] = 0;
    aux[(u32) 2079] = 112;
    aux[(u32) 2080] = 117;
    aux[(u32) 2081] = 116;
    aux[(u32) 2082] = 0;
    aux[(u32) 2083] = 100;
    aux[(u32) 2084] = 105;
    aux[(u32) 2085] = 103;
    aux[(u32) 2086] = 105;
    aux[(u32) 2087] = 116;
    aux[(u32) 2088] = 0;
    aux[(u32) 2089] = 117;
    aux[(u32) 2090] = 48;
    aux[(u32) 2091] = 0;
    aux[(u32) 2092] = 112;
    aux[(u32) 2093] = 114;
    aux[(u32) 2094] = 105;
    aux[(u32) 2095] = 110;
    aux[(u32) 2096] = 116;
    aux[(u32) 2097] = 117;
    aux[(u32) 2098] = 56;
    aux[(u32) 2099] = 104;
    aux[(u32) 2100] = 101;
    aux[(u32) 2101] = 120;
    aux[(u32) 2102] = 0;
    aux[(u32) 2103] = 117;
    aux[(u32) 2104] = 56;
    aux[(u32) 2105] = 0;
    aux[(u32) 2106] = 118;
    aux[(u32) 2107] = 97;
    aux[(u32) 2108] = 108;
    aux[(u32) 2109] = 117;
    aux[(u32) 2110] = 101;
    aux[(u32) 2111] = 0;
    aux[(u32) 2112] = 117;
    aux[(u32) 2113] = 56;
    aux[(u32) 2114] = 0;
    aux[(u32) 2115] = 100;
    aux[(u32) 2116] = 105;
    aux[(u32) 2117] = 118;
    aux[(u32) 2118] = 105;
    aux[(u32) 2119] = 100;
    aux[(u32) 2120] = 101;
    aux[(u32) 2121] = 100;
    aux[(u32) 2122] = 0;
    aux[(u32) 2123] = 118;
    aux[(u32) 2124] = 97;
    aux[(u32) 2125] = 108;
    aux[(u32) 2126] = 117;
    aux[(u32) 2127] = 101;
    aux[(u32) 2128] = 0;
    aux[(u32) 2129] = 112;
    aux[(u32) 2130] = 114;
    aux[(u32) 2131] = 105;
    aux[(u32) 2132] = 110;
    aux[(u32) 2133] = 116;
    aux[(u32) 2134] = 104;
    aux[(u32) 2135] = 101;
    aux[(u32) 2136] = 120;
    aux[(u32) 2137] = 100;
    aux[(u32) 2138] = 105;
    aux[(u32) 2139] = 103;
    aux[(u32) 2140] = 105;
    aux[(u32) 2141] = 116;
    aux[(u32) 2142] = 0;
    aux[(u32) 2143] = 100;
    aux[(u32) 2144] = 105;
    aux[(u32) 2145] = 118;
    aux[(u32) 2146] = 105;
    aux[(u32) 2147] = 100;
    aux[(u32) 2148] = 101;
    aux[(u32) 2149] = 100;
    aux[(u32) 2150] = 0;
    aux[(u32) 2151] = 112;
    aux[(u32) 2152] = 114;
    aux[(u32) 2153] = 105;
    aux[(u32) 2154] = 110;
    aux[(u32) 2155] = 116;
    aux[(u32) 2156] = 104;
    aux[(u32) 2157] = 101;
    aux[(u32) 2158] = 120;
    aux[(u32) 2159] = 100;
    aux[(u32) 2160] = 105;
    aux[(u32) 2161] = 103;
    aux[(u32) 2162] = 105;
    aux[(u32) 2163] = 116;
    aux[(u32) 2164] = 0;
    aux[(u32) 2165] = 118;
    aux[(u32) 2166] = 97;
    aux[(u32) 2167] = 108;
    aux[(u32) 2168] = 117;
    aux[(u32) 2169] = 101;
    aux[(u32) 2170] = 0;
    aux[(u32) 2171] = 100;
    aux[(u32) 2172] = 105;
    aux[(u32) 2173] = 118;
    aux[(u32) 2174] = 105;
    aux[(u32) 2175] = 100;
    aux[(u32) 2176] = 101;
    aux[(u32) 2177] = 100;
    aux[(u32) 2178] = 0;
    aux[(u32) 2179] = 117;
    aux[(u32) 2180] = 48;
    aux[(u32) 2181] = 0;
    aux[(u32) 2182] = 112;
    aux[(u32) 2183] = 114;
    aux[(u32) 2184] = 105;
    aux[(u32) 2185] = 110;
    aux[(u32) 2186] = 116;
    aux[(u32) 2187] = 117;
    aux[(u32) 2188] = 49;
    aux[(u32) 2189] = 54;
    aux[(u32) 2190] = 0;
    aux[(u32) 2191] = 117;
    aux[(u32) 2192] = 49;
    aux[(u32) 2193] = 54;
    aux[(u32) 2194] = 0;
    aux[(u32) 2195] = 118;
    aux[(u32) 2196] = 97;
    aux[(u32) 2197] = 108;
    aux[(u32) 2198] = 117;
    aux[(u32) 2199] = 101;
    aux[(u32) 2200] = 0;
    aux[(u32) 2201] = 117;
    aux[(u32) 2202] = 56;
    aux[(u32) 2203] = 0;
    aux[(u32) 2204] = 100;
    aux[(u32) 2205] = 105;
    aux[(u32) 2206] = 103;
    aux[(u32) 2207] = 105;
    aux[(u32) 2208] = 116;
    aux[(u32) 2209] = 115;
    aux[(u32) 2210] = 0;
    aux[(u32) 2211] = 117;
    aux[(u32) 2212] = 56;
    aux[(u32) 2213] = 0;
    aux[(u32) 2214] = 105;
    aux[(u32) 2215] = 0;
    aux[(u32) 2216] = 100;
    aux[(u32) 2217] = 105;
    aux[(u32) 2218] = 103;
    aux[(u32) 2219] = 105;
    aux[(u32) 2220] = 116;
    aux[(u32) 2221] = 115;
    aux[(u32) 2222] = 0;
    aux[(u32) 2223] = 105;
    aux[(u32) 2224] = 0;
    aux[(u32) 2225] = 105;
    aux[(u32) 2226] = 0;
    aux[(u32) 2227] = 117;
    aux[(u32) 2228] = 49;
    aux[(u32) 2229] = 54;
    aux[(u32) 2230] = 0;
    aux[(u32) 2231] = 100;
    aux[(u32) 2232] = 105;
    aux[(u32) 2233] = 118;
    aux[(u32) 2234] = 105;
    aux[(u32) 2235] = 100;
    aux[(u32) 2236] = 101;
    aux[(u32) 2237] = 100;
    aux[(u32) 2238] = 0;
    aux[(u32) 2239] = 117;
    aux[(u32) 2240] = 49;
    aux[(u32) 2241] = 54;
    aux[(u32) 2242] = 95;
    aux[(u32) 2243] = 100;
    aux[(u32) 2244] = 105;
    aux[(u32) 2245] = 118;
    aux[(u32) 2246] = 0;
    aux[(u32) 2247] = 118;
    aux[(u32) 2248] = 97;
    aux[(u32) 2249] = 108;
    aux[(u32) 2250] = 117;
    aux[(u32) 2251] = 101;
    aux[(u32) 2252] = 0;
    aux[(u32) 2253] = 117;
    aux[(u32) 2254] = 49;
    aux[(u32) 2255] = 54;
    aux[(u32) 2256] = 0;
    aux[(u32) 2257] = 109;
    aux[(u32) 2258] = 111;
    aux[(u32) 2259] = 100;
    aux[(u32) 2260] = 100;
    aux[(u32) 2261] = 101;
    aux[(u32) 2262] = 100;
    aux[(u32) 2263] = 0;
    aux[(u32) 2264] = 117;
    aux[(u32) 2265] = 49;
    aux[(u32) 2266] = 54;
    aux[(u32) 2267] = 95;
    aux[(u32) 2268] = 115;
    aux[(u32) 2269] = 117;
    aux[(u32) 2270] = 98;
    aux[(u32) 2271] = 0;
    aux[(u32) 2272] = 118;
    aux[(u32) 2273] = 97;
    aux[(u32) 2274] = 108;
    aux[(u32) 2275] = 117;
    aux[(u32) 2276] = 101;
    aux[(u32) 2277] = 0;
    aux[(u32) 2278] = 117;
    aux[(u32) 2279] = 49;
    aux[(u32) 2280] = 54;
    aux[(u32) 2281] = 95;
    aux[(u32) 2282] = 109;
    aux[(u32) 2283] = 117;
    aux[(u32) 2284] = 108;
    aux[(u32) 2285] = 0;
    aux[(u32) 2286] = 100;
    aux[(u32) 2287] = 105;
    aux[(u32) 2288] = 118;
    aux[(u32) 2289] = 105;
    aux[(u32) 2290] = 100;
    aux[(u32) 2291] = 101;
    aux[(u32) 2292] = 100;
    aux[(u32) 2293] = 0;
    aux[(u32) 2294] = 100;
    aux[(u32) 2295] = 105;
    aux[(u32) 2296] = 103;
    aux[(u32) 2297] = 105;
    aux[(u32) 2298] = 116;
    aux[(u32) 2299] = 115;
    aux[(u32) 2300] = 0;
    aux[(u32) 2301] = 105;
    aux[(u32) 2302] = 0;
    aux[(u32) 2303] = 109;
    aux[(u32) 2304] = 111;
    aux[(u32) 2305] = 100;
    aux[(u32) 2306] = 100;
    aux[(u32) 2307] = 101;
    aux[(u32) 2308] = 100;
    aux[(u32) 2309] = 0;
    aux[(u32) 2310] = 95;
    aux[(u32) 2311] = 48;
    aux[(u32) 2312] = 0;
    aux[(u32) 2313] = 118;
    aux[(u32) 2314] = 97;
    aux[(u32) 2315] = 108;
    aux[(u32) 2316] = 117;
    aux[(u32) 2317] = 101;
    aux[(u32) 2318] = 0;
    aux[(u32) 2319] = 100;
    aux[(u32) 2320] = 105;
    aux[(u32) 2321] = 118;
    aux[(u32) 2322] = 105;
    aux[(u32) 2323] = 100;
    aux[(u32) 2324] = 101;
    aux[(u32) 2325] = 100;
    aux[(u32) 2326] = 0;
    aux[(u32) 2327] = 117;
    aux[(u32) 2328] = 56;
    aux[(u32) 2329] = 0;
    aux[(u32) 2330] = 102;
    aux[(u32) 2331] = 105;
    aux[(u32) 2332] = 114;
    aux[(u32) 2333] = 115;
    aux[(u32) 2334] = 116;
    aux[(u32) 2335] = 0;
    aux[(u32) 2336] = 102;
    aux[(u32) 2337] = 105;
    aux[(u32) 2338] = 114;
    aux[(u32) 2339] = 115;
    aux[(u32) 2340] = 116;
    aux[(u32) 2341] = 0;
    aux[(u32) 2342] = 100;
    aux[(u32) 2343] = 105;
    aux[(u32) 2344] = 103;
    aux[(u32) 2345] = 105;
    aux[(u32) 2346] = 116;
    aux[(u32) 2347] = 115;
    aux[(u32) 2348] = 0;
    aux[(u32) 2349] = 100;
    aux[(u32) 2350] = 105;
    aux[(u32) 2351] = 103;
    aux[(u32) 2352] = 105;
    aux[(u32) 2353] = 116;
    aux[(u32) 2354] = 115;
    aux[(u32) 2355] = 0;
    aux[(u32) 2356] = 102;
    aux[(u32) 2357] = 105;
    aux[(u32) 2358] = 114;
    aux[(u32) 2359] = 115;
    aux[(u32) 2360] = 116;
    aux[(u32) 2361] = 0;
    aux[(u32) 2362] = 102;
    aux[(u32) 2363] = 105;
    aux[(u32) 2364] = 114;
    aux[(u32) 2365] = 115;
    aux[(u32) 2366] = 116;
    aux[(u32) 2367] = 0;
    aux[(u32) 2368] = 117;
    aux[(u32) 2369] = 56;
    aux[(u32) 2370] = 0;
    aux[(u32) 2371] = 105;
    aux[(u32) 2372] = 0;
    aux[(u32) 2373] = 102;
    aux[(u32) 2374] = 105;
    aux[(u32) 2375] = 114;
    aux[(u32) 2376] = 115;
    aux[(u32) 2377] = 116;
    aux[(u32) 2378] = 0;
    aux[(u32) 2379] = 105;
    aux[(u32) 2380] = 0;
    aux[(u32) 2381] = 100;
    aux[(u32) 2382] = 105;
    aux[(u32) 2383] = 103;
    aux[(u32) 2384] = 105;
    aux[(u32) 2385] = 116;
    aux[(u32) 2386] = 115;
    aux[(u32) 2387] = 0;
    aux[(u32) 2388] = 105;
    aux[(u32) 2389] = 0;
    aux[(u32) 2390] = 112;
    aux[(u32) 2391] = 117;
    aux[(u32) 2392] = 116;
    aux[(u32) 2393] = 0;
    aux[(u32) 2394] = 100;
    aux[(u32) 2395] = 105;
    aux[(u32) 2396] = 103;
    aux[(u32) 2397] = 105;
    aux[(u32) 2398] = 116;
    aux[(u32) 2399] = 115;
    aux[(u32) 2400] = 0;
    aux[(u32) 2401] = 105;
    aux[(u32) 2402] = 0;
    aux[(u32) 2403] = 117;
    aux[(u32) 2404] = 48;
    aux[(u32) 2405] = 0;
    aux[(u32) 2406] = 112;
    aux[(u32) 2407] = 114;
    aux[(u32) 2408] = 105;
    aux[(u32) 2409] = 110;
    aux[(u32) 2410] = 116;
    aux[(u32) 2411] = 117;
    aux[(u32) 2412] = 51;
    aux[(u32) 2413] = 50;
    aux[(u32) 2414] = 0;
    aux[(u32) 2415] = 117;
    aux[(u32) 2416] = 51;
    aux[(u32) 2417] = 50;
    aux[(u32) 2418] = 0;
    aux[(u32) 2419] = 118;
    aux[(u32) 2420] = 97;
    aux[(u32) 2421] = 108;
    aux[(u32) 2422] = 117;
    aux[(u32) 2423] = 101;
    aux[(u32) 2424] = 0;
    aux[(u32) 2425] = 117;
    aux[(u32) 2426] = 56;
    aux[(u32) 2427] = 0;
    aux[(u32) 2428] = 100;
    aux[(u32) 2429] = 105;
    aux[(u32) 2430] = 103;
    aux[(u32) 2431] = 105;
    aux[(u32) 2432] = 116;
    aux[(u32) 2433] = 115;
    aux[(u32) 2434] = 0;
    aux[(u32) 2435] = 117;
    aux[(u32) 2436] = 56;
    aux[(u32) 2437] = 0;
    aux[(u32) 2438] = 105;
    aux[(u32) 2439] = 0;
    aux[(u32) 2440] = 100;
    aux[(u32) 2441] = 105;
    aux[(u32) 2442] = 103;
    aux[(u32) 2443] = 105;
    aux[(u32) 2444] = 116;
    aux[(u32) 2445] = 115;
    aux[(u32) 2446] = 0;
    aux[(u32) 2447] = 105;
    aux[(u32) 2448] = 0;
    aux[(u32) 2449] = 105;
    aux[(u32) 2450] = 0;
    aux[(u32) 2451] = 117;
    aux[(u32) 2452] = 51;
    aux[(u32) 2453] = 50;
    aux[(u32) 2454] = 0;
    aux[(u32) 2455] = 100;
    aux[(u32) 2456] = 105;
    aux[(u32) 2457] = 118;
    aux[(u32) 2458] = 105;
    aux[(u32) 2459] = 100;
    aux[(u32) 2460] = 101;
    aux[(u32) 2461] = 100;
    aux[(u32) 2462] = 0;
    aux[(u32) 2463] = 117;
    aux[(u32) 2464] = 51;
    aux[(u32) 2465] = 50;
    aux[(u32) 2466] = 95;
    aux[(u32) 2467] = 100;
    aux[(u32) 2468] = 105;
    aux[(u32) 2469] = 118;
    aux[(u32) 2470] = 0;
    aux[(u32) 2471] = 118;
    aux[(u32) 2472] = 97;
    aux[(u32) 2473] = 108;
    aux[(u32) 2474] = 117;
    aux[(u32) 2475] = 101;
    aux[(u32) 2476] = 0;
    aux[(u32) 2477] = 117;
    aux[(u32) 2478] = 51;
    aux[(u32) 2479] = 50;
    aux[(u32) 2480] = 0;
    aux[(u32) 2481] = 109;
    aux[(u32) 2482] = 111;
    aux[(u32) 2483] = 100;
    aux[(u32) 2484] = 100;
    aux[(u32) 2485] = 101;
    aux[(u32) 2486] = 100;
    aux[(u32) 2487] = 0;
    aux[(u32) 2488] = 117;
    aux[(u32) 2489] = 51;
    aux[(u32) 2490] = 50;
    aux[(u32) 2491] = 95;
    aux[(u32) 2492] = 115;
    aux[(u32) 2493] = 117;
    aux[(u32) 2494] = 98;
    aux[(u32) 2495] = 0;
    aux[(u32) 2496] = 118;
    aux[(u32) 2497] = 97;
    aux[(u32) 2498] = 108;
    aux[(u32) 2499] = 117;
    aux[(u32) 2500] = 101;
    aux[(u32) 2501] = 0;
    aux[(u32) 2502] = 117;
    aux[(u32) 2503] = 51;
    aux[(u32) 2504] = 50;
    aux[(u32) 2505] = 95;
    aux[(u32) 2506] = 109;
    aux[(u32) 2507] = 117;
    aux[(u32) 2508] = 108;
    aux[(u32) 2509] = 0;
    aux[(u32) 2510] = 100;
    aux[(u32) 2511] = 105;
    aux[(u32) 2512] = 118;
    aux[(u32) 2513] = 105;
    aux[(u32) 2514] = 100;
    aux[(u32) 2515] = 101;
    aux[(u32) 2516] = 100;
    aux[(u32) 2517] = 0;
    aux[(u32) 2518] = 100;
    aux[(u32) 2519] = 105;
    aux[(u32) 2520] = 103;
    aux[(u32) 2521] = 105;
    aux[(u32) 2522] = 116;
    aux[(u32) 2523] = 115;
    aux[(u32) 2524] = 0;
    aux[(u32) 2525] = 105;
    aux[(u32) 2526] = 0;
    aux[(u32) 2527] = 109;
    aux[(u32) 2528] = 111;
    aux[(u32) 2529] = 100;
    aux[(u32) 2530] = 100;
    aux[(u32) 2531] = 101;
    aux[(u32) 2532] = 100;
    aux[(u32) 2533] = 0;
    aux[(u32) 2534] = 95;
    aux[(u32) 2535] = 48;
    aux[(u32) 2536] = 0;
    aux[(u32) 2537] = 118;
    aux[(u32) 2538] = 97;
    aux[(u32) 2539] = 108;
    aux[(u32) 2540] = 117;
    aux[(u32) 2541] = 101;
    aux[(u32) 2542] = 0;
    aux[(u32) 2543] = 100;
    aux[(u32) 2544] = 105;
    aux[(u32) 2545] = 118;
    aux[(u32) 2546] = 105;
    aux[(u32) 2547] = 100;
    aux[(u32) 2548] = 101;
    aux[(u32) 2549] = 100;
    aux[(u32) 2550] = 0;
    aux[(u32) 2551] = 117;
    aux[(u32) 2552] = 56;
    aux[(u32) 2553] = 0;
    aux[(u32) 2554] = 102;
    aux[(u32) 2555] = 105;
    aux[(u32) 2556] = 114;
    aux[(u32) 2557] = 115;
    aux[(u32) 2558] = 116;
    aux[(u32) 2559] = 0;
    aux[(u32) 2560] = 102;
    aux[(u32) 2561] = 105;
    aux[(u32) 2562] = 114;
    aux[(u32) 2563] = 115;
    aux[(u32) 2564] = 116;
    aux[(u32) 2565] = 0;
    aux[(u32) 2566] = 100;
    aux[(u32) 2567] = 105;
    aux[(u32) 2568] = 103;
    aux[(u32) 2569] = 105;
    aux[(u32) 2570] = 116;
    aux[(u32) 2571] = 115;
    aux[(u32) 2572] = 0;
    aux[(u32) 2573] = 100;
    aux[(u32) 2574] = 105;
    aux[(u32) 2575] = 103;
    aux[(u32) 2576] = 105;
    aux[(u32) 2577] = 116;
    aux[(u32) 2578] = 115;
    aux[(u32) 2579] = 0;
    aux[(u32) 2580] = 102;
    aux[(u32) 2581] = 105;
    aux[(u32) 2582] = 114;
    aux[(u32) 2583] = 115;
    aux[(u32) 2584] = 116;
    aux[(u32) 2585] = 0;
    aux[(u32) 2586] = 102;
    aux[(u32) 2587] = 105;
    aux[(u32) 2588] = 114;
    aux[(u32) 2589] = 115;
    aux[(u32) 2590] = 116;
    aux[(u32) 2591] = 0;
    aux[(u32) 2592] = 117;
    aux[(u32) 2593] = 56;
    aux[(u32) 2594] = 0;
    aux[(u32) 2595] = 105;
    aux[(u32) 2596] = 0;
    aux[(u32) 2597] = 102;
    aux[(u32) 2598] = 105;
    aux[(u32) 2599] = 114;
    aux[(u32) 2600] = 115;
    aux[(u32) 2601] = 116;
    aux[(u32) 2602] = 0;
    aux[(u32) 2603] = 105;
    aux[(u32) 2604] = 0;
    aux[(u32) 2605] = 100;
    aux[(u32) 2606] = 105;
    aux[(u32) 2607] = 103;
    aux[(u32) 2608] = 105;
    aux[(u32) 2609] = 116;
    aux[(u32) 2610] = 115;
    aux[(u32) 2611] = 0;
    aux[(u32) 2612] = 105;
    aux[(u32) 2613] = 0;
    aux[(u32) 2614] = 112;
    aux[(u32) 2615] = 117;
    aux[(u32) 2616] = 116;
    aux[(u32) 2617] = 0;
    aux[(u32) 2618] = 100;
    aux[(u32) 2619] = 105;
    aux[(u32) 2620] = 103;
    aux[(u32) 2621] = 105;
    aux[(u32) 2622] = 116;
    aux[(u32) 2623] = 115;
    aux[(u32) 2624] = 0;
    aux[(u32) 2625] = 105;
    aux[(u32) 2626] = 0;
    aux[(u32) 2627] = 117;
    aux[(u32) 2628] = 48;
    aux[(u32) 2629] = 0;
    aux[(u32) 2630] = 112;
    aux[(u32) 2631] = 114;
    aux[(u32) 2632] = 105;
    aux[(u32) 2633] = 110;
    aux[(u32) 2634] = 116;
    aux[(u32) 2635] = 117;
    aux[(u32) 2636] = 49;
    aux[(u32) 2637] = 54;
    aux[(u32) 2638] = 104;
    aux[(u32) 2639] = 101;
    aux[(u32) 2640] = 120;
    aux[(u32) 2641] = 0;
    aux[(u32) 2642] = 117;
    aux[(u32) 2643] = 49;
    aux[(u32) 2644] = 54;
    aux[(u32) 2645] = 0;
    aux[(u32) 2646] = 118;
    aux[(u32) 2647] = 97;
    aux[(u32) 2648] = 108;
    aux[(u32) 2649] = 117;
    aux[(u32) 2650] = 101;
    aux[(u32) 2651] = 0;
    aux[(u32) 2652] = 112;
    aux[(u32) 2653] = 114;
    aux[(u32) 2654] = 105;
    aux[(u32) 2655] = 110;
    aux[(u32) 2656] = 116;
    aux[(u32) 2657] = 117;
    aux[(u32) 2658] = 56;
    aux[(u32) 2659] = 104;
    aux[(u32) 2660] = 101;
    aux[(u32) 2661] = 120;
    aux[(u32) 2662] = 0;
    aux[(u32) 2663] = 118;
    aux[(u32) 2664] = 97;
    aux[(u32) 2665] = 108;
    aux[(u32) 2666] = 117;
    aux[(u32) 2667] = 101;
    aux[(u32) 2668] = 0;
    aux[(u32) 2669] = 95;
    aux[(u32) 2670] = 49;
    aux[(u32) 2671] = 0;
    aux[(u32) 2672] = 112;
    aux[(u32) 2673] = 114;
    aux[(u32) 2674] = 105;
    aux[(u32) 2675] = 110;
    aux[(u32) 2676] = 116;
    aux[(u32) 2677] = 117;
    aux[(u32) 2678] = 56;
    aux[(u32) 2679] = 104;
    aux[(u32) 2680] = 101;
    aux[(u32) 2681] = 120;
    aux[(u32) 2682] = 0;
    aux[(u32) 2683] = 118;
    aux[(u32) 2684] = 97;
    aux[(u32) 2685] = 108;
    aux[(u32) 2686] = 117;
    aux[(u32) 2687] = 101;
    aux[(u32) 2688] = 0;
    aux[(u32) 2689] = 95;
    aux[(u32) 2690] = 48;
    aux[(u32) 2691] = 0;
    aux[(u32) 2692] = 117;
    aux[(u32) 2693] = 48;
    aux[(u32) 2694] = 0;
    aux[(u32) 2695] = 112;
    aux[(u32) 2696] = 114;
    aux[(u32) 2697] = 105;
    aux[(u32) 2698] = 110;
    aux[(u32) 2699] = 116;
    aux[(u32) 2700] = 117;
    aux[(u32) 2701] = 56;
    aux[(u32) 2702] = 98;
    aux[(u32) 2703] = 105;
    aux[(u32) 2704] = 110;
    aux[(u32) 2705] = 0;
    aux[(u32) 2706] = 117;
    aux[(u32) 2707] = 56;
    aux[(u32) 2708] = 0;
    aux[(u32) 2709] = 118;
    aux[(u32) 2710] = 97;
    aux[(u32) 2711] = 108;
    aux[(u32) 2712] = 117;
    aux[(u32) 2713] = 101;
    aux[(u32) 2714] = 0;
    aux[(u32) 2715] = 117;
    aux[(u32) 2716] = 56;
    aux[(u32) 2717] = 0;
    aux[(u32) 2718] = 100;
    aux[(u32) 2719] = 105;
    aux[(u32) 2720] = 103;
    aux[(u32) 2721] = 105;
    aux[(u32) 2722] = 116;
    aux[(u32) 2723] = 115;
    aux[(u32) 2724] = 0;
    aux[(u32) 2725] = 117;
    aux[(u32) 2726] = 56;
    aux[(u32) 2727] = 0;
    aux[(u32) 2728] = 105;
    aux[(u32) 2729] = 0;
    aux[(u32) 2730] = 105;
    aux[(u32) 2731] = 0;
    aux[(u32) 2732] = 100;
    aux[(u32) 2733] = 105;
    aux[(u32) 2734] = 103;
    aux[(u32) 2735] = 105;
    aux[(u32) 2736] = 116;
    aux[(u32) 2737] = 115;
    aux[(u32) 2738] = 0;
    aux[(u32) 2739] = 105;
    aux[(u32) 2740] = 0;
    aux[(u32) 2741] = 100;
    aux[(u32) 2742] = 105;
    aux[(u32) 2743] = 103;
    aux[(u32) 2744] = 105;
    aux[(u32) 2745] = 116;
    aux[(u32) 2746] = 115;
    aux[(u32) 2747] = 0;
    aux[(u32) 2748] = 105;
    aux[(u32) 2749] = 0;
    aux[(u32) 2750] = 117;
    aux[(u32) 2751] = 56;
    aux[(u32) 2752] = 0;
    aux[(u32) 2753] = 112;
    aux[(u32) 2754] = 111;
    aux[(u32) 2755] = 119;
    aux[(u32) 2756] = 101;
    aux[(u32) 2757] = 114;
    aux[(u32) 2758] = 115;
    aux[(u32) 2759] = 0;
    aux[(u32) 2760] = 112;
    aux[(u32) 2761] = 111;
    aux[(u32) 2762] = 119;
    aux[(u32) 2763] = 101;
    aux[(u32) 2764] = 114;
    aux[(u32) 2765] = 115;
    aux[(u32) 2766] = 0;
    aux[(u32) 2767] = 112;
    aux[(u32) 2768] = 111;
    aux[(u32) 2769] = 119;
    aux[(u32) 2770] = 101;
    aux[(u32) 2771] = 114;
    aux[(u32) 2772] = 115;
    aux[(u32) 2773] = 0;
    aux[(u32) 2774] = 112;
    aux[(u32) 2775] = 111;
    aux[(u32) 2776] = 119;
    aux[(u32) 2777] = 101;
    aux[(u32) 2778] = 114;
    aux[(u32) 2779] = 115;
    aux[(u32) 2780] = 0;
    aux[(u32) 2781] = 112;
    aux[(u32) 2782] = 111;
    aux[(u32) 2783] = 119;
    aux[(u32) 2784] = 101;
    aux[(u32) 2785] = 114;
    aux[(u32) 2786] = 115;
    aux[(u32) 2787] = 0;
    aux[(u32) 2788] = 112;
    aux[(u32) 2789] = 111;
    aux[(u32) 2790] = 119;
    aux[(u32) 2791] = 101;
    aux[(u32) 2792] = 114;
    aux[(u32) 2793] = 115;
    aux[(u32) 2794] = 0;
    aux[(u32) 2795] = 112;
    aux[(u32) 2796] = 111;
    aux[(u32) 2797] = 119;
    aux[(u32) 2798] = 101;
    aux[(u32) 2799] = 114;
    aux[(u32) 2800] = 115;
    aux[(u32) 2801] = 0;
    aux[(u32) 2802] = 112;
    aux[(u32) 2803] = 111;
    aux[(u32) 2804] = 119;
    aux[(u32) 2805] = 101;
    aux[(u32) 2806] = 114;
    aux[(u32) 2807] = 115;
    aux[(u32) 2808] = 0;
    aux[(u32) 2809] = 112;
    aux[(u32) 2810] = 111;
    aux[(u32) 2811] = 119;
    aux[(u32) 2812] = 101;
    aux[(u32) 2813] = 114;
    aux[(u32) 2814] = 115;
    aux[(u32) 2815] = 0;
    aux[(u32) 2816] = 117;
    aux[(u32) 2817] = 56;
    aux[(u32) 2818] = 0;
    aux[(u32) 2819] = 105;
    aux[(u32) 2820] = 0;
    aux[(u32) 2821] = 105;
    aux[(u32) 2822] = 0;
    aux[(u32) 2823] = 100;
    aux[(u32) 2824] = 105;
    aux[(u32) 2825] = 103;
    aux[(u32) 2826] = 105;
    aux[(u32) 2827] = 116;
    aux[(u32) 2828] = 115;
    aux[(u32) 2829] = 0;
    aux[(u32) 2830] = 105;
    aux[(u32) 2831] = 0;
    aux[(u32) 2832] = 117;
    aux[(u32) 2833] = 56;
    aux[(u32) 2834] = 0;
    aux[(u32) 2835] = 112;
    aux[(u32) 2836] = 111;
    aux[(u32) 2837] = 119;
    aux[(u32) 2838] = 101;
    aux[(u32) 2839] = 114;
    aux[(u32) 2840] = 0;
    aux[(u32) 2841] = 112;
    aux[(u32) 2842] = 111;
    aux[(u32) 2843] = 119;
    aux[(u32) 2844] = 101;
    aux[(u32) 2845] = 114;
    aux[(u32) 2846] = 115;
    aux[(u32) 2847] = 0;
    aux[(u32) 2848] = 105;
    aux[(u32) 2849] = 0;
    aux[(u32) 2850] = 118;
    aux[(u32) 2851] = 97;
    aux[(u32) 2852] = 108;
    aux[(u32) 2853] = 117;
    aux[(u32) 2854] = 101;
    aux[(u32) 2855] = 0;
    aux[(u32) 2856] = 112;
    aux[(u32) 2857] = 111;
    aux[(u32) 2858] = 119;
    aux[(u32) 2859] = 101;
    aux[(u32) 2860] = 114;
    aux[(u32) 2861] = 0;
    aux[(u32) 2862] = 118;
    aux[(u32) 2863] = 97;
    aux[(u32) 2864] = 108;
    aux[(u32) 2865] = 117;
    aux[(u32) 2866] = 101;
    aux[(u32) 2867] = 0;
    aux[(u32) 2868] = 112;
    aux[(u32) 2869] = 111;
    aux[(u32) 2870] = 119;
    aux[(u32) 2871] = 101;
    aux[(u32) 2872] = 114;
    aux[(u32) 2873] = 0;
    aux[(u32) 2874] = 100;
    aux[(u32) 2875] = 105;
    aux[(u32) 2876] = 103;
    aux[(u32) 2877] = 105;
    aux[(u32) 2878] = 116;
    aux[(u32) 2879] = 115;
    aux[(u32) 2880] = 0;
    aux[(u32) 2881] = 105;
    aux[(u32) 2882] = 0;
    aux[(u32) 2883] = 117;
    aux[(u32) 2884] = 56;
    aux[(u32) 2885] = 0;
    aux[(u32) 2886] = 105;
    aux[(u32) 2887] = 0;
    aux[(u32) 2888] = 105;
    aux[(u32) 2889] = 0;
    aux[(u32) 2890] = 100;
    aux[(u32) 2891] = 105;
    aux[(u32) 2892] = 103;
    aux[(u32) 2893] = 105;
    aux[(u32) 2894] = 116;
    aux[(u32) 2895] = 115;
    aux[(u32) 2896] = 0;
    aux[(u32) 2897] = 105;
    aux[(u32) 2898] = 0;
    aux[(u32) 2899] = 112;
    aux[(u32) 2900] = 117;
    aux[(u32) 2901] = 116;
    aux[(u32) 2902] = 0;
    aux[(u32) 2903] = 100;
    aux[(u32) 2904] = 105;
    aux[(u32) 2905] = 103;
    aux[(u32) 2906] = 105;
    aux[(u32) 2907] = 116;
    aux[(u32) 2908] = 115;
    aux[(u32) 2909] = 0;
    aux[(u32) 2910] = 105;
    aux[(u32) 2911] = 0;
    aux[(u32) 2912] = 117;
    aux[(u32) 2913] = 48;
    aux[(u32) 2914] = 0;
    aux[(u32) 2915] = 112;
    aux[(u32) 2916] = 114;
    aux[(u32) 2917] = 105;
    aux[(u32) 2918] = 110;
    aux[(u32) 2919] = 116;
    aux[(u32) 2920] = 117;
    aux[(u32) 2921] = 49;
    aux[(u32) 2922] = 54;
    aux[(u32) 2923] = 98;
    aux[(u32) 2924] = 105;
    aux[(u32) 2925] = 110;
    aux[(u32) 2926] = 0;
    aux[(u32) 2927] = 117;
    aux[(u32) 2928] = 49;
    aux[(u32) 2929] = 54;
    aux[(u32) 2930] = 0;
    aux[(u32) 2931] = 118;
    aux[(u32) 2932] = 97;
    aux[(u32) 2933] = 108;
    aux[(u32) 2934] = 117;
    aux[(u32) 2935] = 101;
    aux[(u32) 2936] = 0;
    aux[(u32) 2937] = 112;
    aux[(u32) 2938] = 114;
    aux[(u32) 2939] = 105;
    aux[(u32) 2940] = 110;
    aux[(u32) 2941] = 116;
    aux[(u32) 2942] = 117;
    aux[(u32) 2943] = 56;
    aux[(u32) 2944] = 98;
    aux[(u32) 2945] = 105;
    aux[(u32) 2946] = 110;
    aux[(u32) 2947] = 0;
    aux[(u32) 2948] = 118;
    aux[(u32) 2949] = 97;
    aux[(u32) 2950] = 108;
    aux[(u32) 2951] = 117;
    aux[(u32) 2952] = 101;
    aux[(u32) 2953] = 0;
    aux[(u32) 2954] = 95;
    aux[(u32) 2955] = 49;
    aux[(u32) 2956] = 0;
    aux[(u32) 2957] = 112;
    aux[(u32) 2958] = 117;
    aux[(u32) 2959] = 116;
    aux[(u32) 2960] = 0;
    aux[(u32) 2961] = 112;
    aux[(u32) 2962] = 114;
    aux[(u32) 2963] = 105;
    aux[(u32) 2964] = 110;
    aux[(u32) 2965] = 116;
    aux[(u32) 2966] = 117;
    aux[(u32) 2967] = 56;
    aux[(u32) 2968] = 98;
    aux[(u32) 2969] = 105;
    aux[(u32) 2970] = 110;
    aux[(u32) 2971] = 0;
    aux[(u32) 2972] = 118;
    aux[(u32) 2973] = 97;
    aux[(u32) 2974] = 108;
    aux[(u32) 2975] = 117;
    aux[(u32) 2976] = 101;
    aux[(u32) 2977] = 0;
    aux[(u32) 2978] = 95;
    aux[(u32) 2979] = 48;
    aux[(u32) 2980] = 0;
    aux[(u32) 2981] = 117;
    aux[(u32) 2982] = 51;
    aux[(u32) 2983] = 50;
    aux[(u32) 2984] = 0;
    aux[(u32) 2985] = 117;
    aux[(u32) 2986] = 51;
    aux[(u32) 2987] = 50;
    aux[(u32) 2988] = 95;
    aux[(u32) 2989] = 97;
    aux[(u32) 2990] = 100;
    aux[(u32) 2991] = 100;
    aux[(u32) 2992] = 95;
    aux[(u32) 2993] = 117;
    aux[(u32) 2994] = 49;
    aux[(u32) 2995] = 54;
    aux[(u32) 2996] = 115;
    aux[(u32) 2997] = 0;
    aux[(u32) 2998] = 117;
    aux[(u32) 2999] = 49;
    aux[(u32) 3000] = 54;
    aux[(u32) 3001] = 0;
    aux[(u32) 3002] = 97;
    aux[(u32) 3003] = 0;
    aux[(u32) 3004] = 117;
    aux[(u32) 3005] = 49;
    aux[(u32) 3006] = 54;
    aux[(u32) 3007] = 0;
    aux[(u32) 3008] = 98;
    aux[(u32) 3009] = 0;
    aux[(u32) 3010] = 117;
    aux[(u32) 3011] = 49;
    aux[(u32) 3012] = 54;
    aux[(u32) 3013] = 0;
    aux[(u32) 3014] = 120;
    aux[(u32) 3015] = 0;
    aux[(u32) 3016] = 97;
    aux[(u32) 3017] = 0;
    aux[(u32) 3018] = 98;
    aux[(u32) 3019] = 0;
    aux[(u32) 3020] = 117;
    aux[(u32) 3021] = 51;
    aux[(u32) 3022] = 50;
    aux[(u32) 3023] = 0;
    aux[(u32) 3024] = 114;
    aux[(u32) 3025] = 0;
    aux[(u32) 3026] = 114;
    aux[(u32) 3027] = 0;
    aux[(u32) 3028] = 95;
    aux[(u32) 3029] = 51;
    aux[(u32) 3030] = 0;
    aux[(u32) 3031] = 114;
    aux[(u32) 3032] = 0;
    aux[(u32) 3033] = 95;
    aux[(u32) 3034] = 50;
    aux[(u32) 3035] = 0;
    aux[(u32) 3036] = 117;
    aux[(u32) 3037] = 56;
    aux[(u32) 3038] = 0;
    aux[(u32) 3039] = 120;
    aux[(u32) 3040] = 0;
    aux[(u32) 3041] = 97;
    aux[(u32) 3042] = 0;
    aux[(u32) 3043] = 120;
    aux[(u32) 3044] = 0;
    aux[(u32) 3045] = 98;
    aux[(u32) 3046] = 0;
    aux[(u32) 3047] = 114;
    aux[(u32) 3048] = 0;
    aux[(u32) 3049] = 95;
    aux[(u32) 3050] = 49;
    aux[(u32) 3051] = 0;
    aux[(u32) 3052] = 120;
    aux[(u32) 3053] = 0;
    aux[(u32) 3054] = 95;
    aux[(u32) 3055] = 49;
    aux[(u32) 3056] = 0;
    aux[(u32) 3057] = 114;
    aux[(u32) 3058] = 0;
    aux[(u32) 3059] = 95;
    aux[(u32) 3060] = 48;
    aux[(u32) 3061] = 0;
    aux[(u32) 3062] = 120;
    aux[(u32) 3063] = 0;
    aux[(u32) 3064] = 95;
    aux[(u32) 3065] = 48;
    aux[(u32) 3066] = 0;
    aux[(u32) 3067] = 114;
    aux[(u32) 3068] = 0;
    aux[(u32) 3069] = 117;
    aux[(u32) 3070] = 51;
    aux[(u32) 3071] = 50;
    aux[(u32) 3072] = 0;
    aux[(u32) 3073] = 117;
    aux[(u32) 3074] = 51;
    aux[(u32) 3075] = 50;
    aux[(u32) 3076] = 95;
    aux[(u32) 3077] = 97;
    aux[(u32) 3078] = 100;
    aux[(u32) 3079] = 100;
    aux[(u32) 3080] = 0;
    aux[(u32) 3081] = 117;
    aux[(u32) 3082] = 51;
    aux[(u32) 3083] = 50;
    aux[(u32) 3084] = 0;
    aux[(u32) 3085] = 97;
    aux[(u32) 3086] = 0;
    aux[(u32) 3087] = 117;
    aux[(u32) 3088] = 51;
    aux[(u32) 3089] = 50;
    aux[(u32) 3090] = 0;
    aux[(u32) 3091] = 98;
    aux[(u32) 3092] = 0;
    aux[(u32) 3093] = 117;
    aux[(u32) 3094] = 51;
    aux[(u32) 3095] = 50;
    aux[(u32) 3096] = 0;
    aux[(u32) 3097] = 114;
    aux[(u32) 3098] = 0;
    aux[(u32) 3099] = 117;
    aux[(u32) 3100] = 51;
    aux[(u32) 3101] = 50;
    aux[(u32) 3102] = 95;
    aux[(u32) 3103] = 97;
    aux[(u32) 3104] = 100;
    aux[(u32) 3105] = 100;
    aux[(u32) 3106] = 95;
    aux[(u32) 3107] = 117;
    aux[(u32) 3108] = 49;
    aux[(u32) 3109] = 54;
    aux[(u32) 3110] = 115;
    aux[(u32) 3111] = 0;
    aux[(u32) 3112] = 97;
    aux[(u32) 3113] = 0;
    aux[(u32) 3114] = 95;
    aux[(u32) 3115] = 48;
    aux[(u32) 3116] = 117;
    aux[(u32) 3117] = 49;
    aux[(u32) 3118] = 54;
    aux[(u32) 3119] = 0;
    aux[(u32) 3120] = 98;
    aux[(u32) 3121] = 0;
    aux[(u32) 3122] = 95;
    aux[(u32) 3123] = 48;
    aux[(u32) 3124] = 117;
    aux[(u32) 3125] = 49;
    aux[(u32) 3126] = 54;
    aux[(u32) 3127] = 0;
    aux[(u32) 3128] = 114;
    aux[(u32) 3129] = 0;
    aux[(u32) 3130] = 95;
    aux[(u32) 3131] = 49;
    aux[(u32) 3132] = 117;
    aux[(u32) 3133] = 49;
    aux[(u32) 3134] = 54;
    aux[(u32) 3135] = 0;
    aux[(u32) 3136] = 97;
    aux[(u32) 3137] = 0;
    aux[(u32) 3138] = 95;
    aux[(u32) 3139] = 49;
    aux[(u32) 3140] = 117;
    aux[(u32) 3141] = 49;
    aux[(u32) 3142] = 54;
    aux[(u32) 3143] = 0;
    aux[(u32) 3144] = 98;
    aux[(u32) 3145] = 0;
    aux[(u32) 3146] = 95;
    aux[(u32) 3147] = 49;
    aux[(u32) 3148] = 117;
    aux[(u32) 3149] = 49;
    aux[(u32) 3150] = 54;
    aux[(u32) 3151] = 0;
    aux[(u32) 3152] = 114;
    aux[(u32) 3153] = 0;
    aux[(u32) 3154] = 117;
    aux[(u32) 3155] = 51;
    aux[(u32) 3156] = 50;
    aux[(u32) 3157] = 0;
    aux[(u32) 3158] = 117;
    aux[(u32) 3159] = 51;
    aux[(u32) 3160] = 50;
    aux[(u32) 3161] = 95;
    aux[(u32) 3162] = 98;
    aux[(u32) 3163] = 105;
    aux[(u32) 3164] = 116;
    aux[(u32) 3165] = 95;
    aux[(u32) 3166] = 97;
    aux[(u32) 3167] = 110;
    aux[(u32) 3168] = 100;
    aux[(u32) 3169] = 0;
    aux[(u32) 3170] = 117;
    aux[(u32) 3171] = 51;
    aux[(u32) 3172] = 50;
    aux[(u32) 3173] = 0;
    aux[(u32) 3174] = 97;
    aux[(u32) 3175] = 0;
    aux[(u32) 3176] = 117;
    aux[(u32) 3177] = 51;
    aux[(u32) 3178] = 50;
    aux[(u32) 3179] = 0;
    aux[(u32) 3180] = 98;
    aux[(u32) 3181] = 0;
    aux[(u32) 3182] = 117;
    aux[(u32) 3183] = 51;
    aux[(u32) 3184] = 50;
    aux[(u32) 3185] = 0;
    aux[(u32) 3186] = 114;
    aux[(u32) 3187] = 101;
    aux[(u32) 3188] = 115;
    aux[(u32) 3189] = 117;
    aux[(u32) 3190] = 108;
    aux[(u32) 3191] = 116;
    aux[(u32) 3192] = 0;
    aux[(u32) 3193] = 114;
    aux[(u32) 3194] = 101;
    aux[(u32) 3195] = 115;
    aux[(u32) 3196] = 117;
    aux[(u32) 3197] = 108;
    aux[(u32) 3198] = 116;
    aux[(u32) 3199] = 0;
    aux[(u32) 3200] = 95;
    aux[(u32) 3201] = 51;
    aux[(u32) 3202] = 0;
    aux[(u32) 3203] = 97;
    aux[(u32) 3204] = 0;
    aux[(u32) 3205] = 95;
    aux[(u32) 3206] = 51;
    aux[(u32) 3207] = 0;
    aux[(u32) 3208] = 98;
    aux[(u32) 3209] = 0;
    aux[(u32) 3210] = 95;
    aux[(u32) 3211] = 51;
    aux[(u32) 3212] = 0;
    aux[(u32) 3213] = 114;
    aux[(u32) 3214] = 101;
    aux[(u32) 3215] = 115;
    aux[(u32) 3216] = 117;
    aux[(u32) 3217] = 108;
    aux[(u32) 3218] = 116;
    aux[(u32) 3219] = 0;
    aux[(u32) 3220] = 95;
    aux[(u32) 3221] = 50;
    aux[(u32) 3222] = 0;
    aux[(u32) 3223] = 97;
    aux[(u32) 3224] = 0;
    aux[(u32) 3225] = 95;
    aux[(u32) 3226] = 50;
    aux[(u32) 3227] = 0;
    aux[(u32) 3228] = 98;
    aux[(u32) 3229] = 0;
    aux[(u32) 3230] = 95;
    aux[(u32) 3231] = 50;
    aux[(u32) 3232] = 0;
    aux[(u32) 3233] = 114;
    aux[(u32) 3234] = 101;
    aux[(u32) 3235] = 115;
    aux[(u32) 3236] = 117;
    aux[(u32) 3237] = 108;
    aux[(u32) 3238] = 116;
    aux[(u32) 3239] = 0;
    aux[(u32) 3240] = 95;
    aux[(u32) 3241] = 49;
    aux[(u32) 3242] = 0;
    aux[(u32) 3243] = 97;
    aux[(u32) 3244] = 0;
    aux[(u32) 3245] = 95;
    aux[(u32) 3246] = 49;
    aux[(u32) 3247] = 0;
    aux[(u32) 3248] = 98;
    aux[(u32) 3249] = 0;
    aux[(u32) 3250] = 95;
    aux[(u32) 3251] = 49;
    aux[(u32) 3252] = 0;
    aux[(u32) 3253] = 114;
    aux[(u32) 3254] = 101;
    aux[(u32) 3255] = 115;
    aux[(u32) 3256] = 117;
    aux[(u32) 3257] = 108;
    aux[(u32) 3258] = 116;
    aux[(u32) 3259] = 0;
    aux[(u32) 3260] = 95;
    aux[(u32) 3261] = 48;
    aux[(u32) 3262] = 0;
    aux[(u32) 3263] = 97;
    aux[(u32) 3264] = 0;
    aux[(u32) 3265] = 95;
    aux[(u32) 3266] = 48;
    aux[(u32) 3267] = 0;
    aux[(u32) 3268] = 98;
    aux[(u32) 3269] = 0;
    aux[(u32) 3270] = 95;
    aux[(u32) 3271] = 48;
    aux[(u32) 3272] = 0;
    aux[(u32) 3273] = 114;
    aux[(u32) 3274] = 101;
    aux[(u32) 3275] = 115;
    aux[(u32) 3276] = 117;
    aux[(u32) 3277] = 108;
    aux[(u32) 3278] = 116;
    aux[(u32) 3279] = 0;
    aux[(u32) 3280] = 117;
    aux[(u32) 3281] = 51;
    aux[(u32) 3282] = 50;
    aux[(u32) 3283] = 0;
    aux[(u32) 3284] = 117;
    aux[(u32) 3285] = 51;
    aux[(u32) 3286] = 50;
    aux[(u32) 3287] = 95;
    aux[(u32) 3288] = 98;
    aux[(u32) 3289] = 105;
    aux[(u32) 3290] = 116;
    aux[(u32) 3291] = 95;
    aux[(u32) 3292] = 111;
    aux[(u32) 3293] = 114;
    aux[(u32) 3294] = 0;
    aux[(u32) 3295] = 117;
    aux[(u32) 3296] = 51;
    aux[(u32) 3297] = 50;
    aux[(u32) 3298] = 0;
    aux[(u32) 3299] = 97;
    aux[(u32) 3300] = 0;
    aux[(u32) 3301] = 117;
    aux[(u32) 3302] = 51;
    aux[(u32) 3303] = 50;
    aux[(u32) 3304] = 0;
    aux[(u32) 3305] = 98;
    aux[(u32) 3306] = 0;
    aux[(u32) 3307] = 117;
    aux[(u32) 3308] = 51;
    aux[(u32) 3309] = 50;
    aux[(u32) 3310] = 0;
    aux[(u32) 3311] = 114;
    aux[(u32) 3312] = 101;
    aux[(u32) 3313] = 115;
    aux[(u32) 3314] = 117;
    aux[(u32) 3315] = 108;
    aux[(u32) 3316] = 116;
    aux[(u32) 3317] = 0;
    aux[(u32) 3318] = 114;
    aux[(u32) 3319] = 101;
    aux[(u32) 3320] = 115;
    aux[(u32) 3321] = 117;
    aux[(u32) 3322] = 108;
    aux[(u32) 3323] = 116;
    aux[(u32) 3324] = 0;
    aux[(u32) 3325] = 95;
    aux[(u32) 3326] = 51;
    aux[(u32) 3327] = 0;
    aux[(u32) 3328] = 97;
    aux[(u32) 3329] = 0;
    aux[(u32) 3330] = 95;
    aux[(u32) 3331] = 51;
    aux[(u32) 3332] = 0;
    aux[(u32) 3333] = 98;
    aux[(u32) 3334] = 0;
    aux[(u32) 3335] = 95;
    aux[(u32) 3336] = 51;
    aux[(u32) 3337] = 0;
    aux[(u32) 3338] = 114;
    aux[(u32) 3339] = 101;
    aux[(u32) 3340] = 115;
    aux[(u32) 3341] = 117;
    aux[(u32) 3342] = 108;
    aux[(u32) 3343] = 116;
    aux[(u32) 3344] = 0;
    aux[(u32) 3345] = 95;
    aux[(u32) 3346] = 50;
    aux[(u32) 3347] = 0;
    aux[(u32) 3348] = 97;
    aux[(u32) 3349] = 0;
    aux[(u32) 3350] = 95;
    aux[(u32) 3351] = 50;
    aux[(u32) 3352] = 0;
    aux[(u32) 3353] = 98;
    aux[(u32) 3354] = 0;
    aux[(u32) 3355] = 95;
    aux[(u32) 3356] = 50;
    aux[(u32) 3357] = 0;
    aux[(u32) 3358] = 114;
    aux[(u32) 3359] = 101;
    aux[(u32) 3360] = 115;
    aux[(u32) 3361] = 117;
    aux[(u32) 3362] = 108;
    aux[(u32) 3363] = 116;
    aux[(u32) 3364] = 0;
    aux[(u32) 3365] = 95;
    aux[(u32) 3366] = 49;
    aux[(u32) 3367] = 0;
    aux[(u32) 3368] = 97;
    aux[(u32) 3369] = 0;
    aux[(u32) 3370] = 95;
    aux[(u32) 3371] = 49;
    aux[(u32) 3372] = 0;
    aux[(u32) 3373] = 98;
    aux[(u32) 3374] = 0;
    aux[(u32) 3375] = 95;
    aux[(u32) 3376] = 49;
    aux[(u32) 3377] = 0;
    aux[(u32) 3378] = 114;
    aux[(u32) 3379] = 101;
    aux[(u32) 3380] = 115;
    aux[(u32) 3381] = 117;
    aux[(u32) 3382] = 108;
    aux[(u32) 3383] = 116;
    aux[(u32) 3384] = 0;
    aux[(u32) 3385] = 95;
    aux[(u32) 3386] = 48;
    aux[(u32) 3387] = 0;
    aux[(u32) 3388] = 97;
    aux[(u32) 3389] = 0;
    aux[(u32) 3390] = 95;
    aux[(u32) 3391] = 48;
    aux[(u32) 3392] = 0;
    aux[(u32) 3393] = 98;
    aux[(u32) 3394] = 0;
    aux[(u32) 3395] = 95;
    aux[(u32) 3396] = 48;
    aux[(u32) 3397] = 0;
    aux[(u32) 3398] = 114;
    aux[(u32) 3399] = 101;
    aux[(u32) 3400] = 115;
    aux[(u32) 3401] = 117;
    aux[(u32) 3402] = 108;
    aux[(u32) 3403] = 116;
    aux[(u32) 3404] = 0;
    aux[(u32) 3405] = 117;
    aux[(u32) 3406] = 51;
    aux[(u32) 3407] = 50;
    aux[(u32) 3408] = 0;
    aux[(u32) 3409] = 117;
    aux[(u32) 3410] = 51;
    aux[(u32) 3411] = 50;
    aux[(u32) 3412] = 95;
    aux[(u32) 3413] = 98;
    aux[(u32) 3414] = 105;
    aux[(u32) 3415] = 116;
    aux[(u32) 3416] = 95;
    aux[(u32) 3417] = 120;
    aux[(u32) 3418] = 111;
    aux[(u32) 3419] = 114;
    aux[(u32) 3420] = 0;
    aux[(u32) 3421] = 117;
    aux[(u32) 3422] = 51;
    aux[(u32) 3423] = 50;
    aux[(u32) 3424] = 0;
    aux[(u32) 3425] = 97;
    aux[(u32) 3426] = 0;
    aux[(u32) 3427] = 117;
    aux[(u32) 3428] = 51;
    aux[(u32) 3429] = 50;
    aux[(u32) 3430] = 0;
    aux[(u32) 3431] = 98;
    aux[(u32) 3432] = 0;
    aux[(u32) 3433] = 117;
    aux[(u32) 3434] = 51;
    aux[(u32) 3435] = 50;
    aux[(u32) 3436] = 0;
    aux[(u32) 3437] = 114;
    aux[(u32) 3438] = 101;
    aux[(u32) 3439] = 115;
    aux[(u32) 3440] = 117;
    aux[(u32) 3441] = 108;
    aux[(u32) 3442] = 116;
    aux[(u32) 3443] = 0;
    aux[(u32) 3444] = 114;
    aux[(u32) 3445] = 101;
    aux[(u32) 3446] = 115;
    aux[(u32) 3447] = 117;
    aux[(u32) 3448] = 108;
    aux[(u32) 3449] = 116;
    aux[(u32) 3450] = 0;
    aux[(u32) 3451] = 95;
    aux[(u32) 3452] = 51;
    aux[(u32) 3453] = 0;
    aux[(u32) 3454] = 97;
    aux[(u32) 3455] = 0;
    aux[(u32) 3456] = 95;
    aux[(u32) 3457] = 51;
    aux[(u32) 3458] = 0;
    aux[(u32) 3459] = 98;
    aux[(u32) 3460] = 0;
    aux[(u32) 3461] = 95;
    aux[(u32) 3462] = 51;
    aux[(u32) 3463] = 0;
    aux[(u32) 3464] = 114;
    aux[(u32) 3465] = 101;
    aux[(u32) 3466] = 115;
    aux[(u32) 3467] = 117;
    aux[(u32) 3468] = 108;
    aux[(u32) 3469] = 116;
    aux[(u32) 3470] = 0;
    aux[(u32) 3471] = 95;
    aux[(u32) 3472] = 50;
    aux[(u32) 3473] = 0;
    aux[(u32) 3474] = 97;
    aux[(u32) 3475] = 0;
    aux[(u32) 3476] = 95;
    aux[(u32) 3477] = 50;
    aux[(u32) 3478] = 0;
    aux[(u32) 3479] = 98;
    aux[(u32) 3480] = 0;
    aux[(u32) 3481] = 95;
    aux[(u32) 3482] = 50;
    aux[(u32) 3483] = 0;
    aux[(u32) 3484] = 114;
    aux[(u32) 3485] = 101;
    aux[(u32) 3486] = 115;
    aux[(u32) 3487] = 117;
    aux[(u32) 3488] = 108;
    aux[(u32) 3489] = 116;
    aux[(u32) 3490] = 0;
    aux[(u32) 3491] = 95;
    aux[(u32) 3492] = 49;
    aux[(u32) 3493] = 0;
    aux[(u32) 3494] = 97;
    aux[(u32) 3495] = 0;
    aux[(u32) 3496] = 95;
    aux[(u32) 3497] = 49;
    aux[(u32) 3498] = 0;
    aux[(u32) 3499] = 98;
    aux[(u32) 3500] = 0;
    aux[(u32) 3501] = 95;
    aux[(u32) 3502] = 49;
    aux[(u32) 3503] = 0;
    aux[(u32) 3504] = 114;
    aux[(u32) 3505] = 101;
    aux[(u32) 3506] = 115;
    aux[(u32) 3507] = 117;
    aux[(u32) 3508] = 108;
    aux[(u32) 3509] = 116;
    aux[(u32) 3510] = 0;
    aux[(u32) 3511] = 95;
    aux[(u32) 3512] = 48;
    aux[(u32) 3513] = 0;
    aux[(u32) 3514] = 97;
    aux[(u32) 3515] = 0;
    aux[(u32) 3516] = 95;
    aux[(u32) 3517] = 48;
    aux[(u32) 3518] = 0;
    aux[(u32) 3519] = 98;
    aux[(u32) 3520] = 0;
    aux[(u32) 3521] = 95;
    aux[(u32) 3522] = 48;
    aux[(u32) 3523] = 0;
    aux[(u32) 3524] = 114;
    aux[(u32) 3525] = 101;
    aux[(u32) 3526] = 115;
    aux[(u32) 3527] = 117;
    aux[(u32) 3528] = 108;
    aux[(u32) 3529] = 116;
    aux[(u32) 3530] = 0;
    aux[(u32) 3531] = 117;
    aux[(u32) 3532] = 51;
    aux[(u32) 3533] = 50;
    aux[(u32) 3534] = 0;
    aux[(u32) 3535] = 117;
    aux[(u32) 3536] = 51;
    aux[(u32) 3537] = 50;
    aux[(u32) 3538] = 95;
    aux[(u32) 3539] = 98;
    aux[(u32) 3540] = 105;
    aux[(u32) 3541] = 116;
    aux[(u32) 3542] = 95;
    aux[(u32) 3543] = 110;
    aux[(u32) 3544] = 101;
    aux[(u32) 3545] = 103;
    aux[(u32) 3546] = 0;
    aux[(u32) 3547] = 117;
    aux[(u32) 3548] = 51;
    aux[(u32) 3549] = 50;
    aux[(u32) 3550] = 0;
    aux[(u32) 3551] = 118;
    aux[(u32) 3552] = 97;
    aux[(u32) 3553] = 108;
    aux[(u32) 3554] = 117;
    aux[(u32) 3555] = 101;
    aux[(u32) 3556] = 0;
    aux[(u32) 3557] = 118;
    aux[(u32) 3558] = 97;
    aux[(u32) 3559] = 108;
    aux[(u32) 3560] = 117;
    aux[(u32) 3561] = 101;
    aux[(u32) 3562] = 0;
    aux[(u32) 3563] = 95;
    aux[(u32) 3564] = 48;
    aux[(u32) 3565] = 0;
    aux[(u32) 3566] = 118;
    aux[(u32) 3567] = 97;
    aux[(u32) 3568] = 108;
    aux[(u32) 3569] = 117;
    aux[(u32) 3570] = 101;
    aux[(u32) 3571] = 0;
    aux[(u32) 3572] = 95;
    aux[(u32) 3573] = 48;
    aux[(u32) 3574] = 0;
    aux[(u32) 3575] = 118;
    aux[(u32) 3576] = 97;
    aux[(u32) 3577] = 108;
    aux[(u32) 3578] = 117;
    aux[(u32) 3579] = 101;
    aux[(u32) 3580] = 0;
    aux[(u32) 3581] = 95;
    aux[(u32) 3582] = 49;
    aux[(u32) 3583] = 0;
    aux[(u32) 3584] = 118;
    aux[(u32) 3585] = 97;
    aux[(u32) 3586] = 108;
    aux[(u32) 3587] = 117;
    aux[(u32) 3588] = 101;
    aux[(u32) 3589] = 0;
    aux[(u32) 3590] = 95;
    aux[(u32) 3591] = 49;
    aux[(u32) 3592] = 0;
    aux[(u32) 3593] = 118;
    aux[(u32) 3594] = 97;
    aux[(u32) 3595] = 108;
    aux[(u32) 3596] = 117;
    aux[(u32) 3597] = 101;
    aux[(u32) 3598] = 0;
    aux[(u32) 3599] = 95;
    aux[(u32) 3600] = 50;
    aux[(u32) 3601] = 0;
    aux[(u32) 3602] = 118;
    aux[(u32) 3603] = 97;
    aux[(u32) 3604] = 108;
    aux[(u32) 3605] = 117;
    aux[(u32) 3606] = 101;
    aux[(u32) 3607] = 0;
    aux[(u32) 3608] = 95;
    aux[(u32) 3609] = 50;
    aux[(u32) 3610] = 0;
    aux[(u32) 3611] = 118;
    aux[(u32) 3612] = 97;
    aux[(u32) 3613] = 108;
    aux[(u32) 3614] = 117;
    aux[(u32) 3615] = 101;
    aux[(u32) 3616] = 0;
    aux[(u32) 3617] = 95;
    aux[(u32) 3618] = 51;
    aux[(u32) 3619] = 0;
    aux[(u32) 3620] = 118;
    aux[(u32) 3621] = 97;
    aux[(u32) 3622] = 108;
    aux[(u32) 3623] = 117;
    aux[(u32) 3624] = 101;
    aux[(u32) 3625] = 0;
    aux[(u32) 3626] = 95;
    aux[(u32) 3627] = 51;
    aux[(u32) 3628] = 0;
    aux[(u32) 3629] = 118;
    aux[(u32) 3630] = 97;
    aux[(u32) 3631] = 108;
    aux[(u32) 3632] = 117;
    aux[(u32) 3633] = 101;
    aux[(u32) 3634] = 0;
    aux[(u32) 3635] = 117;
    aux[(u32) 3636] = 48;
    aux[(u32) 3637] = 0;
    aux[(u32) 3638] = 112;
    aux[(u32) 3639] = 114;
    aux[(u32) 3640] = 105;
    aux[(u32) 3641] = 110;
    aux[(u32) 3642] = 116;
    aux[(u32) 3643] = 117;
    aux[(u32) 3644] = 51;
    aux[(u32) 3645] = 50;
    aux[(u32) 3646] = 104;
    aux[(u32) 3647] = 101;
    aux[(u32) 3648] = 120;
    aux[(u32) 3649] = 0;
    aux[(u32) 3650] = 117;
    aux[(u32) 3651] = 51;
    aux[(u32) 3652] = 50;
    aux[(u32) 3653] = 0;
    aux[(u32) 3654] = 118;
    aux[(u32) 3655] = 97;
    aux[(u32) 3656] = 108;
    aux[(u32) 3657] = 117;
    aux[(u32) 3658] = 101;
    aux[(u32) 3659] = 0;
    aux[(u32) 3660] = 112;
    aux[(u32) 3661] = 114;
    aux[(u32) 3662] = 105;
    aux[(u32) 3663] = 110;
    aux[(u32) 3664] = 116;
    aux[(u32) 3665] = 117;
    aux[(u32) 3666] = 56;
    aux[(u32) 3667] = 104;
    aux[(u32) 3668] = 101;
    aux[(u32) 3669] = 120;
    aux[(u32) 3670] = 0;
    aux[(u32) 3671] = 118;
    aux[(u32) 3672] = 97;
    aux[(u32) 3673] = 108;
    aux[(u32) 3674] = 117;
    aux[(u32) 3675] = 101;
    aux[(u32) 3676] = 0;
    aux[(u32) 3677] = 95;
    aux[(u32) 3678] = 51;
    aux[(u32) 3679] = 0;
    aux[(u32) 3680] = 112;
    aux[(u32) 3681] = 114;
    aux[(u32) 3682] = 105;
    aux[(u32) 3683] = 110;
    aux[(u32) 3684] = 116;
    aux[(u32) 3685] = 117;
    aux[(u32) 3686] = 56;
    aux[(u32) 3687] = 104;
    aux[(u32) 3688] = 101;
    aux[(u32) 3689] = 120;
    aux[(u32) 3690] = 0;
    aux[(u32) 3691] = 118;
    aux[(u32) 3692] = 97;
    aux[(u32) 3693] = 108;
    aux[(u32) 3694] = 117;
    aux[(u32) 3695] = 101;
    aux[(u32) 3696] = 0;
    aux[(u32) 3697] = 95;
    aux[(u32) 3698] = 50;
    aux[(u32) 3699] = 0;
    aux[(u32) 3700] = 112;
    aux[(u32) 3701] = 114;
    aux[(u32) 3702] = 105;
    aux[(u32) 3703] = 110;
    aux[(u32) 3704] = 116;
    aux[(u32) 3705] = 117;
    aux[(u32) 3706] = 56;
    aux[(u32) 3707] = 104;
    aux[(u32) 3708] = 101;
    aux[(u32) 3709] = 120;
    aux[(u32) 3710] = 0;
    aux[(u32) 3711] = 118;
    aux[(u32) 3712] = 97;
    aux[(u32) 3713] = 108;
    aux[(u32) 3714] = 117;
    aux[(u32) 3715] = 101;
    aux[(u32) 3716] = 0;
    aux[(u32) 3717] = 95;
    aux[(u32) 3718] = 49;
    aux[(u32) 3719] = 0;
    aux[(u32) 3720] = 112;
    aux[(u32) 3721] = 114;
    aux[(u32) 3722] = 105;
    aux[(u32) 3723] = 110;
    aux[(u32) 3724] = 116;
    aux[(u32) 3725] = 117;
    aux[(u32) 3726] = 56;
    aux[(u32) 3727] = 104;
    aux[(u32) 3728] = 101;
    aux[(u32) 3729] = 120;
    aux[(u32) 3730] = 0;
    aux[(u32) 3731] = 118;
    aux[(u32) 3732] = 97;
    aux[(u32) 3733] = 108;
    aux[(u32) 3734] = 117;
    aux[(u32) 3735] = 101;
    aux[(u32) 3736] = 0;
    aux[(u32) 3737] = 95;
    aux[(u32) 3738] = 48;
    aux[(u32) 3739] = 0;
    aux[(u32) 3740] = 117;
    aux[(u32) 3741] = 48;
    aux[(u32) 3742] = 0;
    aux[(u32) 3743] = 112;
    aux[(u32) 3744] = 114;
    aux[(u32) 3745] = 105;
    aux[(u32) 3746] = 110;
    aux[(u32) 3747] = 116;
    aux[(u32) 3748] = 117;
    aux[(u32) 3749] = 51;
    aux[(u32) 3750] = 50;
    aux[(u32) 3751] = 98;
    aux[(u32) 3752] = 105;
    aux[(u32) 3753] = 110;
    aux[(u32) 3754] = 0;
    aux[(u32) 3755] = 117;
    aux[(u32) 3756] = 51;
    aux[(u32) 3757] = 50;
    aux[(u32) 3758] = 0;
    aux[(u32) 3759] = 118;
    aux[(u32) 3760] = 97;
    aux[(u32) 3761] = 108;
    aux[(u32) 3762] = 117;
    aux[(u32) 3763] = 101;
    aux[(u32) 3764] = 0;
    aux[(u32) 3765] = 112;
    aux[(u32) 3766] = 114;
    aux[(u32) 3767] = 105;
    aux[(u32) 3768] = 110;
    aux[(u32) 3769] = 116;
    aux[(u32) 3770] = 117;
    aux[(u32) 3771] = 56;
    aux[(u32) 3772] = 98;
    aux[(u32) 3773] = 105;
    aux[(u32) 3774] = 110;
    aux[(u32) 3775] = 0;
    aux[(u32) 3776] = 118;
    aux[(u32) 3777] = 97;
    aux[(u32) 3778] = 108;
    aux[(u32) 3779] = 117;
    aux[(u32) 3780] = 101;
    aux[(u32) 3781] = 0;
    aux[(u32) 3782] = 95;
    aux[(u32) 3783] = 51;
    aux[(u32) 3784] = 0;
    aux[(u32) 3785] = 112;
    aux[(u32) 3786] = 117;
    aux[(u32) 3787] = 116;
    aux[(u32) 3788] = 0;
    aux[(u32) 3789] = 112;
    aux[(u32) 3790] = 114;
    aux[(u32) 3791] = 105;
    aux[(u32) 3792] = 110;
    aux[(u32) 3793] = 116;
    aux[(u32) 3794] = 117;
    aux[(u32) 3795] = 56;
    aux[(u32) 3796] = 98;
    aux[(u32) 3797] = 105;
    aux[(u32) 3798] = 110;
    aux[(u32) 3799] = 0;
    aux[(u32) 3800] = 118;
    aux[(u32) 3801] = 97;
    aux[(u32) 3802] = 108;
    aux[(u32) 3803] = 117;
    aux[(u32) 3804] = 101;
    aux[(u32) 3805] = 0;
    aux[(u32) 3806] = 95;
    aux[(u32) 3807] = 50;
    aux[(u32) 3808] = 0;
    aux[(u32) 3809] = 112;
    aux[(u32) 3810] = 117;
    aux[(u32) 3811] = 116;
    aux[(u32) 3812] = 0;
    aux[(u32) 3813] = 112;
    aux[(u32) 3814] = 114;
    aux[(u32) 3815] = 105;
    aux[(u32) 3816] = 110;
    aux[(u32) 3817] = 116;
    aux[(u32) 3818] = 117;
    aux[(u32) 3819] = 56;
    aux[(u32) 3820] = 98;
    aux[(u32) 3821] = 105;
    aux[(u32) 3822] = 110;
    aux[(u32) 3823] = 0;
    aux[(u32) 3824] = 118;
    aux[(u32) 3825] = 97;
    aux[(u32) 3826] = 108;
    aux[(u32) 3827] = 117;
    aux[(u32) 3828] = 101;
    aux[(u32) 3829] = 0;
    aux[(u32) 3830] = 95;
    aux[(u32) 3831] = 49;
    aux[(u32) 3832] = 0;
    aux[(u32) 3833] = 112;
    aux[(u32) 3834] = 117;
    aux[(u32) 3835] = 116;
    aux[(u32) 3836] = 0;
    aux[(u32) 3837] = 112;
    aux[(u32) 3838] = 114;
    aux[(u32) 3839] = 105;
    aux[(u32) 3840] = 110;
    aux[(u32) 3841] = 116;
    aux[(u32) 3842] = 117;
    aux[(u32) 3843] = 56;
    aux[(u32) 3844] = 98;
    aux[(u32) 3845] = 105;
    aux[(u32) 3846] = 110;
    aux[(u32) 3847] = 0;
    aux[(u32) 3848] = 118;
    aux[(u32) 3849] = 97;
    aux[(u32) 3850] = 108;
    aux[(u32) 3851] = 117;
    aux[(u32) 3852] = 101;
    aux[(u32) 3853] = 0;
    aux[(u32) 3854] = 95;
    aux[(u32) 3855] = 48;
    aux[(u32) 3856] = 0;
    aux[(u32) 3857] = 117;
    aux[(u32) 3858] = 51;
    aux[(u32) 3859] = 50;
    aux[(u32) 3860] = 0;
    aux[(u32) 3861] = 117;
    aux[(u32) 3862] = 51;
    aux[(u32) 3863] = 50;
    aux[(u32) 3864] = 95;
    aux[(u32) 3865] = 98;
    aux[(u32) 3866] = 105;
    aux[(u32) 3867] = 116;
    aux[(u32) 3868] = 95;
    aux[(u32) 3869] = 110;
    aux[(u32) 3870] = 101;
    aux[(u32) 3871] = 103;
    aux[(u32) 3872] = 0;
    aux[(u32) 3873] = 117;
    aux[(u32) 3874] = 51;
    aux[(u32) 3875] = 50;
    aux[(u32) 3876] = 0;
    aux[(u32) 3877] = 118;
    aux[(u32) 3878] = 97;
    aux[(u32) 3879] = 108;
    aux[(u32) 3880] = 117;
    aux[(u32) 3881] = 101;
    aux[(u32) 3882] = 0;
    aux[(u32) 3883] = 118;
    aux[(u32) 3884] = 97;
    aux[(u32) 3885] = 108;
    aux[(u32) 3886] = 117;
    aux[(u32) 3887] = 101;
    aux[(u32) 3888] = 0;
    aux[(u32) 3889] = 95;
    aux[(u32) 3890] = 48;
    aux[(u32) 3891] = 0;
    aux[(u32) 3892] = 118;
    aux[(u32) 3893] = 97;
    aux[(u32) 3894] = 108;
    aux[(u32) 3895] = 117;
    aux[(u32) 3896] = 101;
    aux[(u32) 3897] = 0;
    aux[(u32) 3898] = 95;
    aux[(u32) 3899] = 48;
    aux[(u32) 3900] = 0;
    aux[(u32) 3901] = 118;
    aux[(u32) 3902] = 97;
    aux[(u32) 3903] = 108;
    aux[(u32) 3904] = 117;
    aux[(u32) 3905] = 101;
    aux[(u32) 3906] = 0;
    aux[(u32) 3907] = 95;
    aux[(u32) 3908] = 49;
    aux[(u32) 3909] = 0;
    aux[(u32) 3910] = 118;
    aux[(u32) 3911] = 97;
    aux[(u32) 3912] = 108;
    aux[(u32) 3913] = 117;
    aux[(u32) 3914] = 101;
    aux[(u32) 3915] = 0;
    aux[(u32) 3916] = 95;
    aux[(u32) 3917] = 49;
    aux[(u32) 3918] = 0;
    aux[(u32) 3919] = 118;
    aux[(u32) 3920] = 97;
    aux[(u32) 3921] = 108;
    aux[(u32) 3922] = 117;
    aux[(u32) 3923] = 101;
    aux[(u32) 3924] = 0;
    aux[(u32) 3925] = 95;
    aux[(u32) 3926] = 50;
    aux[(u32) 3927] = 0;
    aux[(u32) 3928] = 118;
    aux[(u32) 3929] = 97;
    aux[(u32) 3930] = 108;
    aux[(u32) 3931] = 117;
    aux[(u32) 3932] = 101;
    aux[(u32) 3933] = 0;
    aux[(u32) 3934] = 95;
    aux[(u32) 3935] = 50;
    aux[(u32) 3936] = 0;
    aux[(u32) 3937] = 118;
    aux[(u32) 3938] = 97;
    aux[(u32) 3939] = 108;
    aux[(u32) 3940] = 117;
    aux[(u32) 3941] = 101;
    aux[(u32) 3942] = 0;
    aux[(u32) 3943] = 95;
    aux[(u32) 3944] = 51;
    aux[(u32) 3945] = 0;
    aux[(u32) 3946] = 118;
    aux[(u32) 3947] = 97;
    aux[(u32) 3948] = 108;
    aux[(u32) 3949] = 117;
    aux[(u32) 3950] = 101;
    aux[(u32) 3951] = 0;
    aux[(u32) 3952] = 95;
    aux[(u32) 3953] = 51;
    aux[(u32) 3954] = 0;
    aux[(u32) 3955] = 118;
    aux[(u32) 3956] = 97;
    aux[(u32) 3957] = 108;
    aux[(u32) 3958] = 117;
    aux[(u32) 3959] = 101;
    aux[(u32) 3960] = 0;
    aux[(u32) 3961] = 117;
    aux[(u32) 3962] = 51;
    aux[(u32) 3963] = 50;
    aux[(u32) 3964] = 0;
    aux[(u32) 3965] = 117;
    aux[(u32) 3966] = 51;
    aux[(u32) 3967] = 50;
    aux[(u32) 3968] = 95;
    aux[(u32) 3969] = 115;
    aux[(u32) 3970] = 117;
    aux[(u32) 3971] = 98;
    aux[(u32) 3972] = 0;
    aux[(u32) 3973] = 117;
    aux[(u32) 3974] = 51;
    aux[(u32) 3975] = 50;
    aux[(u32) 3976] = 0;
    aux[(u32) 3977] = 97;
    aux[(u32) 3978] = 0;
    aux[(u32) 3979] = 117;
    aux[(u32) 3980] = 51;
    aux[(u32) 3981] = 50;
    aux[(u32) 3982] = 0;
    aux[(u32) 3983] = 98;
    aux[(u32) 3984] = 0;
    aux[(u32) 3985] = 117;
    aux[(u32) 3986] = 51;
    aux[(u32) 3987] = 50;
    aux[(u32) 3988] = 0;
    aux[(u32) 3989] = 110;
    aux[(u32) 3990] = 101;
    aux[(u32) 3991] = 103;
    aux[(u32) 3992] = 97;
    aux[(u32) 3993] = 116;
    aux[(u32) 3994] = 105;
    aux[(u32) 3995] = 118;
    aux[(u32) 3996] = 101;
    aux[(u32) 3997] = 95;
    aux[(u32) 3998] = 98;
    aux[(u32) 3999] = 0;
    aux[(u32) 4000] = 117;
    aux[(u32) 4001] = 51;
    aux[(u32) 4002] = 50;
    aux[(u32) 4003] = 95;
    aux[(u32) 4004] = 97;
    aux[(u32) 4005] = 100;
    aux[(u32) 4006] = 100;
    aux[(u32) 4007] = 0;
    aux[(u32) 4008] = 117;
    aux[(u32) 4009] = 51;
    aux[(u32) 4010] = 50;
    aux[(u32) 4011] = 95;
    aux[(u32) 4012] = 98;
    aux[(u32) 4013] = 105;
    aux[(u32) 4014] = 116;
    aux[(u32) 4015] = 95;
    aux[(u32) 4016] = 110;
    aux[(u32) 4017] = 101;
    aux[(u32) 4018] = 103;
    aux[(u32) 4019] = 0;
    aux[(u32) 4020] = 98;
    aux[(u32) 4021] = 0;
    aux[(u32) 4022] = 117;
    aux[(u32) 4023] = 51;
    aux[(u32) 4024] = 50;
    aux[(u32) 4025] = 95;
    aux[(u32) 4026] = 97;
    aux[(u32) 4027] = 100;
    aux[(u32) 4028] = 100;
    aux[(u32) 4029] = 0;
    aux[(u32) 4030] = 97;
    aux[(u32) 4031] = 0;
    aux[(u32) 4032] = 110;
    aux[(u32) 4033] = 101;
    aux[(u32) 4034] = 103;
    aux[(u32) 4035] = 97;
    aux[(u32) 4036] = 116;
    aux[(u32) 4037] = 105;
    aux[(u32) 4038] = 118;
    aux[(u32) 4039] = 101;
    aux[(u32) 4040] = 95;
    aux[(u32) 4041] = 98;
    aux[(u32) 4042] = 0;
    aux[(u32) 4043] = 117;
    aux[(u32) 4044] = 51;
    aux[(u32) 4045] = 50;
    aux[(u32) 4046] = 0;
    aux[(u32) 4047] = 117;
    aux[(u32) 4048] = 51;
    aux[(u32) 4049] = 50;
    aux[(u32) 4050] = 95;
    aux[(u32) 4051] = 115;
    aux[(u32) 4052] = 108;
    aux[(u32) 4053] = 108;
    aux[(u32) 4054] = 0;
    aux[(u32) 4055] = 117;
    aux[(u32) 4056] = 51;
    aux[(u32) 4057] = 50;
    aux[(u32) 4058] = 0;
    aux[(u32) 4059] = 118;
    aux[(u32) 4060] = 97;
    aux[(u32) 4061] = 108;
    aux[(u32) 4062] = 117;
    aux[(u32) 4063] = 101;
    aux[(u32) 4064] = 0;
    aux[(u32) 4065] = 117;
    aux[(u32) 4066] = 56;
    aux[(u32) 4067] = 0;
    aux[(u32) 4068] = 97;
    aux[(u32) 4069] = 109;
    aux[(u32) 4070] = 111;
    aux[(u32) 4071] = 117;
    aux[(u32) 4072] = 110;
    aux[(u32) 4073] = 116;
    aux[(u32) 4074] = 0;
    aux[(u32) 4075] = 117;
    aux[(u32) 4076] = 51;
    aux[(u32) 4077] = 50;
    aux[(u32) 4078] = 0;
    aux[(u32) 4079] = 114;
    aux[(u32) 4080] = 101;
    aux[(u32) 4081] = 115;
    aux[(u32) 4082] = 117;
    aux[(u32) 4083] = 108;
    aux[(u32) 4084] = 116;
    aux[(u32) 4085] = 0;
    aux[(u32) 4086] = 97;
    aux[(u32) 4087] = 109;
    aux[(u32) 4088] = 111;
    aux[(u32) 4089] = 117;
    aux[(u32) 4090] = 110;
    aux[(u32) 4091] = 116;
    aux[(u32) 4092] = 0;
    aux[(u32) 4093] = 117;
    aux[(u32) 4094] = 56;
    aux[(u32) 4095] = 0;
    aux[(u32) 4096] = 98;
    aux[(u32) 4097] = 101;
    aux[(u32) 4098] = 116;
    aux[(u32) 4099] = 119;
    aux[(u32) 4100] = 101;
    aux[(u32) 4101] = 101;
    aux[(u32) 4102] = 110;
    aux[(u32) 4103] = 48;
    aux[(u32) 4104] = 49;
    aux[(u32) 4105] = 0;
    aux[(u32) 4106] = 118;
    aux[(u32) 4107] = 97;
    aux[(u32) 4108] = 108;
    aux[(u32) 4109] = 117;
    aux[(u32) 4110] = 101;
    aux[(u32) 4111] = 0;
    aux[(u32) 4112] = 95;
    aux[(u32) 4113] = 48;
    aux[(u32) 4114] = 0;
    aux[(u32) 4115] = 97;
    aux[(u32) 4116] = 109;
    aux[(u32) 4117] = 111;
    aux[(u32) 4118] = 117;
    aux[(u32) 4119] = 110;
    aux[(u32) 4120] = 116;
    aux[(u32) 4121] = 0;
    aux[(u32) 4122] = 117;
    aux[(u32) 4123] = 56;
    aux[(u32) 4124] = 0;
    aux[(u32) 4125] = 98;
    aux[(u32) 4126] = 101;
    aux[(u32) 4127] = 116;
    aux[(u32) 4128] = 119;
    aux[(u32) 4129] = 101;
    aux[(u32) 4130] = 101;
    aux[(u32) 4131] = 110;
    aux[(u32) 4132] = 49;
    aux[(u32) 4133] = 50;
    aux[(u32) 4134] = 0;
    aux[(u32) 4135] = 118;
    aux[(u32) 4136] = 97;
    aux[(u32) 4137] = 108;
    aux[(u32) 4138] = 117;
    aux[(u32) 4139] = 101;
    aux[(u32) 4140] = 0;
    aux[(u32) 4141] = 95;
    aux[(u32) 4142] = 49;
    aux[(u32) 4143] = 0;
    aux[(u32) 4144] = 97;
    aux[(u32) 4145] = 109;
    aux[(u32) 4146] = 111;
    aux[(u32) 4147] = 117;
    aux[(u32) 4148] = 110;
    aux[(u32) 4149] = 116;
    aux[(u32) 4150] = 0;
    aux[(u32) 4151] = 117;
    aux[(u32) 4152] = 56;
    aux[(u32) 4153] = 0;
    aux[(u32) 4154] = 98;
    aux[(u32) 4155] = 101;
    aux[(u32) 4156] = 116;
    aux[(u32) 4157] = 119;
    aux[(u32) 4158] = 101;
    aux[(u32) 4159] = 101;
    aux[(u32) 4160] = 110;
    aux[(u32) 4161] = 50;
    aux[(u32) 4162] = 51;
    aux[(u32) 4163] = 0;
    aux[(u32) 4164] = 118;
    aux[(u32) 4165] = 97;
    aux[(u32) 4166] = 108;
    aux[(u32) 4167] = 117;
    aux[(u32) 4168] = 101;
    aux[(u32) 4169] = 0;
    aux[(u32) 4170] = 95;
    aux[(u32) 4171] = 50;
    aux[(u32) 4172] = 0;
    aux[(u32) 4173] = 97;
    aux[(u32) 4174] = 109;
    aux[(u32) 4175] = 111;
    aux[(u32) 4176] = 117;
    aux[(u32) 4177] = 110;
    aux[(u32) 4178] = 116;
    aux[(u32) 4179] = 0;
    aux[(u32) 4180] = 114;
    aux[(u32) 4181] = 101;
    aux[(u32) 4182] = 115;
    aux[(u32) 4183] = 117;
    aux[(u32) 4184] = 108;
    aux[(u32) 4185] = 116;
    aux[(u32) 4186] = 0;
    aux[(u32) 4187] = 95;
    aux[(u32) 4188] = 51;
    aux[(u32) 4189] = 0;
    aux[(u32) 4190] = 118;
    aux[(u32) 4191] = 97;
    aux[(u32) 4192] = 108;
    aux[(u32) 4193] = 117;
    aux[(u32) 4194] = 101;
    aux[(u32) 4195] = 0;
    aux[(u32) 4196] = 95;
    aux[(u32) 4197] = 51;
    aux[(u32) 4198] = 0;
    aux[(u32) 4199] = 97;
    aux[(u32) 4200] = 109;
    aux[(u32) 4201] = 111;
    aux[(u32) 4202] = 117;
    aux[(u32) 4203] = 110;
    aux[(u32) 4204] = 116;
    aux[(u32) 4205] = 0;
    aux[(u32) 4206] = 98;
    aux[(u32) 4207] = 101;
    aux[(u32) 4208] = 116;
    aux[(u32) 4209] = 119;
    aux[(u32) 4210] = 101;
    aux[(u32) 4211] = 101;
    aux[(u32) 4212] = 110;
    aux[(u32) 4213] = 50;
    aux[(u32) 4214] = 51;
    aux[(u32) 4215] = 0;
    aux[(u32) 4216] = 114;
    aux[(u32) 4217] = 101;
    aux[(u32) 4218] = 115;
    aux[(u32) 4219] = 117;
    aux[(u32) 4220] = 108;
    aux[(u32) 4221] = 116;
    aux[(u32) 4222] = 0;
    aux[(u32) 4223] = 95;
    aux[(u32) 4224] = 50;
    aux[(u32) 4225] = 0;
    aux[(u32) 4226] = 118;
    aux[(u32) 4227] = 97;
    aux[(u32) 4228] = 108;
    aux[(u32) 4229] = 117;
    aux[(u32) 4230] = 101;
    aux[(u32) 4231] = 0;
    aux[(u32) 4232] = 95;
    aux[(u32) 4233] = 50;
    aux[(u32) 4234] = 0;
    aux[(u32) 4235] = 97;
    aux[(u32) 4236] = 109;
    aux[(u32) 4237] = 111;
    aux[(u32) 4238] = 117;
    aux[(u32) 4239] = 110;
    aux[(u32) 4240] = 116;
    aux[(u32) 4241] = 0;
    aux[(u32) 4242] = 98;
    aux[(u32) 4243] = 101;
    aux[(u32) 4244] = 116;
    aux[(u32) 4245] = 119;
    aux[(u32) 4246] = 101;
    aux[(u32) 4247] = 101;
    aux[(u32) 4248] = 110;
    aux[(u32) 4249] = 49;
    aux[(u32) 4250] = 50;
    aux[(u32) 4251] = 0;
    aux[(u32) 4252] = 114;
    aux[(u32) 4253] = 101;
    aux[(u32) 4254] = 115;
    aux[(u32) 4255] = 117;
    aux[(u32) 4256] = 108;
    aux[(u32) 4257] = 116;
    aux[(u32) 4258] = 0;
    aux[(u32) 4259] = 95;
    aux[(u32) 4260] = 49;
    aux[(u32) 4261] = 0;
    aux[(u32) 4262] = 118;
    aux[(u32) 4263] = 97;
    aux[(u32) 4264] = 108;
    aux[(u32) 4265] = 117;
    aux[(u32) 4266] = 101;
    aux[(u32) 4267] = 0;
    aux[(u32) 4268] = 95;
    aux[(u32) 4269] = 49;
    aux[(u32) 4270] = 0;
    aux[(u32) 4271] = 97;
    aux[(u32) 4272] = 109;
    aux[(u32) 4273] = 111;
    aux[(u32) 4274] = 117;
    aux[(u32) 4275] = 110;
    aux[(u32) 4276] = 116;
    aux[(u32) 4277] = 0;
    aux[(u32) 4278] = 98;
    aux[(u32) 4279] = 101;
    aux[(u32) 4280] = 116;
    aux[(u32) 4281] = 119;
    aux[(u32) 4282] = 101;
    aux[(u32) 4283] = 101;
    aux[(u32) 4284] = 110;
    aux[(u32) 4285] = 48;
    aux[(u32) 4286] = 49;
    aux[(u32) 4287] = 0;
    aux[(u32) 4288] = 114;
    aux[(u32) 4289] = 101;
    aux[(u32) 4290] = 115;
    aux[(u32) 4291] = 117;
    aux[(u32) 4292] = 108;
    aux[(u32) 4293] = 116;
    aux[(u32) 4294] = 0;
    aux[(u32) 4295] = 95;
    aux[(u32) 4296] = 48;
    aux[(u32) 4297] = 0;
    aux[(u32) 4298] = 118;
    aux[(u32) 4299] = 97;
    aux[(u32) 4300] = 108;
    aux[(u32) 4301] = 117;
    aux[(u32) 4302] = 101;
    aux[(u32) 4303] = 0;
    aux[(u32) 4304] = 95;
    aux[(u32) 4305] = 48;
    aux[(u32) 4306] = 0;
    aux[(u32) 4307] = 97;
    aux[(u32) 4308] = 109;
    aux[(u32) 4309] = 111;
    aux[(u32) 4310] = 117;
    aux[(u32) 4311] = 110;
    aux[(u32) 4312] = 116;
    aux[(u32) 4313] = 0;
    aux[(u32) 4314] = 97;
    aux[(u32) 4315] = 109;
    aux[(u32) 4316] = 111;
    aux[(u32) 4317] = 117;
    aux[(u32) 4318] = 110;
    aux[(u32) 4319] = 116;
    aux[(u32) 4320] = 0;
    aux[(u32) 4321] = 117;
    aux[(u32) 4322] = 56;
    aux[(u32) 4323] = 0;
    aux[(u32) 4324] = 98;
    aux[(u32) 4325] = 101;
    aux[(u32) 4326] = 116;
    aux[(u32) 4327] = 119;
    aux[(u32) 4328] = 101;
    aux[(u32) 4329] = 101;
    aux[(u32) 4330] = 110;
    aux[(u32) 4331] = 48;
    aux[(u32) 4332] = 49;
    aux[(u32) 4333] = 0;
    aux[(u32) 4334] = 118;
    aux[(u32) 4335] = 97;
    aux[(u32) 4336] = 108;
    aux[(u32) 4337] = 117;
    aux[(u32) 4338] = 101;
    aux[(u32) 4339] = 0;
    aux[(u32) 4340] = 95;
    aux[(u32) 4341] = 48;
    aux[(u32) 4342] = 0;
    aux[(u32) 4343] = 97;
    aux[(u32) 4344] = 109;
    aux[(u32) 4345] = 111;
    aux[(u32) 4346] = 117;
    aux[(u32) 4347] = 110;
    aux[(u32) 4348] = 116;
    aux[(u32) 4349] = 0;
    aux[(u32) 4350] = 117;
    aux[(u32) 4351] = 56;
    aux[(u32) 4352] = 0;
    aux[(u32) 4353] = 98;
    aux[(u32) 4354] = 101;
    aux[(u32) 4355] = 116;
    aux[(u32) 4356] = 119;
    aux[(u32) 4357] = 101;
    aux[(u32) 4358] = 101;
    aux[(u32) 4359] = 110;
    aux[(u32) 4360] = 49;
    aux[(u32) 4361] = 50;
    aux[(u32) 4362] = 0;
    aux[(u32) 4363] = 118;
    aux[(u32) 4364] = 97;
    aux[(u32) 4365] = 108;
    aux[(u32) 4366] = 117;
    aux[(u32) 4367] = 101;
    aux[(u32) 4368] = 0;
    aux[(u32) 4369] = 95;
    aux[(u32) 4370] = 49;
    aux[(u32) 4371] = 0;
    aux[(u32) 4372] = 97;
    aux[(u32) 4373] = 109;
    aux[(u32) 4374] = 111;
    aux[(u32) 4375] = 117;
    aux[(u32) 4376] = 110;
    aux[(u32) 4377] = 116;
    aux[(u32) 4378] = 0;
    aux[(u32) 4379] = 114;
    aux[(u32) 4380] = 101;
    aux[(u32) 4381] = 115;
    aux[(u32) 4382] = 117;
    aux[(u32) 4383] = 108;
    aux[(u32) 4384] = 116;
    aux[(u32) 4385] = 0;
    aux[(u32) 4386] = 95;
    aux[(u32) 4387] = 51;
    aux[(u32) 4388] = 0;
    aux[(u32) 4389] = 118;
    aux[(u32) 4390] = 97;
    aux[(u32) 4391] = 108;
    aux[(u32) 4392] = 117;
    aux[(u32) 4393] = 101;
    aux[(u32) 4394] = 0;
    aux[(u32) 4395] = 95;
    aux[(u32) 4396] = 50;
    aux[(u32) 4397] = 0;
    aux[(u32) 4398] = 97;
    aux[(u32) 4399] = 109;
    aux[(u32) 4400] = 111;
    aux[(u32) 4401] = 117;
    aux[(u32) 4402] = 110;
    aux[(u32) 4403] = 116;
    aux[(u32) 4404] = 0;
    aux[(u32) 4405] = 98;
    aux[(u32) 4406] = 101;
    aux[(u32) 4407] = 116;
    aux[(u32) 4408] = 119;
    aux[(u32) 4409] = 101;
    aux[(u32) 4410] = 101;
    aux[(u32) 4411] = 110;
    aux[(u32) 4412] = 49;
    aux[(u32) 4413] = 50;
    aux[(u32) 4414] = 0;
    aux[(u32) 4415] = 114;
    aux[(u32) 4416] = 101;
    aux[(u32) 4417] = 115;
    aux[(u32) 4418] = 117;
    aux[(u32) 4419] = 108;
    aux[(u32) 4420] = 116;
    aux[(u32) 4421] = 0;
    aux[(u32) 4422] = 95;
    aux[(u32) 4423] = 50;
    aux[(u32) 4424] = 0;
    aux[(u32) 4425] = 118;
    aux[(u32) 4426] = 97;
    aux[(u32) 4427] = 108;
    aux[(u32) 4428] = 117;
    aux[(u32) 4429] = 101;
    aux[(u32) 4430] = 0;
    aux[(u32) 4431] = 95;
    aux[(u32) 4432] = 49;
    aux[(u32) 4433] = 0;
    aux[(u32) 4434] = 97;
    aux[(u32) 4435] = 109;
    aux[(u32) 4436] = 111;
    aux[(u32) 4437] = 117;
    aux[(u32) 4438] = 110;
    aux[(u32) 4439] = 116;
    aux[(u32) 4440] = 0;
    aux[(u32) 4441] = 98;
    aux[(u32) 4442] = 101;
    aux[(u32) 4443] = 116;
    aux[(u32) 4444] = 119;
    aux[(u32) 4445] = 101;
    aux[(u32) 4446] = 101;
    aux[(u32) 4447] = 110;
    aux[(u32) 4448] = 48;
    aux[(u32) 4449] = 49;
    aux[(u32) 4450] = 0;
    aux[(u32) 4451] = 114;
    aux[(u32) 4452] = 101;
    aux[(u32) 4453] = 115;
    aux[(u32) 4454] = 117;
    aux[(u32) 4455] = 108;
    aux[(u32) 4456] = 116;
    aux[(u32) 4457] = 0;
    aux[(u32) 4458] = 95;
    aux[(u32) 4459] = 49;
    aux[(u32) 4460] = 0;
    aux[(u32) 4461] = 118;
    aux[(u32) 4462] = 97;
    aux[(u32) 4463] = 108;
    aux[(u32) 4464] = 117;
    aux[(u32) 4465] = 101;
    aux[(u32) 4466] = 0;
    aux[(u32) 4467] = 95;
    aux[(u32) 4468] = 48;
    aux[(u32) 4469] = 0;
    aux[(u32) 4470] = 97;
    aux[(u32) 4471] = 109;
    aux[(u32) 4472] = 111;
    aux[(u32) 4473] = 117;
    aux[(u32) 4474] = 110;
    aux[(u32) 4475] = 116;
    aux[(u32) 4476] = 0;
    aux[(u32) 4477] = 114;
    aux[(u32) 4478] = 101;
    aux[(u32) 4479] = 115;
    aux[(u32) 4480] = 117;
    aux[(u32) 4481] = 108;
    aux[(u32) 4482] = 116;
    aux[(u32) 4483] = 0;
    aux[(u32) 4484] = 95;
    aux[(u32) 4485] = 48;
    aux[(u32) 4486] = 0;
    aux[(u32) 4487] = 97;
    aux[(u32) 4488] = 109;
    aux[(u32) 4489] = 111;
    aux[(u32) 4490] = 117;
    aux[(u32) 4491] = 110;
    aux[(u32) 4492] = 116;
    aux[(u32) 4493] = 0;
    aux[(u32) 4494] = 117;
    aux[(u32) 4495] = 56;
    aux[(u32) 4496] = 0;
    aux[(u32) 4497] = 98;
    aux[(u32) 4498] = 101;
    aux[(u32) 4499] = 116;
    aux[(u32) 4500] = 119;
    aux[(u32) 4501] = 101;
    aux[(u32) 4502] = 101;
    aux[(u32) 4503] = 110;
    aux[(u32) 4504] = 48;
    aux[(u32) 4505] = 49;
    aux[(u32) 4506] = 0;
    aux[(u32) 4507] = 118;
    aux[(u32) 4508] = 97;
    aux[(u32) 4509] = 108;
    aux[(u32) 4510] = 117;
    aux[(u32) 4511] = 101;
    aux[(u32) 4512] = 0;
    aux[(u32) 4513] = 95;
    aux[(u32) 4514] = 48;
    aux[(u32) 4515] = 0;
    aux[(u32) 4516] = 97;
    aux[(u32) 4517] = 109;
    aux[(u32) 4518] = 111;
    aux[(u32) 4519] = 117;
    aux[(u32) 4520] = 110;
    aux[(u32) 4521] = 116;
    aux[(u32) 4522] = 0;
    aux[(u32) 4523] = 114;
    aux[(u32) 4524] = 101;
    aux[(u32) 4525] = 115;
    aux[(u32) 4526] = 117;
    aux[(u32) 4527] = 108;
    aux[(u32) 4528] = 116;
    aux[(u32) 4529] = 0;
    aux[(u32) 4530] = 95;
    aux[(u32) 4531] = 51;
    aux[(u32) 4532] = 0;
    aux[(u32) 4533] = 118;
    aux[(u32) 4534] = 97;
    aux[(u32) 4535] = 108;
    aux[(u32) 4536] = 117;
    aux[(u32) 4537] = 101;
    aux[(u32) 4538] = 0;
    aux[(u32) 4539] = 95;
    aux[(u32) 4540] = 49;
    aux[(u32) 4541] = 0;
    aux[(u32) 4542] = 97;
    aux[(u32) 4543] = 109;
    aux[(u32) 4544] = 111;
    aux[(u32) 4545] = 117;
    aux[(u32) 4546] = 110;
    aux[(u32) 4547] = 116;
    aux[(u32) 4548] = 0;
    aux[(u32) 4549] = 98;
    aux[(u32) 4550] = 101;
    aux[(u32) 4551] = 116;
    aux[(u32) 4552] = 119;
    aux[(u32) 4553] = 101;
    aux[(u32) 4554] = 101;
    aux[(u32) 4555] = 110;
    aux[(u32) 4556] = 48;
    aux[(u32) 4557] = 49;
    aux[(u32) 4558] = 0;
    aux[(u32) 4559] = 114;
    aux[(u32) 4560] = 101;
    aux[(u32) 4561] = 115;
    aux[(u32) 4562] = 117;
    aux[(u32) 4563] = 108;
    aux[(u32) 4564] = 116;
    aux[(u32) 4565] = 0;
    aux[(u32) 4566] = 95;
    aux[(u32) 4567] = 50;
    aux[(u32) 4568] = 0;
    aux[(u32) 4569] = 118;
    aux[(u32) 4570] = 97;
    aux[(u32) 4571] = 108;
    aux[(u32) 4572] = 117;
    aux[(u32) 4573] = 101;
    aux[(u32) 4574] = 0;
    aux[(u32) 4575] = 95;
    aux[(u32) 4576] = 48;
    aux[(u32) 4577] = 0;
    aux[(u32) 4578] = 97;
    aux[(u32) 4579] = 109;
    aux[(u32) 4580] = 111;
    aux[(u32) 4581] = 117;
    aux[(u32) 4582] = 110;
    aux[(u32) 4583] = 116;
    aux[(u32) 4584] = 0;
    aux[(u32) 4585] = 114;
    aux[(u32) 4586] = 101;
    aux[(u32) 4587] = 115;
    aux[(u32) 4588] = 117;
    aux[(u32) 4589] = 108;
    aux[(u32) 4590] = 116;
    aux[(u32) 4591] = 0;
    aux[(u32) 4592] = 95;
    aux[(u32) 4593] = 49;
    aux[(u32) 4594] = 0;
    aux[(u32) 4595] = 114;
    aux[(u32) 4596] = 101;
    aux[(u32) 4597] = 115;
    aux[(u32) 4598] = 117;
    aux[(u32) 4599] = 108;
    aux[(u32) 4600] = 116;
    aux[(u32) 4601] = 0;
    aux[(u32) 4602] = 95;
    aux[(u32) 4603] = 48;
    aux[(u32) 4604] = 0;
    aux[(u32) 4605] = 97;
    aux[(u32) 4606] = 109;
    aux[(u32) 4607] = 111;
    aux[(u32) 4608] = 117;
    aux[(u32) 4609] = 110;
    aux[(u32) 4610] = 116;
    aux[(u32) 4611] = 0;
    aux[(u32) 4612] = 114;
    aux[(u32) 4613] = 101;
    aux[(u32) 4614] = 115;
    aux[(u32) 4615] = 117;
    aux[(u32) 4616] = 108;
    aux[(u32) 4617] = 116;
    aux[(u32) 4618] = 0;
    aux[(u32) 4619] = 95;
    aux[(u32) 4620] = 51;
    aux[(u32) 4621] = 0;
    aux[(u32) 4622] = 118;
    aux[(u32) 4623] = 97;
    aux[(u32) 4624] = 108;
    aux[(u32) 4625] = 117;
    aux[(u32) 4626] = 101;
    aux[(u32) 4627] = 0;
    aux[(u32) 4628] = 95;
    aux[(u32) 4629] = 48;
    aux[(u32) 4630] = 0;
    aux[(u32) 4631] = 97;
    aux[(u32) 4632] = 109;
    aux[(u32) 4633] = 111;
    aux[(u32) 4634] = 117;
    aux[(u32) 4635] = 110;
    aux[(u32) 4636] = 116;
    aux[(u32) 4637] = 0;
    aux[(u32) 4638] = 114;
    aux[(u32) 4639] = 101;
    aux[(u32) 4640] = 115;
    aux[(u32) 4641] = 117;
    aux[(u32) 4642] = 108;
    aux[(u32) 4643] = 116;
    aux[(u32) 4644] = 0;
    aux[(u32) 4645] = 95;
    aux[(u32) 4646] = 50;
    aux[(u32) 4647] = 0;
    aux[(u32) 4648] = 114;
    aux[(u32) 4649] = 101;
    aux[(u32) 4650] = 115;
    aux[(u32) 4651] = 117;
    aux[(u32) 4652] = 108;
    aux[(u32) 4653] = 116;
    aux[(u32) 4654] = 0;
    aux[(u32) 4655] = 95;
    aux[(u32) 4656] = 49;
    aux[(u32) 4657] = 0;
    aux[(u32) 4658] = 114;
    aux[(u32) 4659] = 101;
    aux[(u32) 4660] = 115;
    aux[(u32) 4661] = 117;
    aux[(u32) 4662] = 108;
    aux[(u32) 4663] = 116;
    aux[(u32) 4664] = 0;
    aux[(u32) 4665] = 95;
    aux[(u32) 4666] = 48;
    aux[(u32) 4667] = 0;
    aux[(u32) 4668] = 114;
    aux[(u32) 4669] = 101;
    aux[(u32) 4670] = 115;
    aux[(u32) 4671] = 117;
    aux[(u32) 4672] = 108;
    aux[(u32) 4673] = 116;
    aux[(u32) 4674] = 0;
    aux[(u32) 4675] = 114;
    aux[(u32) 4676] = 101;
    aux[(u32) 4677] = 115;
    aux[(u32) 4678] = 117;
    aux[(u32) 4679] = 108;
    aux[(u32) 4680] = 116;
    aux[(u32) 4681] = 0;
    aux[(u32) 4682] = 117;
    aux[(u32) 4683] = 51;
    aux[(u32) 4684] = 50;
    aux[(u32) 4685] = 0;
    aux[(u32) 4686] = 117;
    aux[(u32) 4687] = 51;
    aux[(u32) 4688] = 50;
    aux[(u32) 4689] = 95;
    aux[(u32) 4690] = 115;
    aux[(u32) 4691] = 114;
    aux[(u32) 4692] = 108;
    aux[(u32) 4693] = 0;
    aux[(u32) 4694] = 117;
    aux[(u32) 4695] = 51;
    aux[(u32) 4696] = 50;
    aux[(u32) 4697] = 0;
    aux[(u32) 4698] = 118;
    aux[(u32) 4699] = 97;
    aux[(u32) 4700] = 108;
    aux[(u32) 4701] = 117;
    aux[(u32) 4702] = 101;
    aux[(u32) 4703] = 0;
    aux[(u32) 4704] = 117;
    aux[(u32) 4705] = 56;
    aux[(u32) 4706] = 0;
    aux[(u32) 4707] = 97;
    aux[(u32) 4708] = 109;
    aux[(u32) 4709] = 111;
    aux[(u32) 4710] = 117;
    aux[(u32) 4711] = 110;
    aux[(u32) 4712] = 116;
    aux[(u32) 4713] = 0;
    aux[(u32) 4714] = 117;
    aux[(u32) 4715] = 51;
    aux[(u32) 4716] = 50;
    aux[(u32) 4717] = 0;
    aux[(u32) 4718] = 114;
    aux[(u32) 4719] = 101;
    aux[(u32) 4720] = 115;
    aux[(u32) 4721] = 117;
    aux[(u32) 4722] = 108;
    aux[(u32) 4723] = 116;
    aux[(u32) 4724] = 0;
    aux[(u32) 4725] = 97;
    aux[(u32) 4726] = 109;
    aux[(u32) 4727] = 111;
    aux[(u32) 4728] = 117;
    aux[(u32) 4729] = 110;
    aux[(u32) 4730] = 116;
    aux[(u32) 4731] = 0;
    aux[(u32) 4732] = 117;
    aux[(u32) 4733] = 56;
    aux[(u32) 4734] = 0;
    aux[(u32) 4735] = 98;
    aux[(u32) 4736] = 101;
    aux[(u32) 4737] = 116;
    aux[(u32) 4738] = 119;
    aux[(u32) 4739] = 101;
    aux[(u32) 4740] = 101;
    aux[(u32) 4741] = 110;
    aux[(u32) 4742] = 48;
    aux[(u32) 4743] = 49;
    aux[(u32) 4744] = 0;
    aux[(u32) 4745] = 118;
    aux[(u32) 4746] = 97;
    aux[(u32) 4747] = 108;
    aux[(u32) 4748] = 117;
    aux[(u32) 4749] = 101;
    aux[(u32) 4750] = 0;
    aux[(u32) 4751] = 95;
    aux[(u32) 4752] = 49;
    aux[(u32) 4753] = 0;
    aux[(u32) 4754] = 97;
    aux[(u32) 4755] = 109;
    aux[(u32) 4756] = 111;
    aux[(u32) 4757] = 117;
    aux[(u32) 4758] = 110;
    aux[(u32) 4759] = 116;
    aux[(u32) 4760] = 0;
    aux[(u32) 4761] = 117;
    aux[(u32) 4762] = 56;
    aux[(u32) 4763] = 0;
    aux[(u32) 4764] = 98;
    aux[(u32) 4765] = 101;
    aux[(u32) 4766] = 116;
    aux[(u32) 4767] = 119;
    aux[(u32) 4768] = 101;
    aux[(u32) 4769] = 101;
    aux[(u32) 4770] = 110;
    aux[(u32) 4771] = 49;
    aux[(u32) 4772] = 50;
    aux[(u32) 4773] = 0;
    aux[(u32) 4774] = 118;
    aux[(u32) 4775] = 97;
    aux[(u32) 4776] = 108;
    aux[(u32) 4777] = 117;
    aux[(u32) 4778] = 101;
    aux[(u32) 4779] = 0;
    aux[(u32) 4780] = 95;
    aux[(u32) 4781] = 50;
    aux[(u32) 4782] = 0;
    aux[(u32) 4783] = 97;
    aux[(u32) 4784] = 109;
    aux[(u32) 4785] = 111;
    aux[(u32) 4786] = 117;
    aux[(u32) 4787] = 110;
    aux[(u32) 4788] = 116;
    aux[(u32) 4789] = 0;
    aux[(u32) 4790] = 117;
    aux[(u32) 4791] = 56;
    aux[(u32) 4792] = 0;
    aux[(u32) 4793] = 98;
    aux[(u32) 4794] = 101;
    aux[(u32) 4795] = 116;
    aux[(u32) 4796] = 119;
    aux[(u32) 4797] = 101;
    aux[(u32) 4798] = 101;
    aux[(u32) 4799] = 110;
    aux[(u32) 4800] = 50;
    aux[(u32) 4801] = 51;
    aux[(u32) 4802] = 0;
    aux[(u32) 4803] = 118;
    aux[(u32) 4804] = 97;
    aux[(u32) 4805] = 108;
    aux[(u32) 4806] = 117;
    aux[(u32) 4807] = 101;
    aux[(u32) 4808] = 0;
    aux[(u32) 4809] = 95;
    aux[(u32) 4810] = 51;
    aux[(u32) 4811] = 0;
    aux[(u32) 4812] = 97;
    aux[(u32) 4813] = 109;
    aux[(u32) 4814] = 111;
    aux[(u32) 4815] = 117;
    aux[(u32) 4816] = 110;
    aux[(u32) 4817] = 116;
    aux[(u32) 4818] = 0;
    aux[(u32) 4819] = 114;
    aux[(u32) 4820] = 101;
    aux[(u32) 4821] = 115;
    aux[(u32) 4822] = 117;
    aux[(u32) 4823] = 108;
    aux[(u32) 4824] = 116;
    aux[(u32) 4825] = 0;
    aux[(u32) 4826] = 95;
    aux[(u32) 4827] = 51;
    aux[(u32) 4828] = 0;
    aux[(u32) 4829] = 118;
    aux[(u32) 4830] = 97;
    aux[(u32) 4831] = 108;
    aux[(u32) 4832] = 117;
    aux[(u32) 4833] = 101;
    aux[(u32) 4834] = 0;
    aux[(u32) 4835] = 95;
    aux[(u32) 4836] = 51;
    aux[(u32) 4837] = 0;
    aux[(u32) 4838] = 97;
    aux[(u32) 4839] = 109;
    aux[(u32) 4840] = 111;
    aux[(u32) 4841] = 117;
    aux[(u32) 4842] = 110;
    aux[(u32) 4843] = 116;
    aux[(u32) 4844] = 0;
    aux[(u32) 4845] = 114;
    aux[(u32) 4846] = 101;
    aux[(u32) 4847] = 115;
    aux[(u32) 4848] = 117;
    aux[(u32) 4849] = 108;
    aux[(u32) 4850] = 116;
    aux[(u32) 4851] = 0;
    aux[(u32) 4852] = 95;
    aux[(u32) 4853] = 50;
    aux[(u32) 4854] = 0;
    aux[(u32) 4855] = 118;
    aux[(u32) 4856] = 97;
    aux[(u32) 4857] = 108;
    aux[(u32) 4858] = 117;
    aux[(u32) 4859] = 101;
    aux[(u32) 4860] = 0;
    aux[(u32) 4861] = 95;
    aux[(u32) 4862] = 50;
    aux[(u32) 4863] = 0;
    aux[(u32) 4864] = 97;
    aux[(u32) 4865] = 109;
    aux[(u32) 4866] = 111;
    aux[(u32) 4867] = 117;
    aux[(u32) 4868] = 110;
    aux[(u32) 4869] = 116;
    aux[(u32) 4870] = 0;
    aux[(u32) 4871] = 98;
    aux[(u32) 4872] = 101;
    aux[(u32) 4873] = 116;
    aux[(u32) 4874] = 119;
    aux[(u32) 4875] = 101;
    aux[(u32) 4876] = 101;
    aux[(u32) 4877] = 110;
    aux[(u32) 4878] = 50;
    aux[(u32) 4879] = 51;
    aux[(u32) 4880] = 0;
    aux[(u32) 4881] = 114;
    aux[(u32) 4882] = 101;
    aux[(u32) 4883] = 115;
    aux[(u32) 4884] = 117;
    aux[(u32) 4885] = 108;
    aux[(u32) 4886] = 116;
    aux[(u32) 4887] = 0;
    aux[(u32) 4888] = 95;
    aux[(u32) 4889] = 49;
    aux[(u32) 4890] = 0;
    aux[(u32) 4891] = 118;
    aux[(u32) 4892] = 97;
    aux[(u32) 4893] = 108;
    aux[(u32) 4894] = 117;
    aux[(u32) 4895] = 101;
    aux[(u32) 4896] = 0;
    aux[(u32) 4897] = 95;
    aux[(u32) 4898] = 49;
    aux[(u32) 4899] = 0;
    aux[(u32) 4900] = 97;
    aux[(u32) 4901] = 109;
    aux[(u32) 4902] = 111;
    aux[(u32) 4903] = 117;
    aux[(u32) 4904] = 110;
    aux[(u32) 4905] = 116;
    aux[(u32) 4906] = 0;
    aux[(u32) 4907] = 98;
    aux[(u32) 4908] = 101;
    aux[(u32) 4909] = 116;
    aux[(u32) 4910] = 119;
    aux[(u32) 4911] = 101;
    aux[(u32) 4912] = 101;
    aux[(u32) 4913] = 110;
    aux[(u32) 4914] = 49;
    aux[(u32) 4915] = 50;
    aux[(u32) 4916] = 0;
    aux[(u32) 4917] = 114;
    aux[(u32) 4918] = 101;
    aux[(u32) 4919] = 115;
    aux[(u32) 4920] = 117;
    aux[(u32) 4921] = 108;
    aux[(u32) 4922] = 116;
    aux[(u32) 4923] = 0;
    aux[(u32) 4924] = 95;
    aux[(u32) 4925] = 48;
    aux[(u32) 4926] = 0;
    aux[(u32) 4927] = 118;
    aux[(u32) 4928] = 97;
    aux[(u32) 4929] = 108;
    aux[(u32) 4930] = 117;
    aux[(u32) 4931] = 101;
    aux[(u32) 4932] = 0;
    aux[(u32) 4933] = 95;
    aux[(u32) 4934] = 48;
    aux[(u32) 4935] = 0;
    aux[(u32) 4936] = 97;
    aux[(u32) 4937] = 109;
    aux[(u32) 4938] = 111;
    aux[(u32) 4939] = 117;
    aux[(u32) 4940] = 110;
    aux[(u32) 4941] = 116;
    aux[(u32) 4942] = 0;
    aux[(u32) 4943] = 98;
    aux[(u32) 4944] = 101;
    aux[(u32) 4945] = 116;
    aux[(u32) 4946] = 119;
    aux[(u32) 4947] = 101;
    aux[(u32) 4948] = 101;
    aux[(u32) 4949] = 110;
    aux[(u32) 4950] = 48;
    aux[(u32) 4951] = 49;
    aux[(u32) 4952] = 0;
    aux[(u32) 4953] = 97;
    aux[(u32) 4954] = 109;
    aux[(u32) 4955] = 111;
    aux[(u32) 4956] = 117;
    aux[(u32) 4957] = 110;
    aux[(u32) 4958] = 116;
    aux[(u32) 4959] = 0;
    aux[(u32) 4960] = 117;
    aux[(u32) 4961] = 56;
    aux[(u32) 4962] = 0;
    aux[(u32) 4963] = 98;
    aux[(u32) 4964] = 101;
    aux[(u32) 4965] = 116;
    aux[(u32) 4966] = 119;
    aux[(u32) 4967] = 101;
    aux[(u32) 4968] = 101;
    aux[(u32) 4969] = 110;
    aux[(u32) 4970] = 48;
    aux[(u32) 4971] = 49;
    aux[(u32) 4972] = 0;
    aux[(u32) 4973] = 118;
    aux[(u32) 4974] = 97;
    aux[(u32) 4975] = 108;
    aux[(u32) 4976] = 117;
    aux[(u32) 4977] = 101;
    aux[(u32) 4978] = 0;
    aux[(u32) 4979] = 95;
    aux[(u32) 4980] = 50;
    aux[(u32) 4981] = 0;
    aux[(u32) 4982] = 97;
    aux[(u32) 4983] = 109;
    aux[(u32) 4984] = 111;
    aux[(u32) 4985] = 117;
    aux[(u32) 4986] = 110;
    aux[(u32) 4987] = 116;
    aux[(u32) 4988] = 0;
    aux[(u32) 4989] = 117;
    aux[(u32) 4990] = 56;
    aux[(u32) 4991] = 0;
    aux[(u32) 4992] = 98;
    aux[(u32) 4993] = 101;
    aux[(u32) 4994] = 116;
    aux[(u32) 4995] = 119;
    aux[(u32) 4996] = 101;
    aux[(u32) 4997] = 101;
    aux[(u32) 4998] = 110;
    aux[(u32) 4999] = 49;
    aux[(u32) 5000] = 50;
    aux[(u32) 5001] = 0;
    aux[(u32) 5002] = 118;
    aux[(u32) 5003] = 97;
    aux[(u32) 5004] = 108;
    aux[(u32) 5005] = 117;
    aux[(u32) 5006] = 101;
    aux[(u32) 5007] = 0;
    aux[(u32) 5008] = 95;
    aux[(u32) 5009] = 51;
    aux[(u32) 5010] = 0;
    aux[(u32) 5011] = 97;
    aux[(u32) 5012] = 109;
    aux[(u32) 5013] = 111;
    aux[(u32) 5014] = 117;
    aux[(u32) 5015] = 110;
    aux[(u32) 5016] = 116;
    aux[(u32) 5017] = 0;
    aux[(u32) 5018] = 114;
    aux[(u32) 5019] = 101;
    aux[(u32) 5020] = 115;
    aux[(u32) 5021] = 117;
    aux[(u32) 5022] = 108;
    aux[(u32) 5023] = 116;
    aux[(u32) 5024] = 0;
    aux[(u32) 5025] = 95;
    aux[(u32) 5026] = 51;
    aux[(u32) 5027] = 0;
    aux[(u32) 5028] = 114;
    aux[(u32) 5029] = 101;
    aux[(u32) 5030] = 115;
    aux[(u32) 5031] = 117;
    aux[(u32) 5032] = 108;
    aux[(u32) 5033] = 116;
    aux[(u32) 5034] = 0;
    aux[(u32) 5035] = 95;
    aux[(u32) 5036] = 50;
    aux[(u32) 5037] = 0;
    aux[(u32) 5038] = 118;
    aux[(u32) 5039] = 97;
    aux[(u32) 5040] = 108;
    aux[(u32) 5041] = 117;
    aux[(u32) 5042] = 101;
    aux[(u32) 5043] = 0;
    aux[(u32) 5044] = 95;
    aux[(u32) 5045] = 51;
    aux[(u32) 5046] = 0;
    aux[(u32) 5047] = 97;
    aux[(u32) 5048] = 109;
    aux[(u32) 5049] = 111;
    aux[(u32) 5050] = 117;
    aux[(u32) 5051] = 110;
    aux[(u32) 5052] = 116;
    aux[(u32) 5053] = 0;
    aux[(u32) 5054] = 114;
    aux[(u32) 5055] = 101;
    aux[(u32) 5056] = 115;
    aux[(u32) 5057] = 117;
    aux[(u32) 5058] = 108;
    aux[(u32) 5059] = 116;
    aux[(u32) 5060] = 0;
    aux[(u32) 5061] = 95;
    aux[(u32) 5062] = 49;
    aux[(u32) 5063] = 0;
    aux[(u32) 5064] = 118;
    aux[(u32) 5065] = 97;
    aux[(u32) 5066] = 108;
    aux[(u32) 5067] = 117;
    aux[(u32) 5068] = 101;
    aux[(u32) 5069] = 0;
    aux[(u32) 5070] = 95;
    aux[(u32) 5071] = 50;
    aux[(u32) 5072] = 0;
    aux[(u32) 5073] = 97;
    aux[(u32) 5074] = 109;
    aux[(u32) 5075] = 111;
    aux[(u32) 5076] = 117;
    aux[(u32) 5077] = 110;
    aux[(u32) 5078] = 116;
    aux[(u32) 5079] = 0;
    aux[(u32) 5080] = 98;
    aux[(u32) 5081] = 101;
    aux[(u32) 5082] = 116;
    aux[(u32) 5083] = 119;
    aux[(u32) 5084] = 101;
    aux[(u32) 5085] = 101;
    aux[(u32) 5086] = 110;
    aux[(u32) 5087] = 49;
    aux[(u32) 5088] = 50;
    aux[(u32) 5089] = 0;
    aux[(u32) 5090] = 114;
    aux[(u32) 5091] = 101;
    aux[(u32) 5092] = 115;
    aux[(u32) 5093] = 117;
    aux[(u32) 5094] = 108;
    aux[(u32) 5095] = 116;
    aux[(u32) 5096] = 0;
    aux[(u32) 5097] = 95;
    aux[(u32) 5098] = 48;
    aux[(u32) 5099] = 0;
    aux[(u32) 5100] = 118;
    aux[(u32) 5101] = 97;
    aux[(u32) 5102] = 108;
    aux[(u32) 5103] = 117;
    aux[(u32) 5104] = 101;
    aux[(u32) 5105] = 0;
    aux[(u32) 5106] = 95;
    aux[(u32) 5107] = 49;
    aux[(u32) 5108] = 0;
    aux[(u32) 5109] = 97;
    aux[(u32) 5110] = 109;
    aux[(u32) 5111] = 111;
    aux[(u32) 5112] = 117;
    aux[(u32) 5113] = 110;
    aux[(u32) 5114] = 116;
    aux[(u32) 5115] = 0;
    aux[(u32) 5116] = 98;
    aux[(u32) 5117] = 101;
    aux[(u32) 5118] = 116;
    aux[(u32) 5119] = 119;
    aux[(u32) 5120] = 101;
    aux[(u32) 5121] = 101;
    aux[(u32) 5122] = 110;
    aux[(u32) 5123] = 48;
    aux[(u32) 5124] = 49;
    aux[(u32) 5125] = 0;
    aux[(u32) 5126] = 97;
    aux[(u32) 5127] = 109;
    aux[(u32) 5128] = 111;
    aux[(u32) 5129] = 117;
    aux[(u32) 5130] = 110;
    aux[(u32) 5131] = 116;
    aux[(u32) 5132] = 0;
    aux[(u32) 5133] = 117;
    aux[(u32) 5134] = 56;
    aux[(u32) 5135] = 0;
    aux[(u32) 5136] = 98;
    aux[(u32) 5137] = 101;
    aux[(u32) 5138] = 116;
    aux[(u32) 5139] = 119;
    aux[(u32) 5140] = 101;
    aux[(u32) 5141] = 101;
    aux[(u32) 5142] = 110;
    aux[(u32) 5143] = 48;
    aux[(u32) 5144] = 49;
    aux[(u32) 5145] = 0;
    aux[(u32) 5146] = 118;
    aux[(u32) 5147] = 97;
    aux[(u32) 5148] = 108;
    aux[(u32) 5149] = 117;
    aux[(u32) 5150] = 101;
    aux[(u32) 5151] = 0;
    aux[(u32) 5152] = 95;
    aux[(u32) 5153] = 51;
    aux[(u32) 5154] = 0;
    aux[(u32) 5155] = 97;
    aux[(u32) 5156] = 109;
    aux[(u32) 5157] = 111;
    aux[(u32) 5158] = 117;
    aux[(u32) 5159] = 110;
    aux[(u32) 5160] = 116;
    aux[(u32) 5161] = 0;
    aux[(u32) 5162] = 114;
    aux[(u32) 5163] = 101;
    aux[(u32) 5164] = 115;
    aux[(u32) 5165] = 117;
    aux[(u32) 5166] = 108;
    aux[(u32) 5167] = 116;
    aux[(u32) 5168] = 0;
    aux[(u32) 5169] = 95;
    aux[(u32) 5170] = 51;
    aux[(u32) 5171] = 0;
    aux[(u32) 5172] = 114;
    aux[(u32) 5173] = 101;
    aux[(u32) 5174] = 115;
    aux[(u32) 5175] = 117;
    aux[(u32) 5176] = 108;
    aux[(u32) 5177] = 116;
    aux[(u32) 5178] = 0;
    aux[(u32) 5179] = 95;
    aux[(u32) 5180] = 50;
    aux[(u32) 5181] = 0;
    aux[(u32) 5182] = 114;
    aux[(u32) 5183] = 101;
    aux[(u32) 5184] = 115;
    aux[(u32) 5185] = 117;
    aux[(u32) 5186] = 108;
    aux[(u32) 5187] = 116;
    aux[(u32) 5188] = 0;
    aux[(u32) 5189] = 95;
    aux[(u32) 5190] = 49;
    aux[(u32) 5191] = 0;
    aux[(u32) 5192] = 118;
    aux[(u32) 5193] = 97;
    aux[(u32) 5194] = 108;
    aux[(u32) 5195] = 117;
    aux[(u32) 5196] = 101;
    aux[(u32) 5197] = 0;
    aux[(u32) 5198] = 95;
    aux[(u32) 5199] = 51;
    aux[(u32) 5200] = 0;
    aux[(u32) 5201] = 97;
    aux[(u32) 5202] = 109;
    aux[(u32) 5203] = 111;
    aux[(u32) 5204] = 117;
    aux[(u32) 5205] = 110;
    aux[(u32) 5206] = 116;
    aux[(u32) 5207] = 0;
    aux[(u32) 5208] = 114;
    aux[(u32) 5209] = 101;
    aux[(u32) 5210] = 115;
    aux[(u32) 5211] = 117;
    aux[(u32) 5212] = 108;
    aux[(u32) 5213] = 116;
    aux[(u32) 5214] = 0;
    aux[(u32) 5215] = 95;
    aux[(u32) 5216] = 48;
    aux[(u32) 5217] = 0;
    aux[(u32) 5218] = 118;
    aux[(u32) 5219] = 97;
    aux[(u32) 5220] = 108;
    aux[(u32) 5221] = 117;
    aux[(u32) 5222] = 101;
    aux[(u32) 5223] = 0;
    aux[(u32) 5224] = 95;
    aux[(u32) 5225] = 50;
    aux[(u32) 5226] = 0;
    aux[(u32) 5227] = 97;
    aux[(u32) 5228] = 109;
    aux[(u32) 5229] = 111;
    aux[(u32) 5230] = 117;
    aux[(u32) 5231] = 110;
    aux[(u32) 5232] = 116;
    aux[(u32) 5233] = 0;
    aux[(u32) 5234] = 98;
    aux[(u32) 5235] = 101;
    aux[(u32) 5236] = 116;
    aux[(u32) 5237] = 119;
    aux[(u32) 5238] = 101;
    aux[(u32) 5239] = 101;
    aux[(u32) 5240] = 110;
    aux[(u32) 5241] = 48;
    aux[(u32) 5242] = 49;
    aux[(u32) 5243] = 0;
    aux[(u32) 5244] = 97;
    aux[(u32) 5245] = 109;
    aux[(u32) 5246] = 111;
    aux[(u32) 5247] = 117;
    aux[(u32) 5248] = 110;
    aux[(u32) 5249] = 116;
    aux[(u32) 5250] = 0;
    aux[(u32) 5251] = 114;
    aux[(u32) 5252] = 101;
    aux[(u32) 5253] = 115;
    aux[(u32) 5254] = 117;
    aux[(u32) 5255] = 108;
    aux[(u32) 5256] = 116;
    aux[(u32) 5257] = 0;
    aux[(u32) 5258] = 95;
    aux[(u32) 5259] = 51;
    aux[(u32) 5260] = 0;
    aux[(u32) 5261] = 114;
    aux[(u32) 5262] = 101;
    aux[(u32) 5263] = 115;
    aux[(u32) 5264] = 117;
    aux[(u32) 5265] = 108;
    aux[(u32) 5266] = 116;
    aux[(u32) 5267] = 0;
    aux[(u32) 5268] = 95;
    aux[(u32) 5269] = 50;
    aux[(u32) 5270] = 0;
    aux[(u32) 5271] = 114;
    aux[(u32) 5272] = 101;
    aux[(u32) 5273] = 115;
    aux[(u32) 5274] = 117;
    aux[(u32) 5275] = 108;
    aux[(u32) 5276] = 116;
    aux[(u32) 5277] = 0;
    aux[(u32) 5278] = 95;
    aux[(u32) 5279] = 49;
    aux[(u32) 5280] = 0;
    aux[(u32) 5281] = 114;
    aux[(u32) 5282] = 101;
    aux[(u32) 5283] = 115;
    aux[(u32) 5284] = 117;
    aux[(u32) 5285] = 108;
    aux[(u32) 5286] = 116;
    aux[(u32) 5287] = 0;
    aux[(u32) 5288] = 95;
    aux[(u32) 5289] = 48;
    aux[(u32) 5290] = 0;
    aux[(u32) 5291] = 118;
    aux[(u32) 5292] = 97;
    aux[(u32) 5293] = 108;
    aux[(u32) 5294] = 117;
    aux[(u32) 5295] = 101;
    aux[(u32) 5296] = 0;
    aux[(u32) 5297] = 95;
    aux[(u32) 5298] = 51;
    aux[(u32) 5299] = 0;
    aux[(u32) 5300] = 97;
    aux[(u32) 5301] = 109;
    aux[(u32) 5302] = 111;
    aux[(u32) 5303] = 117;
    aux[(u32) 5304] = 110;
    aux[(u32) 5305] = 116;
    aux[(u32) 5306] = 0;
    aux[(u32) 5307] = 114;
    aux[(u32) 5308] = 101;
    aux[(u32) 5309] = 115;
    aux[(u32) 5310] = 117;
    aux[(u32) 5311] = 108;
    aux[(u32) 5312] = 116;
    aux[(u32) 5313] = 0;
    aux[(u32) 5314] = 114;
    aux[(u32) 5315] = 101;
    aux[(u32) 5316] = 115;
    aux[(u32) 5317] = 117;
    aux[(u32) 5318] = 108;
    aux[(u32) 5319] = 116;
    aux[(u32) 5320] = 0;
    aux[(u32) 5321] = 117;
    aux[(u32) 5322] = 51;
    aux[(u32) 5323] = 50;
    aux[(u32) 5324] = 0;
    aux[(u32) 5325] = 117;
    aux[(u32) 5326] = 51;
    aux[(u32) 5327] = 50;
    aux[(u32) 5328] = 95;
    aux[(u32) 5329] = 109;
    aux[(u32) 5330] = 117;
    aux[(u32) 5331] = 108;
    aux[(u32) 5332] = 0;
    aux[(u32) 5333] = 117;
    aux[(u32) 5334] = 51;
    aux[(u32) 5335] = 50;
    aux[(u32) 5336] = 0;
    aux[(u32) 5337] = 97;
    aux[(u32) 5338] = 0;
    aux[(u32) 5339] = 117;
    aux[(u32) 5340] = 51;
    aux[(u32) 5341] = 50;
    aux[(u32) 5342] = 0;
    aux[(u32) 5343] = 98;
    aux[(u32) 5344] = 0;
    aux[(u32) 5345] = 117;
    aux[(u32) 5346] = 49;
    aux[(u32) 5347] = 0;
    aux[(u32) 5348] = 97;
    aux[(u32) 5349] = 95;
    aux[(u32) 5350] = 98;
    aux[(u32) 5351] = 105;
    aux[(u32) 5352] = 116;
    aux[(u32) 5353] = 115;
    aux[(u32) 5354] = 0;
    aux[(u32) 5355] = 117;
    aux[(u32) 5356] = 56;
    aux[(u32) 5357] = 0;
    aux[(u32) 5358] = 105;
    aux[(u32) 5359] = 0;
    aux[(u32) 5360] = 105;
    aux[(u32) 5361] = 0;
    aux[(u32) 5362] = 105;
    aux[(u32) 5363] = 0;
    aux[(u32) 5364] = 97;
    aux[(u32) 5365] = 95;
    aux[(u32) 5366] = 98;
    aux[(u32) 5367] = 105;
    aux[(u32) 5368] = 116;
    aux[(u32) 5369] = 115;
    aux[(u32) 5370] = 0;
    aux[(u32) 5371] = 97;
    aux[(u32) 5372] = 95;
    aux[(u32) 5373] = 98;
    aux[(u32) 5374] = 105;
    aux[(u32) 5375] = 116;
    aux[(u32) 5376] = 115;
    aux[(u32) 5377] = 0;
    aux[(u32) 5378] = 105;
    aux[(u32) 5379] = 0;
    aux[(u32) 5380] = 117;
    aux[(u32) 5381] = 49;
    aux[(u32) 5382] = 0;
    aux[(u32) 5383] = 97;
    aux[(u32) 5384] = 0;
    aux[(u32) 5385] = 95;
    aux[(u32) 5386] = 51;
    aux[(u32) 5387] = 0;
    aux[(u32) 5388] = 105;
    aux[(u32) 5389] = 0;
    aux[(u32) 5390] = 117;
    aux[(u32) 5391] = 56;
    aux[(u32) 5392] = 0;
    aux[(u32) 5393] = 105;
    aux[(u32) 5394] = 0;
    aux[(u32) 5395] = 105;
    aux[(u32) 5396] = 0;
    aux[(u32) 5397] = 105;
    aux[(u32) 5398] = 0;
    aux[(u32) 5399] = 97;
    aux[(u32) 5400] = 95;
    aux[(u32) 5401] = 98;
    aux[(u32) 5402] = 105;
    aux[(u32) 5403] = 116;
    aux[(u32) 5404] = 115;
    aux[(u32) 5405] = 0;
    aux[(u32) 5406] = 97;
    aux[(u32) 5407] = 95;
    aux[(u32) 5408] = 98;
    aux[(u32) 5409] = 105;
    aux[(u32) 5410] = 116;
    aux[(u32) 5411] = 115;
    aux[(u32) 5412] = 0;
    aux[(u32) 5413] = 105;
    aux[(u32) 5414] = 0;
    aux[(u32) 5415] = 117;
    aux[(u32) 5416] = 49;
    aux[(u32) 5417] = 0;
    aux[(u32) 5418] = 97;
    aux[(u32) 5419] = 0;
    aux[(u32) 5420] = 95;
    aux[(u32) 5421] = 50;
    aux[(u32) 5422] = 0;
    aux[(u32) 5423] = 105;
    aux[(u32) 5424] = 0;
    aux[(u32) 5425] = 117;
    aux[(u32) 5426] = 56;
    aux[(u32) 5427] = 0;
    aux[(u32) 5428] = 105;
    aux[(u32) 5429] = 0;
    aux[(u32) 5430] = 105;
    aux[(u32) 5431] = 0;
    aux[(u32) 5432] = 105;
    aux[(u32) 5433] = 0;
    aux[(u32) 5434] = 97;
    aux[(u32) 5435] = 95;
    aux[(u32) 5436] = 98;
    aux[(u32) 5437] = 105;
    aux[(u32) 5438] = 116;
    aux[(u32) 5439] = 115;
    aux[(u32) 5440] = 0;
    aux[(u32) 5441] = 97;
    aux[(u32) 5442] = 95;
    aux[(u32) 5443] = 98;
    aux[(u32) 5444] = 105;
    aux[(u32) 5445] = 116;
    aux[(u32) 5446] = 115;
    aux[(u32) 5447] = 0;
    aux[(u32) 5448] = 105;
    aux[(u32) 5449] = 0;
    aux[(u32) 5450] = 117;
    aux[(u32) 5451] = 49;
    aux[(u32) 5452] = 0;
    aux[(u32) 5453] = 97;
    aux[(u32) 5454] = 0;
    aux[(u32) 5455] = 95;
    aux[(u32) 5456] = 49;
    aux[(u32) 5457] = 0;
    aux[(u32) 5458] = 105;
    aux[(u32) 5459] = 0;
    aux[(u32) 5460] = 117;
    aux[(u32) 5461] = 56;
    aux[(u32) 5462] = 0;
    aux[(u32) 5463] = 105;
    aux[(u32) 5464] = 0;
    aux[(u32) 5465] = 105;
    aux[(u32) 5466] = 0;
    aux[(u32) 5467] = 105;
    aux[(u32) 5468] = 0;
    aux[(u32) 5469] = 97;
    aux[(u32) 5470] = 95;
    aux[(u32) 5471] = 98;
    aux[(u32) 5472] = 105;
    aux[(u32) 5473] = 116;
    aux[(u32) 5474] = 115;
    aux[(u32) 5475] = 0;
    aux[(u32) 5476] = 97;
    aux[(u32) 5477] = 95;
    aux[(u32) 5478] = 98;
    aux[(u32) 5479] = 105;
    aux[(u32) 5480] = 116;
    aux[(u32) 5481] = 115;
    aux[(u32) 5482] = 0;
    aux[(u32) 5483] = 105;
    aux[(u32) 5484] = 0;
    aux[(u32) 5485] = 117;
    aux[(u32) 5486] = 49;
    aux[(u32) 5487] = 0;
    aux[(u32) 5488] = 97;
    aux[(u32) 5489] = 0;
    aux[(u32) 5490] = 95;
    aux[(u32) 5491] = 48;
    aux[(u32) 5492] = 0;
    aux[(u32) 5493] = 105;
    aux[(u32) 5494] = 0;
    aux[(u32) 5495] = 117;
    aux[(u32) 5496] = 51;
    aux[(u32) 5497] = 50;
    aux[(u32) 5498] = 0;
    aux[(u32) 5499] = 114;
    aux[(u32) 5500] = 0;
    aux[(u32) 5501] = 117;
    aux[(u32) 5502] = 56;
    aux[(u32) 5503] = 0;
    aux[(u32) 5504] = 105;
    aux[(u32) 5505] = 0;
    aux[(u32) 5506] = 105;
    aux[(u32) 5507] = 0;
    aux[(u32) 5508] = 97;
    aux[(u32) 5509] = 95;
    aux[(u32) 5510] = 98;
    aux[(u32) 5511] = 105;
    aux[(u32) 5512] = 116;
    aux[(u32) 5513] = 115;
    aux[(u32) 5514] = 0;
    aux[(u32) 5515] = 105;
    aux[(u32) 5516] = 0;
    aux[(u32) 5517] = 97;
    aux[(u32) 5518] = 95;
    aux[(u32) 5519] = 98;
    aux[(u32) 5520] = 105;
    aux[(u32) 5521] = 116;
    aux[(u32) 5522] = 115;
    aux[(u32) 5523] = 0;
    aux[(u32) 5524] = 105;
    aux[(u32) 5525] = 0;
    aux[(u32) 5526] = 114;
    aux[(u32) 5527] = 0;
    aux[(u32) 5528] = 117;
    aux[(u32) 5529] = 51;
    aux[(u32) 5530] = 50;
    aux[(u32) 5531] = 95;
    aux[(u32) 5532] = 97;
    aux[(u32) 5533] = 100;
    aux[(u32) 5534] = 100;
    aux[(u32) 5535] = 0;
    aux[(u32) 5536] = 114;
    aux[(u32) 5537] = 0;
    aux[(u32) 5538] = 117;
    aux[(u32) 5539] = 51;
    aux[(u32) 5540] = 50;
    aux[(u32) 5541] = 95;
    aux[(u32) 5542] = 115;
    aux[(u32) 5543] = 108;
    aux[(u32) 5544] = 108;
    aux[(u32) 5545] = 0;
    aux[(u32) 5546] = 98;
    aux[(u32) 5547] = 0;
    aux[(u32) 5548] = 105;
    aux[(u32) 5549] = 0;
    aux[(u32) 5550] = 114;
    aux[(u32) 5551] = 0;
    aux[(u32) 5552] = 117;
    aux[(u32) 5553] = 49;
    aux[(u32) 5554] = 0;
    aux[(u32) 5555] = 117;
    aux[(u32) 5556] = 51;
    aux[(u32) 5557] = 50;
    aux[(u32) 5558] = 95;
    aux[(u32) 5559] = 103;
    aux[(u32) 5560] = 116;
    aux[(u32) 5561] = 0;
    aux[(u32) 5562] = 117;
    aux[(u32) 5563] = 51;
    aux[(u32) 5564] = 50;
    aux[(u32) 5565] = 0;
    aux[(u32) 5566] = 97;
    aux[(u32) 5567] = 0;
    aux[(u32) 5568] = 117;
    aux[(u32) 5569] = 51;
    aux[(u32) 5570] = 50;
    aux[(u32) 5571] = 0;
    aux[(u32) 5572] = 98;
    aux[(u32) 5573] = 0;
    aux[(u32) 5574] = 97;
    aux[(u32) 5575] = 0;
    aux[(u32) 5576] = 95;
    aux[(u32) 5577] = 49;
    aux[(u32) 5578] = 117;
    aux[(u32) 5579] = 49;
    aux[(u32) 5580] = 54;
    aux[(u32) 5581] = 0;
    aux[(u32) 5582] = 98;
    aux[(u32) 5583] = 0;
    aux[(u32) 5584] = 95;
    aux[(u32) 5585] = 49;
    aux[(u32) 5586] = 117;
    aux[(u32) 5587] = 49;
    aux[(u32) 5588] = 54;
    aux[(u32) 5589] = 0;
    aux[(u32) 5590] = 97;
    aux[(u32) 5591] = 0;
    aux[(u32) 5592] = 95;
    aux[(u32) 5593] = 49;
    aux[(u32) 5594] = 117;
    aux[(u32) 5595] = 49;
    aux[(u32) 5596] = 54;
    aux[(u32) 5597] = 0;
    aux[(u32) 5598] = 98;
    aux[(u32) 5599] = 0;
    aux[(u32) 5600] = 95;
    aux[(u32) 5601] = 49;
    aux[(u32) 5602] = 117;
    aux[(u32) 5603] = 49;
    aux[(u32) 5604] = 54;
    aux[(u32) 5605] = 0;
    aux[(u32) 5606] = 97;
    aux[(u32) 5607] = 0;
    aux[(u32) 5608] = 95;
    aux[(u32) 5609] = 48;
    aux[(u32) 5610] = 117;
    aux[(u32) 5611] = 49;
    aux[(u32) 5612] = 54;
    aux[(u32) 5613] = 0;
    aux[(u32) 5614] = 98;
    aux[(u32) 5615] = 0;
    aux[(u32) 5616] = 95;
    aux[(u32) 5617] = 48;
    aux[(u32) 5618] = 117;
    aux[(u32) 5619] = 49;
    aux[(u32) 5620] = 54;
    aux[(u32) 5621] = 0;
    aux[(u32) 5622] = 117;
    aux[(u32) 5623] = 49;
    aux[(u32) 5624] = 0;
    aux[(u32) 5625] = 117;
    aux[(u32) 5626] = 51;
    aux[(u32) 5627] = 50;
    aux[(u32) 5628] = 95;
    aux[(u32) 5629] = 103;
    aux[(u32) 5630] = 116;
    aux[(u32) 5631] = 101;
    aux[(u32) 5632] = 0;
    aux[(u32) 5633] = 117;
    aux[(u32) 5634] = 51;
    aux[(u32) 5635] = 50;
    aux[(u32) 5636] = 0;
    aux[(u32) 5637] = 97;
    aux[(u32) 5638] = 0;
    aux[(u32) 5639] = 117;
    aux[(u32) 5640] = 51;
    aux[(u32) 5641] = 50;
    aux[(u32) 5642] = 0;
    aux[(u32) 5643] = 98;
    aux[(u32) 5644] = 0;
    aux[(u32) 5645] = 97;
    aux[(u32) 5646] = 0;
    aux[(u32) 5647] = 95;
    aux[(u32) 5648] = 49;
    aux[(u32) 5649] = 117;
    aux[(u32) 5650] = 49;
    aux[(u32) 5651] = 54;
    aux[(u32) 5652] = 0;
    aux[(u32) 5653] = 98;
    aux[(u32) 5654] = 0;
    aux[(u32) 5655] = 95;
    aux[(u32) 5656] = 49;
    aux[(u32) 5657] = 117;
    aux[(u32) 5658] = 49;
    aux[(u32) 5659] = 54;
    aux[(u32) 5660] = 0;
    aux[(u32) 5661] = 97;
    aux[(u32) 5662] = 0;
    aux[(u32) 5663] = 95;
    aux[(u32) 5664] = 49;
    aux[(u32) 5665] = 117;
    aux[(u32) 5666] = 49;
    aux[(u32) 5667] = 54;
    aux[(u32) 5668] = 0;
    aux[(u32) 5669] = 98;
    aux[(u32) 5670] = 0;
    aux[(u32) 5671] = 95;
    aux[(u32) 5672] = 49;
    aux[(u32) 5673] = 117;
    aux[(u32) 5674] = 49;
    aux[(u32) 5675] = 54;
    aux[(u32) 5676] = 0;
    aux[(u32) 5677] = 97;
    aux[(u32) 5678] = 0;
    aux[(u32) 5679] = 95;
    aux[(u32) 5680] = 48;
    aux[(u32) 5681] = 117;
    aux[(u32) 5682] = 49;
    aux[(u32) 5683] = 54;
    aux[(u32) 5684] = 0;
    aux[(u32) 5685] = 98;
    aux[(u32) 5686] = 0;
    aux[(u32) 5687] = 95;
    aux[(u32) 5688] = 48;
    aux[(u32) 5689] = 117;
    aux[(u32) 5690] = 49;
    aux[(u32) 5691] = 54;
    aux[(u32) 5692] = 0;
    aux[(u32) 5693] = 117;
    aux[(u32) 5694] = 49;
    aux[(u32) 5695] = 0;
    aux[(u32) 5696] = 117;
    aux[(u32) 5697] = 51;
    aux[(u32) 5698] = 50;
    aux[(u32) 5699] = 95;
    aux[(u32) 5700] = 108;
    aux[(u32) 5701] = 116;
    aux[(u32) 5702] = 0;
    aux[(u32) 5703] = 117;
    aux[(u32) 5704] = 51;
    aux[(u32) 5705] = 50;
    aux[(u32) 5706] = 0;
    aux[(u32) 5707] = 97;
    aux[(u32) 5708] = 0;
    aux[(u32) 5709] = 117;
    aux[(u32) 5710] = 51;
    aux[(u32) 5711] = 50;
    aux[(u32) 5712] = 0;
    aux[(u32) 5713] = 98;
    aux[(u32) 5714] = 0;
    aux[(u32) 5715] = 117;
    aux[(u32) 5716] = 51;
    aux[(u32) 5717] = 50;
    aux[(u32) 5718] = 95;
    aux[(u32) 5719] = 103;
    aux[(u32) 5720] = 116;
    aux[(u32) 5721] = 101;
    aux[(u32) 5722] = 0;
    aux[(u32) 5723] = 97;
    aux[(u32) 5724] = 0;
    aux[(u32) 5725] = 98;
    aux[(u32) 5726] = 0;
    aux[(u32) 5727] = 117;
    aux[(u32) 5728] = 49;
    aux[(u32) 5729] = 0;
    aux[(u32) 5730] = 117;
    aux[(u32) 5731] = 51;
    aux[(u32) 5732] = 50;
    aux[(u32) 5733] = 95;
    aux[(u32) 5734] = 108;
    aux[(u32) 5735] = 116;
    aux[(u32) 5736] = 101;
    aux[(u32) 5737] = 0;
    aux[(u32) 5738] = 117;
    aux[(u32) 5739] = 51;
    aux[(u32) 5740] = 50;
    aux[(u32) 5741] = 0;
    aux[(u32) 5742] = 97;
    aux[(u32) 5743] = 0;
    aux[(u32) 5744] = 117;
    aux[(u32) 5745] = 51;
    aux[(u32) 5746] = 50;
    aux[(u32) 5747] = 0;
    aux[(u32) 5748] = 98;
    aux[(u32) 5749] = 0;
    aux[(u32) 5750] = 117;
    aux[(u32) 5751] = 51;
    aux[(u32) 5752] = 50;
    aux[(u32) 5753] = 95;
    aux[(u32) 5754] = 103;
    aux[(u32) 5755] = 116;
    aux[(u32) 5756] = 0;
    aux[(u32) 5757] = 97;
    aux[(u32) 5758] = 0;
    aux[(u32) 5759] = 98;
    aux[(u32) 5760] = 0;
    aux[(u32) 5761] = 117;
    aux[(u32) 5762] = 49;
    aux[(u32) 5763] = 0;
    aux[(u32) 5764] = 117;
    aux[(u32) 5765] = 51;
    aux[(u32) 5766] = 50;
    aux[(u32) 5767] = 95;
    aux[(u32) 5768] = 101;
    aux[(u32) 5769] = 113;
    aux[(u32) 5770] = 0;
    aux[(u32) 5771] = 117;
    aux[(u32) 5772] = 51;
    aux[(u32) 5773] = 50;
    aux[(u32) 5774] = 0;
    aux[(u32) 5775] = 97;
    aux[(u32) 5776] = 0;
    aux[(u32) 5777] = 117;
    aux[(u32) 5778] = 51;
    aux[(u32) 5779] = 50;
    aux[(u32) 5780] = 0;
    aux[(u32) 5781] = 98;
    aux[(u32) 5782] = 0;
    aux[(u32) 5783] = 97;
    aux[(u32) 5784] = 0;
    aux[(u32) 5785] = 95;
    aux[(u32) 5786] = 48;
    aux[(u32) 5787] = 117;
    aux[(u32) 5788] = 49;
    aux[(u32) 5789] = 54;
    aux[(u32) 5790] = 0;
    aux[(u32) 5791] = 98;
    aux[(u32) 5792] = 0;
    aux[(u32) 5793] = 95;
    aux[(u32) 5794] = 48;
    aux[(u32) 5795] = 117;
    aux[(u32) 5796] = 49;
    aux[(u32) 5797] = 54;
    aux[(u32) 5798] = 0;
    aux[(u32) 5799] = 97;
    aux[(u32) 5800] = 0;
    aux[(u32) 5801] = 95;
    aux[(u32) 5802] = 49;
    aux[(u32) 5803] = 117;
    aux[(u32) 5804] = 49;
    aux[(u32) 5805] = 54;
    aux[(u32) 5806] = 0;
    aux[(u32) 5807] = 98;
    aux[(u32) 5808] = 0;
    aux[(u32) 5809] = 95;
    aux[(u32) 5810] = 49;
    aux[(u32) 5811] = 117;
    aux[(u32) 5812] = 49;
    aux[(u32) 5813] = 54;
    aux[(u32) 5814] = 0;
    aux[(u32) 5815] = 117;
    aux[(u32) 5816] = 51;
    aux[(u32) 5817] = 50;
    aux[(u32) 5818] = 0;
    aux[(u32) 5819] = 117;
    aux[(u32) 5820] = 51;
    aux[(u32) 5821] = 50;
    aux[(u32) 5822] = 95;
    aux[(u32) 5823] = 100;
    aux[(u32) 5824] = 105;
    aux[(u32) 5825] = 118;
    aux[(u32) 5826] = 0;
    aux[(u32) 5827] = 117;
    aux[(u32) 5828] = 51;
    aux[(u32) 5829] = 50;
    aux[(u32) 5830] = 0;
    aux[(u32) 5831] = 97;
    aux[(u32) 5832] = 0;
    aux[(u32) 5833] = 117;
    aux[(u32) 5834] = 51;
    aux[(u32) 5835] = 50;
    aux[(u32) 5836] = 0;
    aux[(u32) 5837] = 98;
    aux[(u32) 5838] = 0;
    aux[(u32) 5839] = 117;
    aux[(u32) 5840] = 51;
    aux[(u32) 5841] = 50;
    aux[(u32) 5842] = 0;
    aux[(u32) 5843] = 114;
    aux[(u32) 5844] = 0;
    aux[(u32) 5845] = 117;
    aux[(u32) 5846] = 51;
    aux[(u32) 5847] = 50;
    aux[(u32) 5848] = 95;
    aux[(u32) 5849] = 101;
    aux[(u32) 5850] = 113;
    aux[(u32) 5851] = 0;
    aux[(u32) 5852] = 98;
    aux[(u32) 5853] = 0;
    aux[(u32) 5854] = 114;
    aux[(u32) 5855] = 0;
    aux[(u32) 5856] = 97;
    aux[(u32) 5857] = 0;
    aux[(u32) 5858] = 117;
    aux[(u32) 5859] = 51;
    aux[(u32) 5860] = 50;
    aux[(u32) 5861] = 95;
    aux[(u32) 5862] = 101;
    aux[(u32) 5863] = 113;
    aux[(u32) 5864] = 0;
    aux[(u32) 5865] = 98;
    aux[(u32) 5866] = 0;
    aux[(u32) 5867] = 114;
    aux[(u32) 5868] = 0;
    aux[(u32) 5869] = 97;
    aux[(u32) 5870] = 0;
    aux[(u32) 5871] = 97;
    aux[(u32) 5872] = 0;
    aux[(u32) 5873] = 117;
    aux[(u32) 5874] = 51;
    aux[(u32) 5875] = 50;
    aux[(u32) 5876] = 0;
    aux[(u32) 5877] = 108;
    aux[(u32) 5878] = 105;
    aux[(u32) 5879] = 109;
    aux[(u32) 5880] = 105;
    aux[(u32) 5881] = 116;
    aux[(u32) 5882] = 115;
    aux[(u32) 5883] = 0;
    aux[(u32) 5884] = 117;
    aux[(u32) 5885] = 51;
    aux[(u32) 5886] = 50;
    aux[(u32) 5887] = 0;
    aux[(u32) 5888] = 109;
    aux[(u32) 5889] = 117;
    aux[(u32) 5890] = 108;
    aux[(u32) 5891] = 116;
    aux[(u32) 5892] = 105;
    aux[(u32) 5893] = 112;
    aux[(u32) 5894] = 108;
    aux[(u32) 5895] = 105;
    aux[(u32) 5896] = 101;
    aux[(u32) 5897] = 114;
    aux[(u32) 5898] = 115;
    aux[(u32) 5899] = 0;
    aux[(u32) 5900] = 108;
    aux[(u32) 5901] = 105;
    aux[(u32) 5902] = 109;
    aux[(u32) 5903] = 105;
    aux[(u32) 5904] = 116;
    aux[(u32) 5905] = 115;
    aux[(u32) 5906] = 0;
    aux[(u32) 5907] = 109;
    aux[(u32) 5908] = 117;
    aux[(u32) 5909] = 108;
    aux[(u32) 5910] = 116;
    aux[(u32) 5911] = 105;
    aux[(u32) 5912] = 112;
    aux[(u32) 5913] = 108;
    aux[(u32) 5914] = 105;
    aux[(u32) 5915] = 101;
    aux[(u32) 5916] = 114;
    aux[(u32) 5917] = 115;
    aux[(u32) 5918] = 0;
    aux[(u32) 5919] = 108;
    aux[(u32) 5920] = 105;
    aux[(u32) 5921] = 109;
    aux[(u32) 5922] = 105;
    aux[(u32) 5923] = 116;
    aux[(u32) 5924] = 115;
    aux[(u32) 5925] = 0;
    aux[(u32) 5926] = 109;
    aux[(u32) 5927] = 117;
    aux[(u32) 5928] = 108;
    aux[(u32) 5929] = 116;
    aux[(u32) 5930] = 105;
    aux[(u32) 5931] = 112;
    aux[(u32) 5932] = 108;
    aux[(u32) 5933] = 105;
    aux[(u32) 5934] = 101;
    aux[(u32) 5935] = 114;
    aux[(u32) 5936] = 115;
    aux[(u32) 5937] = 0;
    aux[(u32) 5938] = 108;
    aux[(u32) 5939] = 105;
    aux[(u32) 5940] = 109;
    aux[(u32) 5941] = 105;
    aux[(u32) 5942] = 116;
    aux[(u32) 5943] = 115;
    aux[(u32) 5944] = 0;
    aux[(u32) 5945] = 109;
    aux[(u32) 5946] = 117;
    aux[(u32) 5947] = 108;
    aux[(u32) 5948] = 116;
    aux[(u32) 5949] = 105;
    aux[(u32) 5950] = 112;
    aux[(u32) 5951] = 108;
    aux[(u32) 5952] = 105;
    aux[(u32) 5953] = 101;
    aux[(u32) 5954] = 114;
    aux[(u32) 5955] = 115;
    aux[(u32) 5956] = 0;
    aux[(u32) 5957] = 108;
    aux[(u32) 5958] = 105;
    aux[(u32) 5959] = 109;
    aux[(u32) 5960] = 105;
    aux[(u32) 5961] = 116;
    aux[(u32) 5962] = 115;
    aux[(u32) 5963] = 0;
    aux[(u32) 5964] = 109;
    aux[(u32) 5965] = 117;
    aux[(u32) 5966] = 108;
    aux[(u32) 5967] = 116;
    aux[(u32) 5968] = 105;
    aux[(u32) 5969] = 112;
    aux[(u32) 5970] = 108;
    aux[(u32) 5971] = 105;
    aux[(u32) 5972] = 101;
    aux[(u32) 5973] = 114;
    aux[(u32) 5974] = 115;
    aux[(u32) 5975] = 0;
    aux[(u32) 5976] = 108;
    aux[(u32) 5977] = 105;
    aux[(u32) 5978] = 109;
    aux[(u32) 5979] = 105;
    aux[(u32) 5980] = 116;
    aux[(u32) 5981] = 115;
    aux[(u32) 5982] = 0;
    aux[(u32) 5983] = 109;
    aux[(u32) 5984] = 117;
    aux[(u32) 5985] = 108;
    aux[(u32) 5986] = 116;
    aux[(u32) 5987] = 105;
    aux[(u32) 5988] = 112;
    aux[(u32) 5989] = 108;
    aux[(u32) 5990] = 105;
    aux[(u32) 5991] = 101;
    aux[(u32) 5992] = 114;
    aux[(u32) 5993] = 115;
    aux[(u32) 5994] = 0;
    aux[(u32) 5995] = 108;
    aux[(u32) 5996] = 105;
    aux[(u32) 5997] = 109;
    aux[(u32) 5998] = 105;
    aux[(u32) 5999] = 116;
    aux[(u32) 6000] = 115;
    aux[(u32) 6001] = 0;
    aux[(u32) 6002] = 109;
    aux[(u32) 6003] = 117;
    aux[(u32) 6004] = 108;
    aux[(u32) 6005] = 116;
    aux[(u32) 6006] = 105;
    aux[(u32) 6007] = 112;
    aux[(u32) 6008] = 108;
    aux[(u32) 6009] = 105;
    aux[(u32) 6010] = 101;
    aux[(u32) 6011] = 114;
    aux[(u32) 6012] = 115;
    aux[(u32) 6013] = 0;
    aux[(u32) 6014] = 108;
    aux[(u32) 6015] = 105;
    aux[(u32) 6016] = 109;
    aux[(u32) 6017] = 105;
    aux[(u32) 6018] = 116;
    aux[(u32) 6019] = 115;
    aux[(u32) 6020] = 0;
    aux[(u32) 6021] = 109;
    aux[(u32) 6022] = 117;
    aux[(u32) 6023] = 108;
    aux[(u32) 6024] = 116;
    aux[(u32) 6025] = 105;
    aux[(u32) 6026] = 112;
    aux[(u32) 6027] = 108;
    aux[(u32) 6028] = 105;
    aux[(u32) 6029] = 101;
    aux[(u32) 6030] = 114;
    aux[(u32) 6031] = 115;
    aux[(u32) 6032] = 0;
    aux[(u32) 6033] = 108;
    aux[(u32) 6034] = 105;
    aux[(u32) 6035] = 109;
    aux[(u32) 6036] = 105;
    aux[(u32) 6037] = 116;
    aux[(u32) 6038] = 115;
    aux[(u32) 6039] = 0;
    aux[(u32) 6040] = 109;
    aux[(u32) 6041] = 117;
    aux[(u32) 6042] = 108;
    aux[(u32) 6043] = 116;
    aux[(u32) 6044] = 105;
    aux[(u32) 6045] = 112;
    aux[(u32) 6046] = 108;
    aux[(u32) 6047] = 105;
    aux[(u32) 6048] = 101;
    aux[(u32) 6049] = 114;
    aux[(u32) 6050] = 115;
    aux[(u32) 6051] = 0;
    aux[(u32) 6052] = 108;
    aux[(u32) 6053] = 105;
    aux[(u32) 6054] = 109;
    aux[(u32) 6055] = 105;
    aux[(u32) 6056] = 116;
    aux[(u32) 6057] = 115;
    aux[(u32) 6058] = 0;
    aux[(u32) 6059] = 109;
    aux[(u32) 6060] = 117;
    aux[(u32) 6061] = 108;
    aux[(u32) 6062] = 116;
    aux[(u32) 6063] = 105;
    aux[(u32) 6064] = 112;
    aux[(u32) 6065] = 108;
    aux[(u32) 6066] = 105;
    aux[(u32) 6067] = 101;
    aux[(u32) 6068] = 114;
    aux[(u32) 6069] = 115;
    aux[(u32) 6070] = 0;
    aux[(u32) 6071] = 108;
    aux[(u32) 6072] = 105;
    aux[(u32) 6073] = 109;
    aux[(u32) 6074] = 105;
    aux[(u32) 6075] = 116;
    aux[(u32) 6076] = 115;
    aux[(u32) 6077] = 0;
    aux[(u32) 6078] = 109;
    aux[(u32) 6079] = 117;
    aux[(u32) 6080] = 108;
    aux[(u32) 6081] = 116;
    aux[(u32) 6082] = 105;
    aux[(u32) 6083] = 112;
    aux[(u32) 6084] = 108;
    aux[(u32) 6085] = 105;
    aux[(u32) 6086] = 101;
    aux[(u32) 6087] = 114;
    aux[(u32) 6088] = 115;
    aux[(u32) 6089] = 0;
    aux[(u32) 6090] = 108;
    aux[(u32) 6091] = 105;
    aux[(u32) 6092] = 109;
    aux[(u32) 6093] = 105;
    aux[(u32) 6094] = 116;
    aux[(u32) 6095] = 115;
    aux[(u32) 6096] = 0;
    aux[(u32) 6097] = 109;
    aux[(u32) 6098] = 117;
    aux[(u32) 6099] = 108;
    aux[(u32) 6100] = 116;
    aux[(u32) 6101] = 105;
    aux[(u32) 6102] = 112;
    aux[(u32) 6103] = 108;
    aux[(u32) 6104] = 105;
    aux[(u32) 6105] = 101;
    aux[(u32) 6106] = 114;
    aux[(u32) 6107] = 115;
    aux[(u32) 6108] = 0;
    aux[(u32) 6109] = 108;
    aux[(u32) 6110] = 105;
    aux[(u32) 6111] = 109;
    aux[(u32) 6112] = 105;
    aux[(u32) 6113] = 116;
    aux[(u32) 6114] = 115;
    aux[(u32) 6115] = 0;
    aux[(u32) 6116] = 109;
    aux[(u32) 6117] = 117;
    aux[(u32) 6118] = 108;
    aux[(u32) 6119] = 116;
    aux[(u32) 6120] = 105;
    aux[(u32) 6121] = 112;
    aux[(u32) 6122] = 108;
    aux[(u32) 6123] = 105;
    aux[(u32) 6124] = 101;
    aux[(u32) 6125] = 114;
    aux[(u32) 6126] = 115;
    aux[(u32) 6127] = 0;
    aux[(u32) 6128] = 108;
    aux[(u32) 6129] = 105;
    aux[(u32) 6130] = 109;
    aux[(u32) 6131] = 105;
    aux[(u32) 6132] = 116;
    aux[(u32) 6133] = 115;
    aux[(u32) 6134] = 0;
    aux[(u32) 6135] = 109;
    aux[(u32) 6136] = 117;
    aux[(u32) 6137] = 108;
    aux[(u32) 6138] = 116;
    aux[(u32) 6139] = 105;
    aux[(u32) 6140] = 112;
    aux[(u32) 6141] = 108;
    aux[(u32) 6142] = 105;
    aux[(u32) 6143] = 101;
    aux[(u32) 6144] = 114;
    aux[(u32) 6145] = 115;
    aux[(u32) 6146] = 0;
    aux[(u32) 6147] = 108;
    aux[(u32) 6148] = 105;
    aux[(u32) 6149] = 109;
    aux[(u32) 6150] = 105;
    aux[(u32) 6151] = 116;
    aux[(u32) 6152] = 115;
    aux[(u32) 6153] = 0;
    aux[(u32) 6154] = 109;
    aux[(u32) 6155] = 117;
    aux[(u32) 6156] = 108;
    aux[(u32) 6157] = 116;
    aux[(u32) 6158] = 105;
    aux[(u32) 6159] = 112;
    aux[(u32) 6160] = 108;
    aux[(u32) 6161] = 105;
    aux[(u32) 6162] = 101;
    aux[(u32) 6163] = 114;
    aux[(u32) 6164] = 115;
    aux[(u32) 6165] = 0;
    aux[(u32) 6166] = 108;
    aux[(u32) 6167] = 105;
    aux[(u32) 6168] = 109;
    aux[(u32) 6169] = 105;
    aux[(u32) 6170] = 116;
    aux[(u32) 6171] = 115;
    aux[(u32) 6172] = 0;
    aux[(u32) 6173] = 109;
    aux[(u32) 6174] = 117;
    aux[(u32) 6175] = 108;
    aux[(u32) 6176] = 116;
    aux[(u32) 6177] = 105;
    aux[(u32) 6178] = 112;
    aux[(u32) 6179] = 108;
    aux[(u32) 6180] = 105;
    aux[(u32) 6181] = 101;
    aux[(u32) 6182] = 114;
    aux[(u32) 6183] = 115;
    aux[(u32) 6184] = 0;
    aux[(u32) 6185] = 108;
    aux[(u32) 6186] = 105;
    aux[(u32) 6187] = 109;
    aux[(u32) 6188] = 105;
    aux[(u32) 6189] = 116;
    aux[(u32) 6190] = 115;
    aux[(u32) 6191] = 0;
    aux[(u32) 6192] = 109;
    aux[(u32) 6193] = 117;
    aux[(u32) 6194] = 108;
    aux[(u32) 6195] = 116;
    aux[(u32) 6196] = 105;
    aux[(u32) 6197] = 112;
    aux[(u32) 6198] = 108;
    aux[(u32) 6199] = 105;
    aux[(u32) 6200] = 101;
    aux[(u32) 6201] = 114;
    aux[(u32) 6202] = 115;
    aux[(u32) 6203] = 0;
    aux[(u32) 6204] = 108;
    aux[(u32) 6205] = 105;
    aux[(u32) 6206] = 109;
    aux[(u32) 6207] = 105;
    aux[(u32) 6208] = 116;
    aux[(u32) 6209] = 115;
    aux[(u32) 6210] = 0;
    aux[(u32) 6211] = 109;
    aux[(u32) 6212] = 117;
    aux[(u32) 6213] = 108;
    aux[(u32) 6214] = 116;
    aux[(u32) 6215] = 105;
    aux[(u32) 6216] = 112;
    aux[(u32) 6217] = 108;
    aux[(u32) 6218] = 105;
    aux[(u32) 6219] = 101;
    aux[(u32) 6220] = 114;
    aux[(u32) 6221] = 115;
    aux[(u32) 6222] = 0;
    aux[(u32) 6223] = 108;
    aux[(u32) 6224] = 105;
    aux[(u32) 6225] = 109;
    aux[(u32) 6226] = 105;
    aux[(u32) 6227] = 116;
    aux[(u32) 6228] = 115;
    aux[(u32) 6229] = 0;
    aux[(u32) 6230] = 109;
    aux[(u32) 6231] = 117;
    aux[(u32) 6232] = 108;
    aux[(u32) 6233] = 116;
    aux[(u32) 6234] = 105;
    aux[(u32) 6235] = 112;
    aux[(u32) 6236] = 108;
    aux[(u32) 6237] = 105;
    aux[(u32) 6238] = 101;
    aux[(u32) 6239] = 114;
    aux[(u32) 6240] = 115;
    aux[(u32) 6241] = 0;
    aux[(u32) 6242] = 108;
    aux[(u32) 6243] = 105;
    aux[(u32) 6244] = 109;
    aux[(u32) 6245] = 105;
    aux[(u32) 6246] = 116;
    aux[(u32) 6247] = 115;
    aux[(u32) 6248] = 0;
    aux[(u32) 6249] = 109;
    aux[(u32) 6250] = 117;
    aux[(u32) 6251] = 108;
    aux[(u32) 6252] = 116;
    aux[(u32) 6253] = 105;
    aux[(u32) 6254] = 112;
    aux[(u32) 6255] = 108;
    aux[(u32) 6256] = 105;
    aux[(u32) 6257] = 101;
    aux[(u32) 6258] = 114;
    aux[(u32) 6259] = 115;
    aux[(u32) 6260] = 0;
    aux[(u32) 6261] = 108;
    aux[(u32) 6262] = 105;
    aux[(u32) 6263] = 109;
    aux[(u32) 6264] = 105;
    aux[(u32) 6265] = 116;
    aux[(u32) 6266] = 115;
    aux[(u32) 6267] = 0;
    aux[(u32) 6268] = 109;
    aux[(u32) 6269] = 117;
    aux[(u32) 6270] = 108;
    aux[(u32) 6271] = 116;
    aux[(u32) 6272] = 105;
    aux[(u32) 6273] = 112;
    aux[(u32) 6274] = 108;
    aux[(u32) 6275] = 105;
    aux[(u32) 6276] = 101;
    aux[(u32) 6277] = 114;
    aux[(u32) 6278] = 115;
    aux[(u32) 6279] = 0;
    aux[(u32) 6280] = 108;
    aux[(u32) 6281] = 105;
    aux[(u32) 6282] = 109;
    aux[(u32) 6283] = 105;
    aux[(u32) 6284] = 116;
    aux[(u32) 6285] = 115;
    aux[(u32) 6286] = 0;
    aux[(u32) 6287] = 109;
    aux[(u32) 6288] = 117;
    aux[(u32) 6289] = 108;
    aux[(u32) 6290] = 116;
    aux[(u32) 6291] = 105;
    aux[(u32) 6292] = 112;
    aux[(u32) 6293] = 108;
    aux[(u32) 6294] = 105;
    aux[(u32) 6295] = 101;
    aux[(u32) 6296] = 114;
    aux[(u32) 6297] = 115;
    aux[(u32) 6298] = 0;
    aux[(u32) 6299] = 108;
    aux[(u32) 6300] = 105;
    aux[(u32) 6301] = 109;
    aux[(u32) 6302] = 105;
    aux[(u32) 6303] = 116;
    aux[(u32) 6304] = 115;
    aux[(u32) 6305] = 0;
    aux[(u32) 6306] = 109;
    aux[(u32) 6307] = 117;
    aux[(u32) 6308] = 108;
    aux[(u32) 6309] = 116;
    aux[(u32) 6310] = 105;
    aux[(u32) 6311] = 112;
    aux[(u32) 6312] = 108;
    aux[(u32) 6313] = 105;
    aux[(u32) 6314] = 101;
    aux[(u32) 6315] = 114;
    aux[(u32) 6316] = 115;
    aux[(u32) 6317] = 0;
    aux[(u32) 6318] = 108;
    aux[(u32) 6319] = 105;
    aux[(u32) 6320] = 109;
    aux[(u32) 6321] = 105;
    aux[(u32) 6322] = 116;
    aux[(u32) 6323] = 115;
    aux[(u32) 6324] = 0;
    aux[(u32) 6325] = 109;
    aux[(u32) 6326] = 117;
    aux[(u32) 6327] = 108;
    aux[(u32) 6328] = 116;
    aux[(u32) 6329] = 105;
    aux[(u32) 6330] = 112;
    aux[(u32) 6331] = 108;
    aux[(u32) 6332] = 105;
    aux[(u32) 6333] = 101;
    aux[(u32) 6334] = 114;
    aux[(u32) 6335] = 115;
    aux[(u32) 6336] = 0;
    aux[(u32) 6337] = 108;
    aux[(u32) 6338] = 105;
    aux[(u32) 6339] = 109;
    aux[(u32) 6340] = 105;
    aux[(u32) 6341] = 116;
    aux[(u32) 6342] = 115;
    aux[(u32) 6343] = 0;
    aux[(u32) 6344] = 109;
    aux[(u32) 6345] = 117;
    aux[(u32) 6346] = 108;
    aux[(u32) 6347] = 116;
    aux[(u32) 6348] = 105;
    aux[(u32) 6349] = 112;
    aux[(u32) 6350] = 108;
    aux[(u32) 6351] = 105;
    aux[(u32) 6352] = 101;
    aux[(u32) 6353] = 114;
    aux[(u32) 6354] = 115;
    aux[(u32) 6355] = 0;
    aux[(u32) 6356] = 108;
    aux[(u32) 6357] = 105;
    aux[(u32) 6358] = 109;
    aux[(u32) 6359] = 105;
    aux[(u32) 6360] = 116;
    aux[(u32) 6361] = 115;
    aux[(u32) 6362] = 0;
    aux[(u32) 6363] = 109;
    aux[(u32) 6364] = 117;
    aux[(u32) 6365] = 108;
    aux[(u32) 6366] = 116;
    aux[(u32) 6367] = 105;
    aux[(u32) 6368] = 112;
    aux[(u32) 6369] = 108;
    aux[(u32) 6370] = 105;
    aux[(u32) 6371] = 101;
    aux[(u32) 6372] = 114;
    aux[(u32) 6373] = 115;
    aux[(u32) 6374] = 0;
    aux[(u32) 6375] = 108;
    aux[(u32) 6376] = 105;
    aux[(u32) 6377] = 109;
    aux[(u32) 6378] = 105;
    aux[(u32) 6379] = 116;
    aux[(u32) 6380] = 115;
    aux[(u32) 6381] = 0;
    aux[(u32) 6382] = 109;
    aux[(u32) 6383] = 117;
    aux[(u32) 6384] = 108;
    aux[(u32) 6385] = 116;
    aux[(u32) 6386] = 105;
    aux[(u32) 6387] = 112;
    aux[(u32) 6388] = 108;
    aux[(u32) 6389] = 105;
    aux[(u32) 6390] = 101;
    aux[(u32) 6391] = 114;
    aux[(u32) 6392] = 115;
    aux[(u32) 6393] = 0;
    aux[(u32) 6394] = 108;
    aux[(u32) 6395] = 105;
    aux[(u32) 6396] = 109;
    aux[(u32) 6397] = 105;
    aux[(u32) 6398] = 116;
    aux[(u32) 6399] = 115;
    aux[(u32) 6400] = 0;
    aux[(u32) 6401] = 109;
    aux[(u32) 6402] = 117;
    aux[(u32) 6403] = 108;
    aux[(u32) 6404] = 116;
    aux[(u32) 6405] = 105;
    aux[(u32) 6406] = 112;
    aux[(u32) 6407] = 108;
    aux[(u32) 6408] = 105;
    aux[(u32) 6409] = 101;
    aux[(u32) 6410] = 114;
    aux[(u32) 6411] = 115;
    aux[(u32) 6412] = 0;
    aux[(u32) 6413] = 108;
    aux[(u32) 6414] = 105;
    aux[(u32) 6415] = 109;
    aux[(u32) 6416] = 105;
    aux[(u32) 6417] = 116;
    aux[(u32) 6418] = 115;
    aux[(u32) 6419] = 0;
    aux[(u32) 6420] = 109;
    aux[(u32) 6421] = 117;
    aux[(u32) 6422] = 108;
    aux[(u32) 6423] = 116;
    aux[(u32) 6424] = 105;
    aux[(u32) 6425] = 112;
    aux[(u32) 6426] = 108;
    aux[(u32) 6427] = 105;
    aux[(u32) 6428] = 101;
    aux[(u32) 6429] = 114;
    aux[(u32) 6430] = 115;
    aux[(u32) 6431] = 0;
    aux[(u32) 6432] = 108;
    aux[(u32) 6433] = 105;
    aux[(u32) 6434] = 109;
    aux[(u32) 6435] = 105;
    aux[(u32) 6436] = 116;
    aux[(u32) 6437] = 115;
    aux[(u32) 6438] = 0;
    aux[(u32) 6439] = 109;
    aux[(u32) 6440] = 117;
    aux[(u32) 6441] = 108;
    aux[(u32) 6442] = 116;
    aux[(u32) 6443] = 105;
    aux[(u32) 6444] = 112;
    aux[(u32) 6445] = 108;
    aux[(u32) 6446] = 105;
    aux[(u32) 6447] = 101;
    aux[(u32) 6448] = 114;
    aux[(u32) 6449] = 115;
    aux[(u32) 6450] = 0;
    aux[(u32) 6451] = 108;
    aux[(u32) 6452] = 105;
    aux[(u32) 6453] = 109;
    aux[(u32) 6454] = 105;
    aux[(u32) 6455] = 116;
    aux[(u32) 6456] = 115;
    aux[(u32) 6457] = 0;
    aux[(u32) 6458] = 109;
    aux[(u32) 6459] = 117;
    aux[(u32) 6460] = 108;
    aux[(u32) 6461] = 116;
    aux[(u32) 6462] = 105;
    aux[(u32) 6463] = 112;
    aux[(u32) 6464] = 108;
    aux[(u32) 6465] = 105;
    aux[(u32) 6466] = 101;
    aux[(u32) 6467] = 114;
    aux[(u32) 6468] = 115;
    aux[(u32) 6469] = 0;
    aux[(u32) 6470] = 117;
    aux[(u32) 6471] = 56;
    aux[(u32) 6472] = 0;
    aux[(u32) 6473] = 105;
    aux[(u32) 6474] = 0;
    aux[(u32) 6475] = 105;
    aux[(u32) 6476] = 0;
    aux[(u32) 6477] = 105;
    aux[(u32) 6478] = 0;
    aux[(u32) 6479] = 117;
    aux[(u32) 6480] = 51;
    aux[(u32) 6481] = 50;
    aux[(u32) 6482] = 95;
    aux[(u32) 6483] = 108;
    aux[(u32) 6484] = 116;
    aux[(u32) 6485] = 0;
    aux[(u32) 6486] = 98;
    aux[(u32) 6487] = 0;
    aux[(u32) 6488] = 108;
    aux[(u32) 6489] = 105;
    aux[(u32) 6490] = 109;
    aux[(u32) 6491] = 105;
    aux[(u32) 6492] = 116;
    aux[(u32) 6493] = 115;
    aux[(u32) 6494] = 0;
    aux[(u32) 6495] = 105;
    aux[(u32) 6496] = 0;
    aux[(u32) 6497] = 117;
    aux[(u32) 6498] = 51;
    aux[(u32) 6499] = 50;
    aux[(u32) 6500] = 0;
    aux[(u32) 6501] = 109;
    aux[(u32) 6502] = 117;
    aux[(u32) 6503] = 108;
    aux[(u32) 6504] = 116;
    aux[(u32) 6505] = 105;
    aux[(u32) 6506] = 112;
    aux[(u32) 6507] = 108;
    aux[(u32) 6508] = 105;
    aux[(u32) 6509] = 101;
    aux[(u32) 6510] = 114;
    aux[(u32) 6511] = 0;
    aux[(u32) 6512] = 109;
    aux[(u32) 6513] = 117;
    aux[(u32) 6514] = 108;
    aux[(u32) 6515] = 116;
    aux[(u32) 6516] = 105;
    aux[(u32) 6517] = 112;
    aux[(u32) 6518] = 108;
    aux[(u32) 6519] = 105;
    aux[(u32) 6520] = 101;
    aux[(u32) 6521] = 114;
    aux[(u32) 6522] = 115;
    aux[(u32) 6523] = 0;
    aux[(u32) 6524] = 105;
    aux[(u32) 6525] = 0;
    aux[(u32) 6526] = 117;
    aux[(u32) 6527] = 51;
    aux[(u32) 6528] = 50;
    aux[(u32) 6529] = 0;
    aux[(u32) 6530] = 115;
    aux[(u32) 6531] = 99;
    aux[(u32) 6532] = 97;
    aux[(u32) 6533] = 108;
    aux[(u32) 6534] = 101;
    aux[(u32) 6535] = 100;
    aux[(u32) 6536] = 0;
    aux[(u32) 6537] = 117;
    aux[(u32) 6538] = 51;
    aux[(u32) 6539] = 50;
    aux[(u32) 6540] = 95;
    aux[(u32) 6541] = 109;
    aux[(u32) 6542] = 117;
    aux[(u32) 6543] = 108;
    aux[(u32) 6544] = 0;
    aux[(u32) 6545] = 109;
    aux[(u32) 6546] = 117;
    aux[(u32) 6547] = 108;
    aux[(u32) 6548] = 116;
    aux[(u32) 6549] = 105;
    aux[(u32) 6550] = 112;
    aux[(u32) 6551] = 108;
    aux[(u32) 6552] = 105;
    aux[(u32) 6553] = 101;
    aux[(u32) 6554] = 114;
    aux[(u32) 6555] = 0;
    aux[(u32) 6556] = 98;
    aux[(u32) 6557] = 0;
    aux[(u32) 6558] = 117;
    aux[(u32) 6559] = 51;
    aux[(u32) 6560] = 50;
    aux[(u32) 6561] = 95;
    aux[(u32) 6562] = 103;
    aux[(u32) 6563] = 116;
    aux[(u32) 6564] = 101;
    aux[(u32) 6565] = 0;
    aux[(u32) 6566] = 97;
    aux[(u32) 6567] = 0;
    aux[(u32) 6568] = 115;
    aux[(u32) 6569] = 99;
    aux[(u32) 6570] = 97;
    aux[(u32) 6571] = 108;
    aux[(u32) 6572] = 101;
    aux[(u32) 6573] = 100;
    aux[(u32) 6574] = 0;
    aux[(u32) 6575] = 97;
    aux[(u32) 6576] = 0;
    aux[(u32) 6577] = 117;
    aux[(u32) 6578] = 51;
    aux[(u32) 6579] = 50;
    aux[(u32) 6580] = 95;
    aux[(u32) 6581] = 115;
    aux[(u32) 6582] = 117;
    aux[(u32) 6583] = 98;
    aux[(u32) 6584] = 0;
    aux[(u32) 6585] = 97;
    aux[(u32) 6586] = 0;
    aux[(u32) 6587] = 115;
    aux[(u32) 6588] = 99;
    aux[(u32) 6589] = 97;
    aux[(u32) 6590] = 108;
    aux[(u32) 6591] = 101;
    aux[(u32) 6592] = 100;
    aux[(u32) 6593] = 0;
    aux[(u32) 6594] = 114;
    aux[(u32) 6595] = 0;
    aux[(u32) 6596] = 117;
    aux[(u32) 6597] = 51;
    aux[(u32) 6598] = 50;
    aux[(u32) 6599] = 95;
    aux[(u32) 6600] = 97;
    aux[(u32) 6601] = 100;
    aux[(u32) 6602] = 100;
    aux[(u32) 6603] = 0;
    aux[(u32) 6604] = 114;
    aux[(u32) 6605] = 0;
    aux[(u32) 6606] = 109;
    aux[(u32) 6607] = 117;
    aux[(u32) 6608] = 108;
    aux[(u32) 6609] = 116;
    aux[(u32) 6610] = 105;
    aux[(u32) 6611] = 112;
    aux[(u32) 6612] = 108;
    aux[(u32) 6613] = 105;
    aux[(u32) 6614] = 101;
    aux[(u32) 6615] = 114;
    aux[(u32) 6616] = 0;
    aux[(u32) 6617] = 117;
    aux[(u32) 6618] = 51;
    aux[(u32) 6619] = 50;
    aux[(u32) 6620] = 95;
    aux[(u32) 6621] = 103;
    aux[(u32) 6622] = 116;
    aux[(u32) 6623] = 101;
    aux[(u32) 6624] = 0;
    aux[(u32) 6625] = 97;
    aux[(u32) 6626] = 0;
    aux[(u32) 6627] = 98;
    aux[(u32) 6628] = 0;
    aux[(u32) 6629] = 97;
    aux[(u32) 6630] = 0;
    aux[(u32) 6631] = 117;
    aux[(u32) 6632] = 51;
    aux[(u32) 6633] = 50;
    aux[(u32) 6634] = 95;
    aux[(u32) 6635] = 115;
    aux[(u32) 6636] = 117;
    aux[(u32) 6637] = 98;
    aux[(u32) 6638] = 0;
    aux[(u32) 6639] = 97;
    aux[(u32) 6640] = 0;
    aux[(u32) 6641] = 98;
    aux[(u32) 6642] = 0;
    aux[(u32) 6643] = 114;
    aux[(u32) 6644] = 0;
    aux[(u32) 6645] = 117;
    aux[(u32) 6646] = 51;
    aux[(u32) 6647] = 50;
    aux[(u32) 6648] = 95;
    aux[(u32) 6649] = 97;
    aux[(u32) 6650] = 100;
    aux[(u32) 6651] = 100;
    aux[(u32) 6652] = 0;
    aux[(u32) 6653] = 114;
    aux[(u32) 6654] = 0;
    aux[(u32) 6655] = 114;
    aux[(u32) 6656] = 0;
    aux[(u32) 6657] = 117;
    aux[(u32) 6658] = 51;
    aux[(u32) 6659] = 50;
    aux[(u32) 6660] = 0;
    aux[(u32) 6661] = 117;
    aux[(u32) 6662] = 51;
    aux[(u32) 6663] = 50;
    aux[(u32) 6664] = 95;
    aux[(u32) 6665] = 109;
    aux[(u32) 6666] = 111;
    aux[(u32) 6667] = 100;
    aux[(u32) 6668] = 0;
    aux[(u32) 6669] = 117;
    aux[(u32) 6670] = 51;
    aux[(u32) 6671] = 50;
    aux[(u32) 6672] = 0;
    aux[(u32) 6673] = 97;
    aux[(u32) 6674] = 0;
    aux[(u32) 6675] = 117;
    aux[(u32) 6676] = 51;
    aux[(u32) 6677] = 50;
    aux[(u32) 6678] = 0;
    aux[(u32) 6679] = 98;
    aux[(u32) 6680] = 0;
    aux[(u32) 6681] = 117;
    aux[(u32) 6682] = 51;
    aux[(u32) 6683] = 50;
    aux[(u32) 6684] = 95;
    aux[(u32) 6685] = 115;
    aux[(u32) 6686] = 117;
    aux[(u32) 6687] = 98;
    aux[(u32) 6688] = 0;
    aux[(u32) 6689] = 97;
    aux[(u32) 6690] = 0;
    aux[(u32) 6691] = 117;
    aux[(u32) 6692] = 51;
    aux[(u32) 6693] = 50;
    aux[(u32) 6694] = 95;
    aux[(u32) 6695] = 109;
    aux[(u32) 6696] = 117;
    aux[(u32) 6697] = 108;
    aux[(u32) 6698] = 0;
    aux[(u32) 6699] = 117;
    aux[(u32) 6700] = 51;
    aux[(u32) 6701] = 50;
    aux[(u32) 6702] = 95;
    aux[(u32) 6703] = 100;
    aux[(u32) 6704] = 105;
    aux[(u32) 6705] = 118;
    aux[(u32) 6706] = 0;
    aux[(u32) 6707] = 97;
    aux[(u32) 6708] = 0;
    aux[(u32) 6709] = 98;
    aux[(u32) 6710] = 0;
    aux[(u32) 6711] = 98;
    aux[(u32) 6712] = 0;
    num_aux += 6713;
    // Assume that num_tokens + delta_tokens < AUX_CAPACITY
    tokens[(u32) 0] = (Token){ .kind = (TokenKind) 5, .data = (u32) 0 };
    tokens[(u32) 1] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4 };
    tokens[(u32) 2] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3] = (Token){ .kind = (TokenKind) 5, .data = (u32) 16 };
    tokens[(u32) 4] = (Token){ .kind = (TokenKind) 5, .data = (u32) 19 };
    tokens[(u32) 5] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 6] = (Token){ .kind = (TokenKind) 5, .data = (u32) 21 };
    tokens[(u32) 7] = (Token){ .kind = (TokenKind) 5, .data = (u32) 24 };
    tokens[(u32) 8] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 9] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 10] = (Token){ .kind = (TokenKind) 5, .data = (u32) 26 };
    tokens[(u32) 11] = (Token){ .kind = (TokenKind) 5, .data = (u32) 30 };
    tokens[(u32) 12] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 13] = (Token){ .kind = (TokenKind) 5, .data = (u32) 37 };
    tokens[(u32) 14] = (Token){ .kind = (TokenKind) 5, .data = (u32) 40 };
    tokens[(u32) 15] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 16] = (Token){ .kind = (TokenKind) 5, .data = (u32) 46 };
    tokens[(u32) 17] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 18] = (Token){ .kind = (TokenKind) 5, .data = (u32) 48 };
    tokens[(u32) 19] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 20] = (Token){ .kind = (TokenKind) 5, .data = (u32) 50 };
    tokens[(u32) 21] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 22] = (Token){ .kind = (TokenKind) 5, .data = (u32) 57 };
    tokens[(u32) 23] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 24] = (Token){ .kind = (TokenKind) 5, .data = (u32) 60 };
    tokens[(u32) 25] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 26] = (Token){ .kind = (TokenKind) 5, .data = (u32) 66 };
    tokens[(u32) 27] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 28] = (Token){ .kind = (TokenKind) 5, .data = (u32) 73 };
    tokens[(u32) 29] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 30] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 31] = (Token){ .kind = (TokenKind) 5, .data = (u32) 76 };
    tokens[(u32) 32] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 33] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 34] = (Token){ .kind = (TokenKind) 5, .data = (u32) 79 };
    tokens[(u32) 35] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 36] = (Token){ .kind = (TokenKind) 5, .data = (u32) 85 };
    tokens[(u32) 37] = (Token){ .kind = (TokenKind) 33, .data = (u32) 0 };
    tokens[(u32) 38] = (Token){ .kind = (TokenKind) 5, .data = (u32) 87 };
    tokens[(u32) 39] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 40] = (Token){ .kind = (TokenKind) 5, .data = (u32) 93 };
    tokens[(u32) 41] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 42] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 43] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 44] = (Token){ .kind = (TokenKind) 5, .data = (u32) 95 };
    tokens[(u32) 45] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 46] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 47] = (Token){ .kind = (TokenKind) 5, .data = (u32) 102 };
    tokens[(u32) 48] = (Token){ .kind = (TokenKind) 5, .data = (u32) 106 };
    tokens[(u32) 49] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 50] = (Token){ .kind = (TokenKind) 5, .data = (u32) 114 };
    tokens[(u32) 51] = (Token){ .kind = (TokenKind) 5, .data = (u32) 118 };
    tokens[(u32) 52] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 53] = (Token){ .kind = (TokenKind) 5, .data = (u32) 120 };
    tokens[(u32) 54] = (Token){ .kind = (TokenKind) 5, .data = (u32) 124 };
    tokens[(u32) 55] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 56] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 57] = (Token){ .kind = (TokenKind) 5, .data = (u32) 126 };
    tokens[(u32) 58] = (Token){ .kind = (TokenKind) 5, .data = (u32) 130 };
    tokens[(u32) 59] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 60] = (Token){ .kind = (TokenKind) 5, .data = (u32) 137 };
    tokens[(u32) 61] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 62] = (Token){ .kind = (TokenKind) 5, .data = (u32) 149 };
    tokens[(u32) 63] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 64] = (Token){ .kind = (TokenKind) 5, .data = (u32) 151 };
    tokens[(u32) 65] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 66] = (Token){ .kind = (TokenKind) 5, .data = (u32) 154 };
    tokens[(u32) 67] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 68] = (Token){ .kind = (TokenKind) 5, .data = (u32) 156 };
    tokens[(u32) 69] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 70] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 71] = (Token){ .kind = (TokenKind) 5, .data = (u32) 159 };
    tokens[(u32) 72] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 73] = (Token){ .kind = (TokenKind) 5, .data = (u32) 166 };
    tokens[(u32) 74] = (Token){ .kind = (TokenKind) 50, .data = (u32) 0 };
    tokens[(u32) 75] = (Token){ .kind = (TokenKind) 5, .data = (u32) 169 };
    tokens[(u32) 76] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 77] = (Token){ .kind = (TokenKind) 5, .data = (u32) 171 };
    tokens[(u32) 78] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 79] = (Token){ .kind = (TokenKind) 5, .data = (u32) 174 };
    tokens[(u32) 80] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 81] = (Token){ .kind = (TokenKind) 5, .data = (u32) 176 };
    tokens[(u32) 82] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 83] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 84] = (Token){ .kind = (TokenKind) 5, .data = (u32) 179 };
    tokens[(u32) 85] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 86] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 87] = (Token){ .kind = (TokenKind) 5, .data = (u32) 186 };
    tokens[(u32) 88] = (Token){ .kind = (TokenKind) 5, .data = (u32) 190 };
    tokens[(u32) 89] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 90] = (Token){ .kind = (TokenKind) 5, .data = (u32) 198 };
    tokens[(u32) 91] = (Token){ .kind = (TokenKind) 5, .data = (u32) 202 };
    tokens[(u32) 92] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 93] = (Token){ .kind = (TokenKind) 5, .data = (u32) 204 };
    tokens[(u32) 94] = (Token){ .kind = (TokenKind) 5, .data = (u32) 208 };
    tokens[(u32) 95] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 96] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 97] = (Token){ .kind = (TokenKind) 5, .data = (u32) 210 };
    tokens[(u32) 98] = (Token){ .kind = (TokenKind) 5, .data = (u32) 214 };
    tokens[(u32) 99] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 100] = (Token){ .kind = (TokenKind) 5, .data = (u32) 225 };
    tokens[(u32) 101] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 102] = (Token){ .kind = (TokenKind) 5, .data = (u32) 233 };
    tokens[(u32) 103] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 104] = (Token){ .kind = (TokenKind) 5, .data = (u32) 245 };
    tokens[(u32) 105] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 106] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 107] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 108] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 109] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 110] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 111] = (Token){ .kind = (TokenKind) 5, .data = (u32) 247 };
    tokens[(u32) 112] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 113] = (Token){ .kind = (TokenKind) 5, .data = (u32) 255 };
    tokens[(u32) 114] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 115] = (Token){ .kind = (TokenKind) 5, .data = (u32) 257 };
    tokens[(u32) 116] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 117] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 118] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 119] = (Token){ .kind = (TokenKind) 5, .data = (u32) 268 };
    tokens[(u32) 120] = (Token){ .kind = (TokenKind) 5, .data = (u32) 272 };
    tokens[(u32) 121] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 122] = (Token){ .kind = (TokenKind) 5, .data = (u32) 284 };
    tokens[(u32) 123] = (Token){ .kind = (TokenKind) 5, .data = (u32) 288 };
    tokens[(u32) 124] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 125] = (Token){ .kind = (TokenKind) 5, .data = (u32) 290 };
    tokens[(u32) 126] = (Token){ .kind = (TokenKind) 5, .data = (u32) 294 };
    tokens[(u32) 127] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 128] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 129] = (Token){ .kind = (TokenKind) 5, .data = (u32) 296 };
    tokens[(u32) 130] = (Token){ .kind = (TokenKind) 5, .data = (u32) 300 };
    tokens[(u32) 131] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 132] = (Token){ .kind = (TokenKind) 5, .data = (u32) 307 };
    tokens[(u32) 133] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 134] = (Token){ .kind = (TokenKind) 5, .data = (u32) 314 };
    tokens[(u32) 135] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 136] = (Token){ .kind = (TokenKind) 5, .data = (u32) 317 };
    tokens[(u32) 137] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 138] = (Token){ .kind = (TokenKind) 5, .data = (u32) 319 };
    tokens[(u32) 139] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 140] = (Token){ .kind = (TokenKind) 5, .data = (u32) 322 };
    tokens[(u32) 141] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 142] = (Token){ .kind = (TokenKind) 5, .data = (u32) 324 };
    tokens[(u32) 143] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 144] = (Token){ .kind = (TokenKind) 5, .data = (u32) 327 };
    tokens[(u32) 145] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 146] = (Token){ .kind = (TokenKind) 5, .data = (u32) 334 };
    tokens[(u32) 147] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 148] = (Token){ .kind = (TokenKind) 5, .data = (u32) 337 };
    tokens[(u32) 149] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 150] = (Token){ .kind = (TokenKind) 5, .data = (u32) 339 };
    tokens[(u32) 151] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 152] = (Token){ .kind = (TokenKind) 5, .data = (u32) 342 };
    tokens[(u32) 153] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 154] = (Token){ .kind = (TokenKind) 5, .data = (u32) 344 };
    tokens[(u32) 155] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 156] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 157] = (Token){ .kind = (TokenKind) 5, .data = (u32) 347 };
    tokens[(u32) 158] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 159] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 160] = (Token){ .kind = (TokenKind) 5, .data = (u32) 354 };
    tokens[(u32) 161] = (Token){ .kind = (TokenKind) 5, .data = (u32) 358 };
    tokens[(u32) 162] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 163] = (Token){ .kind = (TokenKind) 5, .data = (u32) 369 };
    tokens[(u32) 164] = (Token){ .kind = (TokenKind) 5, .data = (u32) 373 };
    tokens[(u32) 165] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 166] = (Token){ .kind = (TokenKind) 5, .data = (u32) 375 };
    tokens[(u32) 167] = (Token){ .kind = (TokenKind) 5, .data = (u32) 379 };
    tokens[(u32) 168] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 169] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 170] = (Token){ .kind = (TokenKind) 5, .data = (u32) 381 };
    tokens[(u32) 171] = (Token){ .kind = (TokenKind) 5, .data = (u32) 385 };
    tokens[(u32) 172] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 173] = (Token){ .kind = (TokenKind) 5, .data = (u32) 392 };
    tokens[(u32) 174] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 175] = (Token){ .kind = (TokenKind) 5, .data = (u32) 399 };
    tokens[(u32) 176] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 177] = (Token){ .kind = (TokenKind) 5, .data = (u32) 402 };
    tokens[(u32) 178] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 179] = (Token){ .kind = (TokenKind) 5, .data = (u32) 404 };
    tokens[(u32) 180] = (Token){ .kind = (TokenKind) 35, .data = (u32) 0 };
    tokens[(u32) 181] = (Token){ .kind = (TokenKind) 5, .data = (u32) 407 };
    tokens[(u32) 182] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 183] = (Token){ .kind = (TokenKind) 5, .data = (u32) 409 };
    tokens[(u32) 184] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 185] = (Token){ .kind = (TokenKind) 5, .data = (u32) 412 };
    tokens[(u32) 186] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 187] = (Token){ .kind = (TokenKind) 5, .data = (u32) 419 };
    tokens[(u32) 188] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 189] = (Token){ .kind = (TokenKind) 5, .data = (u32) 422 };
    tokens[(u32) 190] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 191] = (Token){ .kind = (TokenKind) 5, .data = (u32) 424 };
    tokens[(u32) 192] = (Token){ .kind = (TokenKind) 35, .data = (u32) 0 };
    tokens[(u32) 193] = (Token){ .kind = (TokenKind) 5, .data = (u32) 427 };
    tokens[(u32) 194] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 195] = (Token){ .kind = (TokenKind) 5, .data = (u32) 429 };
    tokens[(u32) 196] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 197] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 198] = (Token){ .kind = (TokenKind) 5, .data = (u32) 432 };
    tokens[(u32) 199] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 200] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 201] = (Token){ .kind = (TokenKind) 5, .data = (u32) 439 };
    tokens[(u32) 202] = (Token){ .kind = (TokenKind) 5, .data = (u32) 443 };
    tokens[(u32) 203] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 204] = (Token){ .kind = (TokenKind) 5, .data = (u32) 455 };
    tokens[(u32) 205] = (Token){ .kind = (TokenKind) 5, .data = (u32) 459 };
    tokens[(u32) 206] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 207] = (Token){ .kind = (TokenKind) 5, .data = (u32) 461 };
    tokens[(u32) 208] = (Token){ .kind = (TokenKind) 5, .data = (u32) 465 };
    tokens[(u32) 209] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 210] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 211] = (Token){ .kind = (TokenKind) 5, .data = (u32) 467 };
    tokens[(u32) 212] = (Token){ .kind = (TokenKind) 5, .data = (u32) 471 };
    tokens[(u32) 213] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 214] = (Token){ .kind = (TokenKind) 5, .data = (u32) 478 };
    tokens[(u32) 215] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 216] = (Token){ .kind = (TokenKind) 5, .data = (u32) 485 };
    tokens[(u32) 217] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 218] = (Token){ .kind = (TokenKind) 5, .data = (u32) 488 };
    tokens[(u32) 219] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 220] = (Token){ .kind = (TokenKind) 5, .data = (u32) 490 };
    tokens[(u32) 221] = (Token){ .kind = (TokenKind) 36, .data = (u32) 0 };
    tokens[(u32) 222] = (Token){ .kind = (TokenKind) 5, .data = (u32) 493 };
    tokens[(u32) 223] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 224] = (Token){ .kind = (TokenKind) 5, .data = (u32) 495 };
    tokens[(u32) 225] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 226] = (Token){ .kind = (TokenKind) 5, .data = (u32) 498 };
    tokens[(u32) 227] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 228] = (Token){ .kind = (TokenKind) 5, .data = (u32) 505 };
    tokens[(u32) 229] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 230] = (Token){ .kind = (TokenKind) 5, .data = (u32) 508 };
    tokens[(u32) 231] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 232] = (Token){ .kind = (TokenKind) 5, .data = (u32) 510 };
    tokens[(u32) 233] = (Token){ .kind = (TokenKind) 36, .data = (u32) 0 };
    tokens[(u32) 234] = (Token){ .kind = (TokenKind) 5, .data = (u32) 513 };
    tokens[(u32) 235] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 236] = (Token){ .kind = (TokenKind) 5, .data = (u32) 515 };
    tokens[(u32) 237] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 238] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 239] = (Token){ .kind = (TokenKind) 5, .data = (u32) 518 };
    tokens[(u32) 240] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 241] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 242] = (Token){ .kind = (TokenKind) 5, .data = (u32) 525 };
    tokens[(u32) 243] = (Token){ .kind = (TokenKind) 5, .data = (u32) 529 };
    tokens[(u32) 244] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 245] = (Token){ .kind = (TokenKind) 5, .data = (u32) 541 };
    tokens[(u32) 246] = (Token){ .kind = (TokenKind) 5, .data = (u32) 545 };
    tokens[(u32) 247] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 248] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 249] = (Token){ .kind = (TokenKind) 5, .data = (u32) 551 };
    tokens[(u32) 250] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 251] = (Token){ .kind = (TokenKind) 5, .data = (u32) 557 };
    tokens[(u32) 252] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 253] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 254] = (Token){ .kind = (TokenKind) 5, .data = (u32) 560 };
    tokens[(u32) 255] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 256] = (Token){ .kind = (TokenKind) 5, .data = (u32) 566 };
    tokens[(u32) 257] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 258] = (Token){ .kind = (TokenKind) 5, .data = (u32) 569 };
    tokens[(u32) 259] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 260] = (Token){ .kind = (TokenKind) 5, .data = (u32) 575 };
    tokens[(u32) 261] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 262] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 263] = (Token){ .kind = (TokenKind) 5, .data = (u32) 578 };
    tokens[(u32) 264] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 265] = (Token){ .kind = (TokenKind) 5, .data = (u32) 584 };
    tokens[(u32) 266] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 267] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 268] = (Token){ .kind = (TokenKind) 5, .data = (u32) 587 };
    tokens[(u32) 269] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 270] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 271] = (Token){ .kind = (TokenKind) 5, .data = (u32) 593 };
    tokens[(u32) 272] = (Token){ .kind = (TokenKind) 5, .data = (u32) 597 };
    tokens[(u32) 273] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 274] = (Token){ .kind = (TokenKind) 5, .data = (u32) 605 };
    tokens[(u32) 275] = (Token){ .kind = (TokenKind) 5, .data = (u32) 609 };
    tokens[(u32) 276] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 277] = (Token){ .kind = (TokenKind) 5, .data = (u32) 615 };
    tokens[(u32) 278] = (Token){ .kind = (TokenKind) 5, .data = (u32) 618 };
    tokens[(u32) 279] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 280] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 281] = (Token){ .kind = (TokenKind) 5, .data = (u32) 625 };
    tokens[(u32) 282] = (Token){ .kind = (TokenKind) 5, .data = (u32) 629 };
    tokens[(u32) 283] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 284] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 285] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 286] = (Token){ .kind = (TokenKind) 5, .data = (u32) 636 };
    tokens[(u32) 287] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 288] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 289] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 290] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 291] = (Token){ .kind = (TokenKind) 5, .data = (u32) 643 };
    tokens[(u32) 292] = (Token){ .kind = (TokenKind) 5, .data = (u32) 646 };
    tokens[(u32) 293] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 294] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 295] = (Token){ .kind = (TokenKind) 5, .data = (u32) 654 };
    tokens[(u32) 296] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 297] = (Token){ .kind = (TokenKind) 5, .data = (u32) 660 };
    tokens[(u32) 298] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 299] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 300] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 301] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 302] = (Token){ .kind = (TokenKind) 5, .data = (u32) 663 };
    tokens[(u32) 303] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 304] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 305] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 306] = (Token){ .kind = (TokenKind) 5, .data = (u32) 670 };
    tokens[(u32) 307] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 308] = (Token){ .kind = (TokenKind) 5, .data = (u32) 677 };
    tokens[(u32) 309] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 310] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 311] = (Token){ .kind = (TokenKind) 5, .data = (u32) 680 };
    tokens[(u32) 312] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 313] = (Token){ .kind = (TokenKind) 5, .data = (u32) 686 };
    tokens[(u32) 314] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 315] = (Token){ .kind = (TokenKind) 5, .data = (u32) 689 };
    tokens[(u32) 316] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 317] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 318] = (Token){ .kind = (TokenKind) 5, .data = (u32) 696 };
    tokens[(u32) 319] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 320] = (Token){ .kind = (TokenKind) 5, .data = (u32) 704 };
    tokens[(u32) 321] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 322] = (Token){ .kind = (TokenKind) 5, .data = (u32) 711 };
    tokens[(u32) 323] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 324] = (Token){ .kind = (TokenKind) 5, .data = (u32) 714 };
    tokens[(u32) 325] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 326] = (Token){ .kind = (TokenKind) 5, .data = (u32) 720 };
    tokens[(u32) 327] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 328] = (Token){ .kind = (TokenKind) 5, .data = (u32) 723 };
    tokens[(u32) 329] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 330] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 331] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 332] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 333] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 334] = (Token){ .kind = (TokenKind) 5, .data = (u32) 730 };
    tokens[(u32) 335] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 336] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 337] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 338] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 339] = (Token){ .kind = (TokenKind) 5, .data = (u32) 737 };
    tokens[(u32) 340] = (Token){ .kind = (TokenKind) 5, .data = (u32) 740 };
    tokens[(u32) 341] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 342] = (Token){ .kind = (TokenKind) 5, .data = (u32) 746 };
    tokens[(u32) 343] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 344] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 345] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 346] = (Token){ .kind = (TokenKind) 5, .data = (u32) 753 };
    tokens[(u32) 347] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 348] = (Token){ .kind = (TokenKind) 5, .data = (u32) 760 };
    tokens[(u32) 349] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 350] = (Token){ .kind = (TokenKind) 5, .data = (u32) 763 };
    tokens[(u32) 351] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 352] = (Token){ .kind = (TokenKind) 5, .data = (u32) 769 };
    tokens[(u32) 353] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 354] = (Token){ .kind = (TokenKind) 5, .data = (u32) 772 };
    tokens[(u32) 355] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 356] = (Token){ .kind = (TokenKind) 5, .data = (u32) 778 };
    tokens[(u32) 357] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 358] = (Token){ .kind = (TokenKind) 5, .data = (u32) 785 };
    tokens[(u32) 359] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 360] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 361] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 362] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 363] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 364] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 365] = (Token){ .kind = (TokenKind) 5, .data = (u32) 788 };
    tokens[(u32) 366] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 367] = (Token){ .kind = (TokenKind) 5, .data = (u32) 795 };
    tokens[(u32) 368] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 369] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 370] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 371] = (Token){ .kind = (TokenKind) 5, .data = (u32) 798 };
    tokens[(u32) 372] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 373] = (Token){ .kind = (TokenKind) 5, .data = (u32) 805 };
    tokens[(u32) 374] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 375] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 376] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 377] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 378] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 379] = (Token){ .kind = (TokenKind) 5, .data = (u32) 808 };
    tokens[(u32) 380] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 381] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 382] = (Token){ .kind = (TokenKind) 5, .data = (u32) 815 };
    tokens[(u32) 383] = (Token){ .kind = (TokenKind) 5, .data = (u32) 819 };
    tokens[(u32) 384] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 385] = (Token){ .kind = (TokenKind) 5, .data = (u32) 827 };
    tokens[(u32) 386] = (Token){ .kind = (TokenKind) 5, .data = (u32) 831 };
    tokens[(u32) 387] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 388] = (Token){ .kind = (TokenKind) 5, .data = (u32) 837 };
    tokens[(u32) 389] = (Token){ .kind = (TokenKind) 5, .data = (u32) 840 };
    tokens[(u32) 390] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 391] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 392] = (Token){ .kind = (TokenKind) 5, .data = (u32) 847 };
    tokens[(u32) 393] = (Token){ .kind = (TokenKind) 5, .data = (u32) 851 };
    tokens[(u32) 394] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 395] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 396] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 397] = (Token){ .kind = (TokenKind) 5, .data = (u32) 858 };
    tokens[(u32) 398] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 399] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 400] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 401] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 402] = (Token){ .kind = (TokenKind) 5, .data = (u32) 865 };
    tokens[(u32) 403] = (Token){ .kind = (TokenKind) 5, .data = (u32) 868 };
    tokens[(u32) 404] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 405] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 406] = (Token){ .kind = (TokenKind) 5, .data = (u32) 876 };
    tokens[(u32) 407] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 408] = (Token){ .kind = (TokenKind) 5, .data = (u32) 882 };
    tokens[(u32) 409] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 410] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 411] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 412] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 413] = (Token){ .kind = (TokenKind) 5, .data = (u32) 885 };
    tokens[(u32) 414] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 415] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 416] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 417] = (Token){ .kind = (TokenKind) 5, .data = (u32) 892 };
    tokens[(u32) 418] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 419] = (Token){ .kind = (TokenKind) 5, .data = (u32) 899 };
    tokens[(u32) 420] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 421] = (Token){ .kind = (TokenKind) 5, .data = (u32) 902 };
    tokens[(u32) 422] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 423] = (Token){ .kind = (TokenKind) 5, .data = (u32) 908 };
    tokens[(u32) 424] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 425] = (Token){ .kind = (TokenKind) 5, .data = (u32) 911 };
    tokens[(u32) 426] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 427] = (Token){ .kind = (TokenKind) 5, .data = (u32) 918 };
    tokens[(u32) 428] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 429] = (Token){ .kind = (TokenKind) 5, .data = (u32) 925 };
    tokens[(u32) 430] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 431] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 432] = (Token){ .kind = (TokenKind) 5, .data = (u32) 928 };
    tokens[(u32) 433] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 434] = (Token){ .kind = (TokenKind) 5, .data = (u32) 934 };
    tokens[(u32) 435] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 436] = (Token){ .kind = (TokenKind) 5, .data = (u32) 937 };
    tokens[(u32) 437] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 438] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 439] = (Token){ .kind = (TokenKind) 5, .data = (u32) 944 };
    tokens[(u32) 440] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 441] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 442] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 443] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 444] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 445] = (Token){ .kind = (TokenKind) 5, .data = (u32) 952 };
    tokens[(u32) 446] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 447] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 448] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 449] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 450] = (Token){ .kind = (TokenKind) 5, .data = (u32) 959 };
    tokens[(u32) 451] = (Token){ .kind = (TokenKind) 5, .data = (u32) 962 };
    tokens[(u32) 452] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 453] = (Token){ .kind = (TokenKind) 5, .data = (u32) 968 };
    tokens[(u32) 454] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 455] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 456] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 457] = (Token){ .kind = (TokenKind) 5, .data = (u32) 975 };
    tokens[(u32) 458] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 459] = (Token){ .kind = (TokenKind) 5, .data = (u32) 982 };
    tokens[(u32) 460] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 461] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 462] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 463] = (Token){ .kind = (TokenKind) 5, .data = (u32) 985 };
    tokens[(u32) 464] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 465] = (Token){ .kind = (TokenKind) 5, .data = (u32) 992 };
    tokens[(u32) 466] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 467] = (Token){ .kind = (TokenKind) 5, .data = (u32) 995 };
    tokens[(u32) 468] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 469] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1001 };
    tokens[(u32) 470] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 471] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1004 };
    tokens[(u32) 472] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 473] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 474] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 475] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 476] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1010 };
    tokens[(u32) 477] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 478] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1017 };
    tokens[(u32) 479] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 480] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 481] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 482] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1020 };
    tokens[(u32) 483] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 484] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1027 };
    tokens[(u32) 485] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 486] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 487] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 488] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 489] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 490] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1030 };
    tokens[(u32) 491] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 492] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 493] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1037 };
    tokens[(u32) 494] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1041 };
    tokens[(u32) 495] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 496] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1049 };
    tokens[(u32) 497] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1053 };
    tokens[(u32) 498] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 499] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1055 };
    tokens[(u32) 500] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1059 };
    tokens[(u32) 501] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 502] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 503] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1061 };
    tokens[(u32) 504] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1064 };
    tokens[(u32) 505] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 506] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 507] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 508] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 509] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 510] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 511] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1071 };
    tokens[(u32) 512] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1074 };
    tokens[(u32) 513] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 514] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 515] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 516] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1076 };
    tokens[(u32) 517] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 518] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 519] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 520] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1078 };
    tokens[(u32) 521] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 522] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 523] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 524] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1080 };
    tokens[(u32) 525] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 526] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 527] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1087 };
    tokens[(u32) 528] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 529] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 530] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 531] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 532] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1094 };
    tokens[(u32) 533] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 534] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 535] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 536] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 537] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 538] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 539] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1096 };
    tokens[(u32) 540] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 541] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 542] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 543] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1099 };
    tokens[(u32) 544] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 545] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1101 };
    tokens[(u32) 546] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 547] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1104 };
    tokens[(u32) 548] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 549] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 550] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 551] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 552] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 553] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 554] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 555] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 556] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1106 };
    tokens[(u32) 557] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1109 };
    tokens[(u32) 558] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 559] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 560] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 561] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1111 };
    tokens[(u32) 562] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 563] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 564] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 565] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1113 };
    tokens[(u32) 566] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 567] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 568] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 569] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1115 };
    tokens[(u32) 570] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 571] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 572] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1122 };
    tokens[(u32) 573] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 574] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1129 };
    tokens[(u32) 575] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 576] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 577] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 578] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 579] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 580] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1131 };
    tokens[(u32) 581] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 582] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 583] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 584] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1134 };
    tokens[(u32) 585] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 586] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1136 };
    tokens[(u32) 587] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 588] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1139 };
    tokens[(u32) 589] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 590] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 591] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 592] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 593] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 594] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 595] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1141 };
    tokens[(u32) 596] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1145 };
    tokens[(u32) 597] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 598] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 599] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 600] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 601] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 602] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1147 };
    tokens[(u32) 603] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1150 };
    tokens[(u32) 604] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 605] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 606] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 607] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1152 };
    tokens[(u32) 608] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 609] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 610] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 611] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1154 };
    tokens[(u32) 612] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 613] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 614] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 615] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 616] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 617] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1156 };
    tokens[(u32) 618] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 619] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1163 };
    tokens[(u32) 620] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 621] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 622] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 623] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1165 };
    tokens[(u32) 624] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 625] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1167 };
    tokens[(u32) 626] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 627] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1175 };
    tokens[(u32) 628] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 629] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1177 };
    tokens[(u32) 630] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 631] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1185 };
    tokens[(u32) 632] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 633] = (Token){ .kind = (TokenKind) 16, .data = (u32) 15 };
    tokens[(u32) 634] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 635] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1187 };
    tokens[(u32) 636] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 637] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 638] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 639] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 640] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 641] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 642] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1189 };
    tokens[(u32) 643] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 644] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 645] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1191 };
    tokens[(u32) 646] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1194 };
    tokens[(u32) 647] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 648] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1201 };
    tokens[(u32) 649] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1205 };
    tokens[(u32) 650] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 651] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1207 };
    tokens[(u32) 652] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1211 };
    tokens[(u32) 653] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 654] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 655] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 656] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1213 };
    tokens[(u32) 657] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 658] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1215 };
    tokens[(u32) 659] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 660] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1218 };
    tokens[(u32) 661] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 662] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1220 };
    tokens[(u32) 663] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 664] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1223 };
    tokens[(u32) 665] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 666] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1225 };
    tokens[(u32) 667] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 668] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1228 };
    tokens[(u32) 669] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 670] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1230 };
    tokens[(u32) 671] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 672] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 673] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1233 };
    tokens[(u32) 674] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1237 };
    tokens[(u32) 675] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 676] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1245 };
    tokens[(u32) 677] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1249 };
    tokens[(u32) 678] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 679] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1251 };
    tokens[(u32) 680] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1255 };
    tokens[(u32) 681] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 682] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 683] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1257 };
    tokens[(u32) 684] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1261 };
    tokens[(u32) 685] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 686] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 687] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 688] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 689] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 690] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1263 };
    tokens[(u32) 691] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 692] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1270 };
    tokens[(u32) 693] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 694] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 695] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 696] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 697] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 698] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1272 };
    tokens[(u32) 699] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 700] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 701] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 702] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1274 };
    tokens[(u32) 703] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 704] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 705] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 706] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 707] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 708] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 709] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1276 };
    tokens[(u32) 710] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 711] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1283 };
    tokens[(u32) 712] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 713] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 714] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 715] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 716] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 717] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1285 };
    tokens[(u32) 718] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 719] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1287 };
    tokens[(u32) 720] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 721] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1289 };
    tokens[(u32) 722] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 723] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 724] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 725] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 726] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1291 };
    tokens[(u32) 727] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1295 };
    tokens[(u32) 728] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 729] = (Token){ .kind = (TokenKind) 16, .data = (u32) 14 };
    tokens[(u32) 730] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 731] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 732] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1302 };
    tokens[(u32) 733] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1306 };
    tokens[(u32) 734] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 735] = (Token){ .kind = (TokenKind) 16, .data = (u32) 14 };
    tokens[(u32) 736] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 737] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 738] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1318 };
    tokens[(u32) 739] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 740] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 741] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 742] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 743] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4 };
    tokens[(u32) 744] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 745] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1325 };
    tokens[(u32) 746] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 747] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 748] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 749] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 750] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16384 };
    tokens[(u32) 751] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 752] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1337 };
    tokens[(u32) 753] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 754] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 755] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 756] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 757] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 758] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 759] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1344 };
    tokens[(u32) 760] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 761] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 762] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 763] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 764] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8192 };
    tokens[(u32) 765] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 766] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1356 };
    tokens[(u32) 767] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 768] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2 };
    tokens[(u32) 769] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 770] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 771] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 772] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 773] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1363 };
    tokens[(u32) 774] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 775] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2 };
    tokens[(u32) 776] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 777] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 778] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4096 };
    tokens[(u32) 779] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 780] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1375 };
    tokens[(u32) 781] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 782] = (Token){ .kind = (TokenKind) 16, .data = (u32) 3 };
    tokens[(u32) 783] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 784] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 785] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 786] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 787] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1382 };
    tokens[(u32) 788] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 789] = (Token){ .kind = (TokenKind) 16, .data = (u32) 3 };
    tokens[(u32) 790] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 791] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 792] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2048 };
    tokens[(u32) 793] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 794] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1394 };
    tokens[(u32) 795] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 796] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4 };
    tokens[(u32) 797] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 798] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 799] = (Token){ .kind = (TokenKind) 16, .data = (u32) 64 };
    tokens[(u32) 800] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 801] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1401 };
    tokens[(u32) 802] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 803] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4 };
    tokens[(u32) 804] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 805] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 806] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1024 };
    tokens[(u32) 807] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 808] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1413 };
    tokens[(u32) 809] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 810] = (Token){ .kind = (TokenKind) 16, .data = (u32) 5 };
    tokens[(u32) 811] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 812] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 813] = (Token){ .kind = (TokenKind) 16, .data = (u32) 128 };
    tokens[(u32) 814] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 815] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1420 };
    tokens[(u32) 816] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 817] = (Token){ .kind = (TokenKind) 16, .data = (u32) 5 };
    tokens[(u32) 818] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 819] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 820] = (Token){ .kind = (TokenKind) 16, .data = (u32) 512 };
    tokens[(u32) 821] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 822] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1432 };
    tokens[(u32) 823] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 824] = (Token){ .kind = (TokenKind) 16, .data = (u32) 6 };
    tokens[(u32) 825] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 826] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 827] = (Token){ .kind = (TokenKind) 16, .data = (u32) 256 };
    tokens[(u32) 828] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 829] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1439 };
    tokens[(u32) 830] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 831] = (Token){ .kind = (TokenKind) 16, .data = (u32) 6 };
    tokens[(u32) 832] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 833] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 834] = (Token){ .kind = (TokenKind) 16, .data = (u32) 256 };
    tokens[(u32) 835] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 836] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1451 };
    tokens[(u32) 837] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 838] = (Token){ .kind = (TokenKind) 16, .data = (u32) 7 };
    tokens[(u32) 839] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 840] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 841] = (Token){ .kind = (TokenKind) 16, .data = (u32) 512 };
    tokens[(u32) 842] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 843] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1458 };
    tokens[(u32) 844] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 845] = (Token){ .kind = (TokenKind) 16, .data = (u32) 7 };
    tokens[(u32) 846] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 847] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 848] = (Token){ .kind = (TokenKind) 16, .data = (u32) 128 };
    tokens[(u32) 849] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 850] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1470 };
    tokens[(u32) 851] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 852] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 853] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 854] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 855] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1024 };
    tokens[(u32) 856] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 857] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1477 };
    tokens[(u32) 858] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 859] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 860] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 861] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 862] = (Token){ .kind = (TokenKind) 16, .data = (u32) 64 };
    tokens[(u32) 863] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 864] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1489 };
    tokens[(u32) 865] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 866] = (Token){ .kind = (TokenKind) 16, .data = (u32) 9 };
    tokens[(u32) 867] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 868] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 869] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2048 };
    tokens[(u32) 870] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 871] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1496 };
    tokens[(u32) 872] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 873] = (Token){ .kind = (TokenKind) 16, .data = (u32) 9 };
    tokens[(u32) 874] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 875] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 876] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 877] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 878] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1508 };
    tokens[(u32) 879] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 880] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 881] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 882] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 883] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4096 };
    tokens[(u32) 884] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 885] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1515 };
    tokens[(u32) 886] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 887] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 888] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 889] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 890] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 891] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 892] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1527 };
    tokens[(u32) 893] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 894] = (Token){ .kind = (TokenKind) 16, .data = (u32) 11 };
    tokens[(u32) 895] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 896] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 897] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8192 };
    tokens[(u32) 898] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 899] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1534 };
    tokens[(u32) 900] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 901] = (Token){ .kind = (TokenKind) 16, .data = (u32) 11 };
    tokens[(u32) 902] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 903] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 904] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 905] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 906] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1546 };
    tokens[(u32) 907] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 908] = (Token){ .kind = (TokenKind) 16, .data = (u32) 12 };
    tokens[(u32) 909] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 910] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 911] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16384 };
    tokens[(u32) 912] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 913] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1553 };
    tokens[(u32) 914] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 915] = (Token){ .kind = (TokenKind) 16, .data = (u32) 12 };
    tokens[(u32) 916] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 917] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 918] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4 };
    tokens[(u32) 919] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 920] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1565 };
    tokens[(u32) 921] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 922] = (Token){ .kind = (TokenKind) 16, .data = (u32) 13 };
    tokens[(u32) 923] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 924] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 925] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32768 };
    tokens[(u32) 926] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 927] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1572 };
    tokens[(u32) 928] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 929] = (Token){ .kind = (TokenKind) 16, .data = (u32) 13 };
    tokens[(u32) 930] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 931] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 932] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2 };
    tokens[(u32) 933] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 934] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 935] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 936] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1584 };
    tokens[(u32) 937] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1587 };
    tokens[(u32) 938] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 939] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 940] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 941] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1589 };
    tokens[(u32) 942] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 943] = (Token){ .kind = (TokenKind) 16, .data = (u32) 14 };
    tokens[(u32) 944] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 945] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1591 };
    tokens[(u32) 946] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 947] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 948] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 949] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 950] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 951] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1593 };
    tokens[(u32) 952] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 953] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1600 };
    tokens[(u32) 954] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 955] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1602 };
    tokens[(u32) 956] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 957] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1609 };
    tokens[(u32) 958] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 959] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 960] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 961] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 962] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1611 };
    tokens[(u32) 963] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1615 };
    tokens[(u32) 964] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 965] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1626 };
    tokens[(u32) 966] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 967] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1638 };
    tokens[(u32) 968] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 969] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 970] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1640 };
    tokens[(u32) 971] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1644 };
    tokens[(u32) 972] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 973] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1651 };
    tokens[(u32) 974] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 975] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1659 };
    tokens[(u32) 976] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 977] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1670 };
    tokens[(u32) 978] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 979] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 980] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 981] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 982] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1672 };
    tokens[(u32) 983] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 984] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1680 };
    tokens[(u32) 985] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 986] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1682 };
    tokens[(u32) 987] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 988] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 989] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 990] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1689 };
    tokens[(u32) 991] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 992] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1691 };
    tokens[(u32) 993] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 994] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1699 };
    tokens[(u32) 995] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 996] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1701 };
    tokens[(u32) 997] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 998] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 999] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1708 };
    tokens[(u32) 1000] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1001] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1710 };
    tokens[(u32) 1002] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1003] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1718 };
    tokens[(u32) 1004] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1005] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1720 };
    tokens[(u32) 1006] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1007] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1008] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1009] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1010] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1011] = (Token){ .kind = (TokenKind) 45, .data = (u32) 0 };
    tokens[(u32) 1012] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1013] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1731 };
    tokens[(u32) 1014] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1015] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1739 };
    tokens[(u32) 1016] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1017] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1741 };
    tokens[(u32) 1018] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1019] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1020] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1021] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1743 };
    tokens[(u32) 1022] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1023] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1745 };
    tokens[(u32) 1024] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1025] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1753 };
    tokens[(u32) 1026] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1027] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1755 };
    tokens[(u32) 1028] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1029] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1030] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1757 };
    tokens[(u32) 1031] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1032] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1759 };
    tokens[(u32) 1033] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1034] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1767 };
    tokens[(u32) 1035] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1036] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 1037] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1038] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1039] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1040] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1041] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1769 };
    tokens[(u32) 1042] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1043] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1044] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1771 };
    tokens[(u32) 1045] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1775 };
    tokens[(u32) 1046] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1047] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1783 };
    tokens[(u32) 1048] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1787 };
    tokens[(u32) 1049] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1050] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1789 };
    tokens[(u32) 1051] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1793 };
    tokens[(u32) 1052] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1053] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1054] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1055] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1795 };
    tokens[(u32) 1056] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1057] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1803 };
    tokens[(u32) 1058] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1059] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1805 };
    tokens[(u32) 1060] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1061] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1813 };
    tokens[(u32) 1062] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1063] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1821 };
    tokens[(u32) 1064] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1065] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1823 };
    tokens[(u32) 1066] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1067] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1068] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1825 };
    tokens[(u32) 1069] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1070] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1071] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1072] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1073] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1827 };
    tokens[(u32) 1074] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1830 };
    tokens[(u32) 1075] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1076] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1837 };
    tokens[(u32) 1077] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1841 };
    tokens[(u32) 1078] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1079] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1843 };
    tokens[(u32) 1080] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1847 };
    tokens[(u32) 1081] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1082] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1083] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1084] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1849 };
    tokens[(u32) 1085] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1086] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1851 };
    tokens[(u32) 1087] = (Token){ .kind = (TokenKind) 27, .data = (u32) 0 };
    tokens[(u32) 1088] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1854 };
    tokens[(u32) 1089] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1090] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1856 };
    tokens[(u32) 1091] = (Token){ .kind = (TokenKind) 33, .data = (u32) 0 };
    tokens[(u32) 1092] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1093] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1859 };
    tokens[(u32) 1094] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1095] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1861 };
    tokens[(u32) 1096] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 1097] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1864 };
    tokens[(u32) 1098] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1099] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1866 };
    tokens[(u32) 1100] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 1101] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1869 };
    tokens[(u32) 1102] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1103] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1871 };
    tokens[(u32) 1104] = (Token){ .kind = (TokenKind) 27, .data = (u32) 0 };
    tokens[(u32) 1105] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1874 };
    tokens[(u32) 1106] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1107] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1876 };
    tokens[(u32) 1108] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1109] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1110] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1111] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1879 };
    tokens[(u32) 1112] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1882 };
    tokens[(u32) 1113] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1114] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1890 };
    tokens[(u32) 1115] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1894 };
    tokens[(u32) 1116] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1117] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1896 };
    tokens[(u32) 1118] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1900 };
    tokens[(u32) 1119] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1120] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1121] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1122] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1902 };
    tokens[(u32) 1123] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1124] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1904 };
    tokens[(u32) 1125] = (Token){ .kind = (TokenKind) 27, .data = (u32) 0 };
    tokens[(u32) 1126] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1907 };
    tokens[(u32) 1127] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1128] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1909 };
    tokens[(u32) 1129] = (Token){ .kind = (TokenKind) 33, .data = (u32) 0 };
    tokens[(u32) 1130] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1131] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1912 };
    tokens[(u32) 1132] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1133] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1914 };
    tokens[(u32) 1134] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 1135] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1917 };
    tokens[(u32) 1136] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1137] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1919 };
    tokens[(u32) 1138] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 1139] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1922 };
    tokens[(u32) 1140] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1141] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1924 };
    tokens[(u32) 1142] = (Token){ .kind = (TokenKind) 29, .data = (u32) 0 };
    tokens[(u32) 1143] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1927 };
    tokens[(u32) 1144] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1145] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1929 };
    tokens[(u32) 1146] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1147] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1148] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1149] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1932 };
    tokens[(u32) 1150] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1935 };
    tokens[(u32) 1151] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1152] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1942 };
    tokens[(u32) 1153] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1946 };
    tokens[(u32) 1154] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1155] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1948 };
    tokens[(u32) 1156] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1952 };
    tokens[(u32) 1157] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1158] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1159] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1160] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1954 };
    tokens[(u32) 1161] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1162] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1956 };
    tokens[(u32) 1163] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1164] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1959 };
    tokens[(u32) 1165] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1166] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1961 };
    tokens[(u32) 1167] = (Token){ .kind = (TokenKind) 33, .data = (u32) 0 };
    tokens[(u32) 1168] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1169] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1964 };
    tokens[(u32) 1170] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1171] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1966 };
    tokens[(u32) 1172] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 1173] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1969 };
    tokens[(u32) 1174] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1175] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1971 };
    tokens[(u32) 1176] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 1177] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1974 };
    tokens[(u32) 1178] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1179] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1976 };
    tokens[(u32) 1180] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1181] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1979 };
    tokens[(u32) 1182] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1183] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1981 };
    tokens[(u32) 1184] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1185] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1186] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1187] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1984 };
    tokens[(u32) 1188] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1987 };
    tokens[(u32) 1189] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1190] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1995 };
    tokens[(u32) 1191] = (Token){ .kind = (TokenKind) 5, .data = (u32) 1999 };
    tokens[(u32) 1192] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1193] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2001 };
    tokens[(u32) 1194] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2005 };
    tokens[(u32) 1195] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1196] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1197] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1198] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2007 };
    tokens[(u32) 1199] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1200] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2009 };
    tokens[(u32) 1201] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1202] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2012 };
    tokens[(u32) 1203] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1204] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2014 };
    tokens[(u32) 1205] = (Token){ .kind = (TokenKind) 33, .data = (u32) 0 };
    tokens[(u32) 1206] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1207] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2017 };
    tokens[(u32) 1208] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1209] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2019 };
    tokens[(u32) 1210] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 1211] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2022 };
    tokens[(u32) 1212] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1213] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2024 };
    tokens[(u32) 1214] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 1215] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2027 };
    tokens[(u32) 1216] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1217] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2029 };
    tokens[(u32) 1218] = (Token){ .kind = (TokenKind) 28, .data = (u32) 0 };
    tokens[(u32) 1219] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2032 };
    tokens[(u32) 1220] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1221] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2034 };
    tokens[(u32) 1222] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1223] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1224] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1225] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2037 };
    tokens[(u32) 1226] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2040 };
    tokens[(u32) 1227] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1228] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2054 };
    tokens[(u32) 1229] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2057 };
    tokens[(u32) 1230] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1231] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1232] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 1233] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1234] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2063 };
    tokens[(u32) 1235] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1236] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 1237] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1238] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1239] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2069 };
    tokens[(u32) 1240] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1241] = (Token){ .kind = (TokenKind) 16, .data = (u32) 48 };
    tokens[(u32) 1242] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 1243] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2073 };
    tokens[(u32) 1244] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1245] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1246] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1247] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 1248] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1249] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2079 };
    tokens[(u32) 1250] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1251] = (Token){ .kind = (TokenKind) 16, .data = (u32) 65 };
    tokens[(u32) 1252] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 1253] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1254] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2083 };
    tokens[(u32) 1255] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 1256] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 1257] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1258] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1259] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1260] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1261] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1262] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2089 };
    tokens[(u32) 1263] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2092 };
    tokens[(u32) 1264] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1265] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2103 };
    tokens[(u32) 1266] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2106 };
    tokens[(u32) 1267] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1268] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1269] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2112 };
    tokens[(u32) 1270] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2115 };
    tokens[(u32) 1271] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1272] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2123 };
    tokens[(u32) 1273] = (Token){ .kind = (TokenKind) 22, .data = (u32) 0 };
    tokens[(u32) 1274] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 1275] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1276] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2129 };
    tokens[(u32) 1277] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1278] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2143 };
    tokens[(u32) 1279] = (Token){ .kind = (TokenKind) 23, .data = (u32) 0 };
    tokens[(u32) 1280] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 1281] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1282] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1283] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2151 };
    tokens[(u32) 1284] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1285] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2165 };
    tokens[(u32) 1286] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 1287] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2171 };
    tokens[(u32) 1288] = (Token){ .kind = (TokenKind) 21, .data = (u32) 0 };
    tokens[(u32) 1289] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 1290] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1291] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1292] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1293] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2179 };
    tokens[(u32) 1294] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2182 };
    tokens[(u32) 1295] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1296] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2191 };
    tokens[(u32) 1297] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2195 };
    tokens[(u32) 1298] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1299] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1300] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2201 };
    tokens[(u32) 1301] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2204 };
    tokens[(u32) 1302] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1303] = (Token){ .kind = (TokenKind) 16, .data = (u32) 5 };
    tokens[(u32) 1304] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1305] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1306] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 1307] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1308] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2211 };
    tokens[(u32) 1309] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2214 };
    tokens[(u32) 1310] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1311] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 1312] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2216 };
    tokens[(u32) 1313] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 1314] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 1315] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1316] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2223 };
    tokens[(u32) 1317] = (Token){ .kind = (TokenKind) 25, .data = (u32) 0 };
    tokens[(u32) 1318] = (Token){ .kind = (TokenKind) 16, .data = (u32) 255 };
    tokens[(u32) 1319] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1320] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2225 };
    tokens[(u32) 1321] = (Token){ .kind = (TokenKind) 40, .data = (u32) 0 };
    tokens[(u32) 1322] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1323] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1324] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2227 };
    tokens[(u32) 1325] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2231 };
    tokens[(u32) 1326] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1327] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2239 };
    tokens[(u32) 1328] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1329] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2247 };
    tokens[(u32) 1330] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1331] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 1332] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1333] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1334] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2253 };
    tokens[(u32) 1335] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2257 };
    tokens[(u32) 1336] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1337] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2264 };
    tokens[(u32) 1338] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1339] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2272 };
    tokens[(u32) 1340] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1341] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2278 };
    tokens[(u32) 1342] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1343] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2286 };
    tokens[(u32) 1344] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1345] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 1346] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1347] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1348] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1349] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2294 };
    tokens[(u32) 1350] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1351] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2301 };
    tokens[(u32) 1352] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1353] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1354] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2303 };
    tokens[(u32) 1355] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1356] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2310 };
    tokens[(u32) 1357] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1358] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2313 };
    tokens[(u32) 1359] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1360] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2319 };
    tokens[(u32) 1361] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1362] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1363] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2327 };
    tokens[(u32) 1364] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2330 };
    tokens[(u32) 1365] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1366] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1367] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1368] = (Token){ .kind = (TokenKind) 45, .data = (u32) 0 };
    tokens[(u32) 1369] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1370] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2336 };
    tokens[(u32) 1371] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1372] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 1373] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2342 };
    tokens[(u32) 1374] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 1375] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 1376] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 1377] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2349 };
    tokens[(u32) 1378] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1379] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2356 };
    tokens[(u32) 1380] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1381] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 1382] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1383] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1384] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1385] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2362 };
    tokens[(u32) 1386] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 1387] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1388] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1389] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 1390] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1391] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2368 };
    tokens[(u32) 1392] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2371 };
    tokens[(u32) 1393] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1394] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2373 };
    tokens[(u32) 1395] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1396] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2379 };
    tokens[(u32) 1397] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1398] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 1399] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2381 };
    tokens[(u32) 1400] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1401] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2388 };
    tokens[(u32) 1402] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 1403] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1404] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1405] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2390 };
    tokens[(u32) 1406] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1407] = (Token){ .kind = (TokenKind) 16, .data = (u32) 48 };
    tokens[(u32) 1408] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 1409] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2394 };
    tokens[(u32) 1410] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1411] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2401 };
    tokens[(u32) 1412] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1413] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1414] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1415] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1416] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1417] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2403 };
    tokens[(u32) 1418] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2406 };
    tokens[(u32) 1419] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1420] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2415 };
    tokens[(u32) 1421] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2419 };
    tokens[(u32) 1422] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1423] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1424] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2425 };
    tokens[(u32) 1425] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2428 };
    tokens[(u32) 1426] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1427] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 1428] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1429] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1430] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 1431] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1432] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2435 };
    tokens[(u32) 1433] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2438 };
    tokens[(u32) 1434] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1435] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 1436] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2440 };
    tokens[(u32) 1437] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 1438] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 1439] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1440] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2447 };
    tokens[(u32) 1441] = (Token){ .kind = (TokenKind) 25, .data = (u32) 0 };
    tokens[(u32) 1442] = (Token){ .kind = (TokenKind) 16, .data = (u32) 255 };
    tokens[(u32) 1443] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1444] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2449 };
    tokens[(u32) 1445] = (Token){ .kind = (TokenKind) 40, .data = (u32) 0 };
    tokens[(u32) 1446] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1447] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1448] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2451 };
    tokens[(u32) 1449] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2455 };
    tokens[(u32) 1450] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1451] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2463 };
    tokens[(u32) 1452] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1453] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2471 };
    tokens[(u32) 1454] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1455] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 1456] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1457] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1458] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2477 };
    tokens[(u32) 1459] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2481 };
    tokens[(u32) 1460] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1461] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2488 };
    tokens[(u32) 1462] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1463] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2496 };
    tokens[(u32) 1464] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1465] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2502 };
    tokens[(u32) 1466] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1467] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2510 };
    tokens[(u32) 1468] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1469] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 1470] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1471] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1472] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1473] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2518 };
    tokens[(u32) 1474] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1475] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2525 };
    tokens[(u32) 1476] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1477] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1478] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2527 };
    tokens[(u32) 1479] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1480] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2534 };
    tokens[(u32) 1481] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1482] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2537 };
    tokens[(u32) 1483] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1484] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2543 };
    tokens[(u32) 1485] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1486] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1487] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2551 };
    tokens[(u32) 1488] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2554 };
    tokens[(u32) 1489] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1490] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1491] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1492] = (Token){ .kind = (TokenKind) 45, .data = (u32) 0 };
    tokens[(u32) 1493] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1494] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2560 };
    tokens[(u32) 1495] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1496] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 1497] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2566 };
    tokens[(u32) 1498] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 1499] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 1500] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 1501] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2573 };
    tokens[(u32) 1502] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1503] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2580 };
    tokens[(u32) 1504] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1505] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 1506] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1507] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1508] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1509] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2586 };
    tokens[(u32) 1510] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 1511] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1512] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1513] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 1514] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1515] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2592 };
    tokens[(u32) 1516] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2595 };
    tokens[(u32) 1517] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1518] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2597 };
    tokens[(u32) 1519] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1520] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2603 };
    tokens[(u32) 1521] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1522] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 1523] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2605 };
    tokens[(u32) 1524] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1525] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2612 };
    tokens[(u32) 1526] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 1527] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1528] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1529] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2614 };
    tokens[(u32) 1530] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1531] = (Token){ .kind = (TokenKind) 16, .data = (u32) 48 };
    tokens[(u32) 1532] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 1533] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2618 };
    tokens[(u32) 1534] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1535] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2625 };
    tokens[(u32) 1536] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1537] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1538] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1539] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1540] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1541] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2627 };
    tokens[(u32) 1542] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2630 };
    tokens[(u32) 1543] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1544] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2642 };
    tokens[(u32) 1545] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2646 };
    tokens[(u32) 1546] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1547] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1548] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2652 };
    tokens[(u32) 1549] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1550] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2663 };
    tokens[(u32) 1551] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1552] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2669 };
    tokens[(u32) 1553] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1554] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1555] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2672 };
    tokens[(u32) 1556] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1557] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2683 };
    tokens[(u32) 1558] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1559] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2689 };
    tokens[(u32) 1560] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1561] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1562] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1563] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2692 };
    tokens[(u32) 1564] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2695 };
    tokens[(u32) 1565] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1566] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2706 };
    tokens[(u32) 1567] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2709 };
    tokens[(u32) 1568] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1569] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1570] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2715 };
    tokens[(u32) 1571] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2718 };
    tokens[(u32) 1572] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1573] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 1574] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1575] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1576] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 1577] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1578] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2725 };
    tokens[(u32) 1579] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2728 };
    tokens[(u32) 1580] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1581] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1582] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1583] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2730 };
    tokens[(u32) 1584] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1585] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 1586] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2732 };
    tokens[(u32) 1587] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1588] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2739 };
    tokens[(u32) 1589] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 1590] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1591] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1592] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2741 };
    tokens[(u32) 1593] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1594] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2748 };
    tokens[(u32) 1595] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1596] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1597] = (Token){ .kind = (TokenKind) 16, .data = (u32) 48 };
    tokens[(u32) 1598] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1599] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1600] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2750 };
    tokens[(u32) 1601] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2753 };
    tokens[(u32) 1602] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1603] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 1604] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1605] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1606] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2760 };
    tokens[(u32) 1607] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1608] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1609] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1610] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1611] = (Token){ .kind = (TokenKind) 16, .data = (u32) 127 };
    tokens[(u32) 1612] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1613] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2767 };
    tokens[(u32) 1614] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1615] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 1616] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1617] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1618] = (Token){ .kind = (TokenKind) 16, .data = (u32) 63 };
    tokens[(u32) 1619] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1620] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2774 };
    tokens[(u32) 1621] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1622] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2 };
    tokens[(u32) 1623] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1624] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1625] = (Token){ .kind = (TokenKind) 16, .data = (u32) 31 };
    tokens[(u32) 1626] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1627] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2781 };
    tokens[(u32) 1628] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1629] = (Token){ .kind = (TokenKind) 16, .data = (u32) 3 };
    tokens[(u32) 1630] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1631] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1632] = (Token){ .kind = (TokenKind) 16, .data = (u32) 15 };
    tokens[(u32) 1633] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1634] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2788 };
    tokens[(u32) 1635] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1636] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4 };
    tokens[(u32) 1637] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1638] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1639] = (Token){ .kind = (TokenKind) 16, .data = (u32) 7 };
    tokens[(u32) 1640] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1641] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2795 };
    tokens[(u32) 1642] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1643] = (Token){ .kind = (TokenKind) 16, .data = (u32) 5 };
    tokens[(u32) 1644] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1645] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1646] = (Token){ .kind = (TokenKind) 16, .data = (u32) 3 };
    tokens[(u32) 1647] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1648] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2802 };
    tokens[(u32) 1649] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1650] = (Token){ .kind = (TokenKind) 16, .data = (u32) 6 };
    tokens[(u32) 1651] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1652] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1653] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 1654] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1655] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2809 };
    tokens[(u32) 1656] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1657] = (Token){ .kind = (TokenKind) 16, .data = (u32) 7 };
    tokens[(u32) 1658] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1659] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1660] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1661] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1662] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 1663] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1664] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2816 };
    tokens[(u32) 1665] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2819 };
    tokens[(u32) 1666] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1667] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1668] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1669] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2821 };
    tokens[(u32) 1670] = (Token){ .kind = (TokenKind) 25, .data = (u32) 0 };
    tokens[(u32) 1671] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 1672] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2823 };
    tokens[(u32) 1673] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1674] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2830 };
    tokens[(u32) 1675] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 1676] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1677] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1678] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2832 };
    tokens[(u32) 1679] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2835 };
    tokens[(u32) 1680] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1681] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2841 };
    tokens[(u32) 1682] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1683] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2848 };
    tokens[(u32) 1684] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1685] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1686] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 1687] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1688] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2850 };
    tokens[(u32) 1689] = (Token){ .kind = (TokenKind) 27, .data = (u32) 0 };
    tokens[(u32) 1690] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2856 };
    tokens[(u32) 1691] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1692] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1693] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2862 };
    tokens[(u32) 1694] = (Token){ .kind = (TokenKind) 51, .data = (u32) 0 };
    tokens[(u32) 1695] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2868 };
    tokens[(u32) 1696] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 1697] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 1698] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1699] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2874 };
    tokens[(u32) 1700] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1701] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2881 };
    tokens[(u32) 1702] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1703] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 1704] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1705] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1706] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1707] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 1708] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1709] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2883 };
    tokens[(u32) 1710] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2886 };
    tokens[(u32) 1711] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1712] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1713] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1714] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2888 };
    tokens[(u32) 1715] = (Token){ .kind = (TokenKind) 25, .data = (u32) 0 };
    tokens[(u32) 1716] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 1717] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2890 };
    tokens[(u32) 1718] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1719] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2897 };
    tokens[(u32) 1720] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 1721] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1722] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1723] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2899 };
    tokens[(u32) 1724] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1725] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2903 };
    tokens[(u32) 1726] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 1727] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2910 };
    tokens[(u32) 1728] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 1729] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1730] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1731] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1732] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1733] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2912 };
    tokens[(u32) 1734] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2915 };
    tokens[(u32) 1735] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1736] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2927 };
    tokens[(u32) 1737] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2931 };
    tokens[(u32) 1738] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1739] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1740] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2937 };
    tokens[(u32) 1741] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1742] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2948 };
    tokens[(u32) 1743] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1744] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2954 };
    tokens[(u32) 1745] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1746] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1747] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2957 };
    tokens[(u32) 1748] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1749] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 1750] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1751] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1752] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2961 };
    tokens[(u32) 1753] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1754] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2972 };
    tokens[(u32) 1755] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1756] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2978 };
    tokens[(u32) 1757] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1758] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1759] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1760] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2981 };
    tokens[(u32) 1761] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2985 };
    tokens[(u32) 1762] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1763] = (Token){ .kind = (TokenKind) 5, .data = (u32) 2998 };
    tokens[(u32) 1764] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3002 };
    tokens[(u32) 1765] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1766] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3004 };
    tokens[(u32) 1767] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3008 };
    tokens[(u32) 1768] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1769] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1770] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3010 };
    tokens[(u32) 1771] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3014 };
    tokens[(u32) 1772] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1773] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3016 };
    tokens[(u32) 1774] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 1775] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3018 };
    tokens[(u32) 1776] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1777] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3020 };
    tokens[(u32) 1778] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3024 };
    tokens[(u32) 1779] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1780] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3026 };
    tokens[(u32) 1781] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1782] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3028 };
    tokens[(u32) 1783] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1784] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 1785] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1786] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3031 };
    tokens[(u32) 1787] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1788] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3033 };
    tokens[(u32) 1789] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1790] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1791] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3036 };
    tokens[(u32) 1792] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1793] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1794] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3039 };
    tokens[(u32) 1795] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1796] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3041 };
    tokens[(u32) 1797] = (Token){ .kind = (TokenKind) 33, .data = (u32) 0 };
    tokens[(u32) 1798] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3043 };
    tokens[(u32) 1799] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 1800] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3045 };
    tokens[(u32) 1801] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1802] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1803] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3047 };
    tokens[(u32) 1804] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1805] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3049 };
    tokens[(u32) 1806] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1807] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3052 };
    tokens[(u32) 1808] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1809] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3054 };
    tokens[(u32) 1810] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1811] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3057 };
    tokens[(u32) 1812] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1813] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3059 };
    tokens[(u32) 1814] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1815] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3062 };
    tokens[(u32) 1816] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1817] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3064 };
    tokens[(u32) 1818] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1819] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1820] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3067 };
    tokens[(u32) 1821] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1822] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1823] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3069 };
    tokens[(u32) 1824] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3073 };
    tokens[(u32) 1825] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1826] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3081 };
    tokens[(u32) 1827] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3085 };
    tokens[(u32) 1828] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1829] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3087 };
    tokens[(u32) 1830] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3091 };
    tokens[(u32) 1831] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1832] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1833] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3093 };
    tokens[(u32) 1834] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3097 };
    tokens[(u32) 1835] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1836] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3099 };
    tokens[(u32) 1837] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1838] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3112 };
    tokens[(u32) 1839] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1840] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3114 };
    tokens[(u32) 1841] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1842] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3120 };
    tokens[(u32) 1843] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1844] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3122 };
    tokens[(u32) 1845] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1846] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1847] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3128 };
    tokens[(u32) 1848] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1849] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3130 };
    tokens[(u32) 1850] = (Token){ .kind = (TokenKind) 50, .data = (u32) 0 };
    tokens[(u32) 1851] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3136 };
    tokens[(u32) 1852] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1853] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3138 };
    tokens[(u32) 1854] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 1855] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3144 };
    tokens[(u32) 1856] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1857] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3146 };
    tokens[(u32) 1858] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1859] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1860] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3152 };
    tokens[(u32) 1861] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1862] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1863] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3154 };
    tokens[(u32) 1864] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3158 };
    tokens[(u32) 1865] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1866] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3170 };
    tokens[(u32) 1867] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3174 };
    tokens[(u32) 1868] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1869] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3176 };
    tokens[(u32) 1870] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3180 };
    tokens[(u32) 1871] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1872] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1873] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3182 };
    tokens[(u32) 1874] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3186 };
    tokens[(u32) 1875] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1876] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3193 };
    tokens[(u32) 1877] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1878] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3200 };
    tokens[(u32) 1879] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1880] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3203 };
    tokens[(u32) 1881] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1882] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3205 };
    tokens[(u32) 1883] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 1884] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3208 };
    tokens[(u32) 1885] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1886] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3210 };
    tokens[(u32) 1887] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1888] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3213 };
    tokens[(u32) 1889] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1890] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3220 };
    tokens[(u32) 1891] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1892] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3223 };
    tokens[(u32) 1893] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1894] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3225 };
    tokens[(u32) 1895] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 1896] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3228 };
    tokens[(u32) 1897] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1898] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3230 };
    tokens[(u32) 1899] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1900] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3233 };
    tokens[(u32) 1901] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1902] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3240 };
    tokens[(u32) 1903] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1904] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3243 };
    tokens[(u32) 1905] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1906] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3245 };
    tokens[(u32) 1907] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 1908] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3248 };
    tokens[(u32) 1909] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1910] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3250 };
    tokens[(u32) 1911] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1912] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3253 };
    tokens[(u32) 1913] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1914] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3260 };
    tokens[(u32) 1915] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1916] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3263 };
    tokens[(u32) 1917] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1918] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3265 };
    tokens[(u32) 1919] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 1920] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3268 };
    tokens[(u32) 1921] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1922] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3270 };
    tokens[(u32) 1923] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1924] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1925] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3273 };
    tokens[(u32) 1926] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1927] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1928] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3280 };
    tokens[(u32) 1929] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3284 };
    tokens[(u32) 1930] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1931] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3295 };
    tokens[(u32) 1932] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3299 };
    tokens[(u32) 1933] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1934] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3301 };
    tokens[(u32) 1935] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3305 };
    tokens[(u32) 1936] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 1937] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 1938] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3307 };
    tokens[(u32) 1939] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3311 };
    tokens[(u32) 1940] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1941] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3318 };
    tokens[(u32) 1942] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1943] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3325 };
    tokens[(u32) 1944] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1945] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3328 };
    tokens[(u32) 1946] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1947] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3330 };
    tokens[(u32) 1948] = (Token){ .kind = (TokenKind) 35, .data = (u32) 0 };
    tokens[(u32) 1949] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3333 };
    tokens[(u32) 1950] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1951] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3335 };
    tokens[(u32) 1952] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1953] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3338 };
    tokens[(u32) 1954] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1955] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3345 };
    tokens[(u32) 1956] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1957] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3348 };
    tokens[(u32) 1958] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1959] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3350 };
    tokens[(u32) 1960] = (Token){ .kind = (TokenKind) 35, .data = (u32) 0 };
    tokens[(u32) 1961] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3353 };
    tokens[(u32) 1962] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1963] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3355 };
    tokens[(u32) 1964] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1965] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3358 };
    tokens[(u32) 1966] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1967] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3365 };
    tokens[(u32) 1968] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1969] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3368 };
    tokens[(u32) 1970] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1971] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3370 };
    tokens[(u32) 1972] = (Token){ .kind = (TokenKind) 35, .data = (u32) 0 };
    tokens[(u32) 1973] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3373 };
    tokens[(u32) 1974] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1975] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3375 };
    tokens[(u32) 1976] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1977] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3378 };
    tokens[(u32) 1978] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1979] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3385 };
    tokens[(u32) 1980] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 1981] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3388 };
    tokens[(u32) 1982] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1983] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3390 };
    tokens[(u32) 1984] = (Token){ .kind = (TokenKind) 35, .data = (u32) 0 };
    tokens[(u32) 1985] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3393 };
    tokens[(u32) 1986] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 1987] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3395 };
    tokens[(u32) 1988] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1989] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 1990] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3398 };
    tokens[(u32) 1991] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 1992] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 1993] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3405 };
    tokens[(u32) 1994] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3409 };
    tokens[(u32) 1995] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 1996] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3421 };
    tokens[(u32) 1997] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3425 };
    tokens[(u32) 1998] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 1999] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3427 };
    tokens[(u32) 2000] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3431 };
    tokens[(u32) 2001] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2002] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2003] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3433 };
    tokens[(u32) 2004] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3437 };
    tokens[(u32) 2005] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2006] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3444 };
    tokens[(u32) 2007] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2008] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3451 };
    tokens[(u32) 2009] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2010] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3454 };
    tokens[(u32) 2011] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2012] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3456 };
    tokens[(u32) 2013] = (Token){ .kind = (TokenKind) 36, .data = (u32) 0 };
    tokens[(u32) 2014] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3459 };
    tokens[(u32) 2015] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2016] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3461 };
    tokens[(u32) 2017] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2018] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3464 };
    tokens[(u32) 2019] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2020] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3471 };
    tokens[(u32) 2021] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2022] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3474 };
    tokens[(u32) 2023] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2024] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3476 };
    tokens[(u32) 2025] = (Token){ .kind = (TokenKind) 36, .data = (u32) 0 };
    tokens[(u32) 2026] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3479 };
    tokens[(u32) 2027] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2028] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3481 };
    tokens[(u32) 2029] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2030] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3484 };
    tokens[(u32) 2031] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2032] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3491 };
    tokens[(u32) 2033] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2034] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3494 };
    tokens[(u32) 2035] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2036] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3496 };
    tokens[(u32) 2037] = (Token){ .kind = (TokenKind) 36, .data = (u32) 0 };
    tokens[(u32) 2038] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3499 };
    tokens[(u32) 2039] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2040] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3501 };
    tokens[(u32) 2041] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2042] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3504 };
    tokens[(u32) 2043] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2044] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3511 };
    tokens[(u32) 2045] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2046] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3514 };
    tokens[(u32) 2047] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2048] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3516 };
    tokens[(u32) 2049] = (Token){ .kind = (TokenKind) 36, .data = (u32) 0 };
    tokens[(u32) 2050] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3519 };
    tokens[(u32) 2051] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2052] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3521 };
    tokens[(u32) 2053] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2054] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 2055] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3524 };
    tokens[(u32) 2056] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2057] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2058] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3531 };
    tokens[(u32) 2059] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3535 };
    tokens[(u32) 2060] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2061] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3547 };
    tokens[(u32) 2062] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3551 };
    tokens[(u32) 2063] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2064] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2065] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3557 };
    tokens[(u32) 2066] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2067] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3563 };
    tokens[(u32) 2068] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2069] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 2070] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3566 };
    tokens[(u32) 2071] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2072] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3572 };
    tokens[(u32) 2073] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2074] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3575 };
    tokens[(u32) 2075] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2076] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3581 };
    tokens[(u32) 2077] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2078] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 2079] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3584 };
    tokens[(u32) 2080] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2081] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3590 };
    tokens[(u32) 2082] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2083] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3593 };
    tokens[(u32) 2084] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2085] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3599 };
    tokens[(u32) 2086] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2087] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 2088] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3602 };
    tokens[(u32) 2089] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2090] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3608 };
    tokens[(u32) 2091] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2092] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3611 };
    tokens[(u32) 2093] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2094] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3617 };
    tokens[(u32) 2095] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2096] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 2097] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3620 };
    tokens[(u32) 2098] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2099] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3626 };
    tokens[(u32) 2100] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2101] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 2102] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3629 };
    tokens[(u32) 2103] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2104] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2105] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3635 };
    tokens[(u32) 2106] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3638 };
    tokens[(u32) 2107] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2108] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3650 };
    tokens[(u32) 2109] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3654 };
    tokens[(u32) 2110] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2111] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2112] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3660 };
    tokens[(u32) 2113] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2114] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3671 };
    tokens[(u32) 2115] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2116] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3677 };
    tokens[(u32) 2117] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2118] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2119] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3680 };
    tokens[(u32) 2120] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2121] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3691 };
    tokens[(u32) 2122] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2123] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3697 };
    tokens[(u32) 2124] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2125] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2126] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3700 };
    tokens[(u32) 2127] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2128] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3711 };
    tokens[(u32) 2129] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2130] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3717 };
    tokens[(u32) 2131] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2132] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2133] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3720 };
    tokens[(u32) 2134] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2135] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3731 };
    tokens[(u32) 2136] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2137] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3737 };
    tokens[(u32) 2138] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2139] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2140] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2141] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3740 };
    tokens[(u32) 2142] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3743 };
    tokens[(u32) 2143] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2144] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3755 };
    tokens[(u32) 2145] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3759 };
    tokens[(u32) 2146] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2147] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2148] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3765 };
    tokens[(u32) 2149] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2150] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3776 };
    tokens[(u32) 2151] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2152] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3782 };
    tokens[(u32) 2153] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2154] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2155] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3785 };
    tokens[(u32) 2156] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2157] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 2158] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2159] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2160] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3789 };
    tokens[(u32) 2161] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2162] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3800 };
    tokens[(u32) 2163] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2164] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3806 };
    tokens[(u32) 2165] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2166] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2167] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3809 };
    tokens[(u32) 2168] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2169] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 2170] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2171] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2172] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3813 };
    tokens[(u32) 2173] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2174] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3824 };
    tokens[(u32) 2175] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2176] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3830 };
    tokens[(u32) 2177] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2178] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2179] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3833 };
    tokens[(u32) 2180] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2181] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 2182] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2183] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2184] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3837 };
    tokens[(u32) 2185] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2186] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3848 };
    tokens[(u32) 2187] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2188] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3854 };
    tokens[(u32) 2189] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2190] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2191] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2192] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3857 };
    tokens[(u32) 2193] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3861 };
    tokens[(u32) 2194] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2195] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3873 };
    tokens[(u32) 2196] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3877 };
    tokens[(u32) 2197] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2198] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2199] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3883 };
    tokens[(u32) 2200] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2201] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3889 };
    tokens[(u32) 2202] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2203] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 2204] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3892 };
    tokens[(u32) 2205] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2206] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3898 };
    tokens[(u32) 2207] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2208] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3901 };
    tokens[(u32) 2209] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2210] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3907 };
    tokens[(u32) 2211] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2212] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 2213] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3910 };
    tokens[(u32) 2214] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2215] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3916 };
    tokens[(u32) 2216] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2217] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3919 };
    tokens[(u32) 2218] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2219] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3925 };
    tokens[(u32) 2220] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2221] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 2222] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3928 };
    tokens[(u32) 2223] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2224] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3934 };
    tokens[(u32) 2225] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2226] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3937 };
    tokens[(u32) 2227] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2228] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3943 };
    tokens[(u32) 2229] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2230] = (Token){ .kind = (TokenKind) 38, .data = (u32) 0 };
    tokens[(u32) 2231] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3946 };
    tokens[(u32) 2232] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2233] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3952 };
    tokens[(u32) 2234] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2235] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 2236] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3955 };
    tokens[(u32) 2237] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2238] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2239] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3961 };
    tokens[(u32) 2240] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3965 };
    tokens[(u32) 2241] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2242] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3973 };
    tokens[(u32) 2243] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3977 };
    tokens[(u32) 2244] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 2245] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3979 };
    tokens[(u32) 2246] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3983 };
    tokens[(u32) 2247] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2248] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2249] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3985 };
    tokens[(u32) 2250] = (Token){ .kind = (TokenKind) 5, .data = (u32) 3989 };
    tokens[(u32) 2251] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2252] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4000 };
    tokens[(u32) 2253] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2254] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4008 };
    tokens[(u32) 2255] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2256] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4020 };
    tokens[(u32) 2257] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2258] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 2259] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 2260] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2261] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2262] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 2263] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4022 };
    tokens[(u32) 2264] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2265] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4030 };
    tokens[(u32) 2266] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 2267] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4032 };
    tokens[(u32) 2268] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2269] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2270] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2271] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4043 };
    tokens[(u32) 2272] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4047 };
    tokens[(u32) 2273] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2274] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4055 };
    tokens[(u32) 2275] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4059 };
    tokens[(u32) 2276] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 2277] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4065 };
    tokens[(u32) 2278] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4068 };
    tokens[(u32) 2279] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2280] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2281] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4075 };
    tokens[(u32) 2282] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4079 };
    tokens[(u32) 2283] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2284] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 2285] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2286] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4086 };
    tokens[(u32) 2287] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2288] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2289] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2290] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2291] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4093 };
    tokens[(u32) 2292] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4096 };
    tokens[(u32) 2293] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2294] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2295] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4106 };
    tokens[(u32) 2296] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2297] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4112 };
    tokens[(u32) 2298] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2299] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2300] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2301] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2302] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4115 };
    tokens[(u32) 2303] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2304] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2305] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2306] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4122 };
    tokens[(u32) 2307] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4125 };
    tokens[(u32) 2308] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2309] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2310] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4135 };
    tokens[(u32) 2311] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2312] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4141 };
    tokens[(u32) 2313] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2314] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2315] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2316] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2317] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4144 };
    tokens[(u32) 2318] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2319] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2320] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2321] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4151 };
    tokens[(u32) 2322] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4154 };
    tokens[(u32) 2323] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2324] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2325] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4164 };
    tokens[(u32) 2326] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2327] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4170 };
    tokens[(u32) 2328] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2329] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2330] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2331] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2332] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4173 };
    tokens[(u32) 2333] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2334] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2335] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2336] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4180 };
    tokens[(u32) 2337] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2338] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4187 };
    tokens[(u32) 2339] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2340] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2341] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4190 };
    tokens[(u32) 2342] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2343] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4196 };
    tokens[(u32) 2344] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2345] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4199 };
    tokens[(u32) 2346] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2347] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2348] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4206 };
    tokens[(u32) 2349] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2350] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4216 };
    tokens[(u32) 2351] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2352] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4223 };
    tokens[(u32) 2353] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2354] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2355] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4226 };
    tokens[(u32) 2356] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2357] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4232 };
    tokens[(u32) 2358] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2359] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4235 };
    tokens[(u32) 2360] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2361] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2362] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4242 };
    tokens[(u32) 2363] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2364] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4252 };
    tokens[(u32) 2365] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2366] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4259 };
    tokens[(u32) 2367] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2368] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2369] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4262 };
    tokens[(u32) 2370] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2371] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4268 };
    tokens[(u32) 2372] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2373] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4271 };
    tokens[(u32) 2374] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2375] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2376] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4278 };
    tokens[(u32) 2377] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2378] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4288 };
    tokens[(u32) 2379] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2380] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4295 };
    tokens[(u32) 2381] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2382] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2383] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4298 };
    tokens[(u32) 2384] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2385] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4304 };
    tokens[(u32) 2386] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2387] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4307 };
    tokens[(u32) 2388] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2389] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2390] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2391] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 2392] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 2393] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2394] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4314 };
    tokens[(u32) 2395] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2396] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2397] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2398] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2399] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4321 };
    tokens[(u32) 2400] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4324 };
    tokens[(u32) 2401] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2402] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2403] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4334 };
    tokens[(u32) 2404] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2405] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4340 };
    tokens[(u32) 2406] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2407] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2408] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2409] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2410] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4343 };
    tokens[(u32) 2411] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2412] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2413] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2414] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4350 };
    tokens[(u32) 2415] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4353 };
    tokens[(u32) 2416] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2417] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2418] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4363 };
    tokens[(u32) 2419] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2420] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4369 };
    tokens[(u32) 2421] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2422] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2423] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2424] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2425] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4372 };
    tokens[(u32) 2426] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2427] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2428] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2429] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4379 };
    tokens[(u32) 2430] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2431] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4386 };
    tokens[(u32) 2432] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2433] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2434] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4389 };
    tokens[(u32) 2435] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2436] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4395 };
    tokens[(u32) 2437] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2438] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4398 };
    tokens[(u32) 2439] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2440] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2441] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2442] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2443] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4405 };
    tokens[(u32) 2444] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2445] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4415 };
    tokens[(u32) 2446] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2447] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4422 };
    tokens[(u32) 2448] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2449] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2450] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4425 };
    tokens[(u32) 2451] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2452] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4431 };
    tokens[(u32) 2453] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2454] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4434 };
    tokens[(u32) 2455] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2456] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2457] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2458] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2459] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4441 };
    tokens[(u32) 2460] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2461] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4451 };
    tokens[(u32) 2462] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2463] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4458 };
    tokens[(u32) 2464] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2465] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2466] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4461 };
    tokens[(u32) 2467] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2468] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4467 };
    tokens[(u32) 2469] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2470] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4470 };
    tokens[(u32) 2471] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2472] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2473] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2474] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2475] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4477 };
    tokens[(u32) 2476] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2477] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4484 };
    tokens[(u32) 2478] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2479] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2480] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2481] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2482] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 2483] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 2484] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2485] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4487 };
    tokens[(u32) 2486] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2487] = (Token){ .kind = (TokenKind) 16, .data = (u32) 24 };
    tokens[(u32) 2488] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2489] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2490] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4494 };
    tokens[(u32) 2491] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4497 };
    tokens[(u32) 2492] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2493] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2494] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4507 };
    tokens[(u32) 2495] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2496] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4513 };
    tokens[(u32) 2497] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2498] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2499] = (Token){ .kind = (TokenKind) 16, .data = (u32) 24 };
    tokens[(u32) 2500] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2501] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4516 };
    tokens[(u32) 2502] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2503] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2504] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2505] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4523 };
    tokens[(u32) 2506] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2507] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4530 };
    tokens[(u32) 2508] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2509] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2510] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4533 };
    tokens[(u32) 2511] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2512] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4539 };
    tokens[(u32) 2513] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2514] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4542 };
    tokens[(u32) 2515] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2516] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2517] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2518] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2519] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4549 };
    tokens[(u32) 2520] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2521] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4559 };
    tokens[(u32) 2522] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2523] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4566 };
    tokens[(u32) 2524] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2525] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2526] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4569 };
    tokens[(u32) 2527] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2528] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4575 };
    tokens[(u32) 2529] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2530] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4578 };
    tokens[(u32) 2531] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2532] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2533] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2534] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2535] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4585 };
    tokens[(u32) 2536] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2537] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4592 };
    tokens[(u32) 2538] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2539] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2540] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2541] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4595 };
    tokens[(u32) 2542] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2543] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4602 };
    tokens[(u32) 2544] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2545] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2546] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2547] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2548] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 2549] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 2550] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2551] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4605 };
    tokens[(u32) 2552] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2553] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 2554] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2555] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2556] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4612 };
    tokens[(u32) 2557] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2558] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4619 };
    tokens[(u32) 2559] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2560] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2561] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4622 };
    tokens[(u32) 2562] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2563] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4628 };
    tokens[(u32) 2564] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2565] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4631 };
    tokens[(u32) 2566] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2567] = (Token){ .kind = (TokenKind) 16, .data = (u32) 24 };
    tokens[(u32) 2568] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2569] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2570] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4638 };
    tokens[(u32) 2571] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2572] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4645 };
    tokens[(u32) 2573] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2574] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2575] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2576] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4648 };
    tokens[(u32) 2577] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2578] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4655 };
    tokens[(u32) 2579] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2580] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2581] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2582] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4658 };
    tokens[(u32) 2583] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2584] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4665 };
    tokens[(u32) 2585] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2586] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2587] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2588] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2589] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 2590] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2591] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4668 };
    tokens[(u32) 2592] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2593] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2594] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2595] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2596] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 2597] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4675 };
    tokens[(u32) 2598] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2599] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2600] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4682 };
    tokens[(u32) 2601] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4686 };
    tokens[(u32) 2602] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2603] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4694 };
    tokens[(u32) 2604] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4698 };
    tokens[(u32) 2605] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 2606] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4704 };
    tokens[(u32) 2607] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4707 };
    tokens[(u32) 2608] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2609] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2610] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4714 };
    tokens[(u32) 2611] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4718 };
    tokens[(u32) 2612] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2613] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 2614] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2615] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4725 };
    tokens[(u32) 2616] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2617] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2618] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2619] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2620] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4732 };
    tokens[(u32) 2621] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4735 };
    tokens[(u32) 2622] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2623] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2624] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4745 };
    tokens[(u32) 2625] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2626] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4751 };
    tokens[(u32) 2627] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2628] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2629] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2630] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2631] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4754 };
    tokens[(u32) 2632] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2633] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2634] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2635] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4761 };
    tokens[(u32) 2636] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4764 };
    tokens[(u32) 2637] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2638] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2639] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4774 };
    tokens[(u32) 2640] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2641] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4780 };
    tokens[(u32) 2642] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2643] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2644] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2645] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2646] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4783 };
    tokens[(u32) 2647] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2648] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2649] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2650] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4790 };
    tokens[(u32) 2651] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4793 };
    tokens[(u32) 2652] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2653] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2654] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4803 };
    tokens[(u32) 2655] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2656] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4809 };
    tokens[(u32) 2657] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2658] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2659] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2660] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2661] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4812 };
    tokens[(u32) 2662] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2663] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2664] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2665] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4819 };
    tokens[(u32) 2666] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2667] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4826 };
    tokens[(u32) 2668] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2669] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2670] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4829 };
    tokens[(u32) 2671] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2672] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4835 };
    tokens[(u32) 2673] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2674] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4838 };
    tokens[(u32) 2675] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2676] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2677] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4845 };
    tokens[(u32) 2678] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2679] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4852 };
    tokens[(u32) 2680] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2681] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2682] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4855 };
    tokens[(u32) 2683] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2684] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4861 };
    tokens[(u32) 2685] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2686] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4864 };
    tokens[(u32) 2687] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2688] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2689] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4871 };
    tokens[(u32) 2690] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2691] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4881 };
    tokens[(u32) 2692] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2693] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4888 };
    tokens[(u32) 2694] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2695] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2696] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4891 };
    tokens[(u32) 2697] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2698] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4897 };
    tokens[(u32) 2699] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2700] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4900 };
    tokens[(u32) 2701] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2702] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2703] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4907 };
    tokens[(u32) 2704] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2705] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4917 };
    tokens[(u32) 2706] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2707] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4924 };
    tokens[(u32) 2708] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2709] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2710] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4927 };
    tokens[(u32) 2711] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2712] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4933 };
    tokens[(u32) 2713] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2714] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4936 };
    tokens[(u32) 2715] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2716] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2717] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4943 };
    tokens[(u32) 2718] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2719] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2720] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 2721] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 2722] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2723] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4953 };
    tokens[(u32) 2724] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2725] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2726] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2727] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2728] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4960 };
    tokens[(u32) 2729] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4963 };
    tokens[(u32) 2730] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2731] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2732] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4973 };
    tokens[(u32) 2733] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2734] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4979 };
    tokens[(u32) 2735] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2736] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2737] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2738] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2739] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4982 };
    tokens[(u32) 2740] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2741] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2742] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2743] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4989 };
    tokens[(u32) 2744] = (Token){ .kind = (TokenKind) 5, .data = (u32) 4992 };
    tokens[(u32) 2745] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2746] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2747] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5002 };
    tokens[(u32) 2748] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2749] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5008 };
    tokens[(u32) 2750] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2751] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2752] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2753] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2754] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5011 };
    tokens[(u32) 2755] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2756] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2757] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2758] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5018 };
    tokens[(u32) 2759] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2760] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5025 };
    tokens[(u32) 2761] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2762] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2763] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2764] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5028 };
    tokens[(u32) 2765] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2766] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5035 };
    tokens[(u32) 2767] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2768] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2769] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5038 };
    tokens[(u32) 2770] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2771] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5044 };
    tokens[(u32) 2772] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2773] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5047 };
    tokens[(u32) 2774] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2775] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2776] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2777] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2778] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5054 };
    tokens[(u32) 2779] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2780] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5061 };
    tokens[(u32) 2781] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2782] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2783] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5064 };
    tokens[(u32) 2784] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2785] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5070 };
    tokens[(u32) 2786] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2787] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5073 };
    tokens[(u32) 2788] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2789] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2790] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2791] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2792] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5080 };
    tokens[(u32) 2793] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2794] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5090 };
    tokens[(u32) 2795] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2796] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5097 };
    tokens[(u32) 2797] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2798] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2799] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5100 };
    tokens[(u32) 2800] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2801] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5106 };
    tokens[(u32) 2802] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2803] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5109 };
    tokens[(u32) 2804] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2805] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2806] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2807] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2808] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5116 };
    tokens[(u32) 2809] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2810] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2811] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 2812] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 2813] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2814] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5126 };
    tokens[(u32) 2815] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2816] = (Token){ .kind = (TokenKind) 16, .data = (u32) 24 };
    tokens[(u32) 2817] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2818] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2819] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5133 };
    tokens[(u32) 2820] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5136 };
    tokens[(u32) 2821] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2822] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2823] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5146 };
    tokens[(u32) 2824] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2825] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5152 };
    tokens[(u32) 2826] = (Token){ .kind = (TokenKind) 30, .data = (u32) 0 };
    tokens[(u32) 2827] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2828] = (Token){ .kind = (TokenKind) 16, .data = (u32) 24 };
    tokens[(u32) 2829] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2830] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5155 };
    tokens[(u32) 2831] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2832] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2833] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2834] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5162 };
    tokens[(u32) 2835] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2836] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5169 };
    tokens[(u32) 2837] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2838] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2839] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2840] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5172 };
    tokens[(u32) 2841] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2842] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5179 };
    tokens[(u32) 2843] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2844] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2845] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2846] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5182 };
    tokens[(u32) 2847] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2848] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5189 };
    tokens[(u32) 2849] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2850] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2851] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5192 };
    tokens[(u32) 2852] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2853] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5198 };
    tokens[(u32) 2854] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2855] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5201 };
    tokens[(u32) 2856] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2857] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2858] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2859] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2860] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5208 };
    tokens[(u32) 2861] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2862] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5215 };
    tokens[(u32) 2863] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2864] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2865] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5218 };
    tokens[(u32) 2866] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2867] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5224 };
    tokens[(u32) 2868] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2869] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5227 };
    tokens[(u32) 2870] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2871] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 2872] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2873] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2874] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5234 };
    tokens[(u32) 2875] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2876] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2877] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 2878] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 2879] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2880] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5244 };
    tokens[(u32) 2881] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2882] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 2883] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2884] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2885] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5251 };
    tokens[(u32) 2886] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2887] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5258 };
    tokens[(u32) 2888] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2889] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2890] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2891] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5261 };
    tokens[(u32) 2892] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2893] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5268 };
    tokens[(u32) 2894] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2895] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2896] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2897] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5271 };
    tokens[(u32) 2898] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2899] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5278 };
    tokens[(u32) 2900] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2901] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2902] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2903] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5281 };
    tokens[(u32) 2904] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2905] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5288 };
    tokens[(u32) 2906] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2907] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2908] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5291 };
    tokens[(u32) 2909] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2910] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5297 };
    tokens[(u32) 2911] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2912] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5300 };
    tokens[(u32) 2913] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2914] = (Token){ .kind = (TokenKind) 16, .data = (u32) 24 };
    tokens[(u32) 2915] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2916] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2917] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2918] = (Token){ .kind = (TokenKind) 44, .data = (u32) 0 };
    tokens[(u32) 2919] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2920] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5307 };
    tokens[(u32) 2921] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2922] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2923] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2924] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2925] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 2926] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5314 };
    tokens[(u32) 2927] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2928] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2929] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5321 };
    tokens[(u32) 2930] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5325 };
    tokens[(u32) 2931] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2932] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5333 };
    tokens[(u32) 2933] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5337 };
    tokens[(u32) 2934] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 2935] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5339 };
    tokens[(u32) 2936] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5343 };
    tokens[(u32) 2937] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2938] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2939] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5345 };
    tokens[(u32) 2940] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5348 };
    tokens[(u32) 2941] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 2942] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 2943] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 2944] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2945] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 2946] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2947] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5355 };
    tokens[(u32) 2948] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5358 };
    tokens[(u32) 2949] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2950] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2951] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2952] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5360 };
    tokens[(u32) 2953] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2954] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 2955] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2956] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5362 };
    tokens[(u32) 2957] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 2958] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2959] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 2960] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5364 };
    tokens[(u32) 2961] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 2962] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 2963] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5371 };
    tokens[(u32) 2964] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2965] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2966] = (Token){ .kind = (TokenKind) 16, .data = (u32) 24 };
    tokens[(u32) 2967] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 2968] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5378 };
    tokens[(u32) 2969] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2970] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 2971] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 2972] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 2973] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2974] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2975] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5380 };
    tokens[(u32) 2976] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2977] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2978] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2979] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5383 };
    tokens[(u32) 2980] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 2981] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5385 };
    tokens[(u32) 2982] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 2983] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5388 };
    tokens[(u32) 2984] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2985] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 2986] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 2987] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 2988] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2989] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 2990] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 2991] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 2992] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5390 };
    tokens[(u32) 2993] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5393 };
    tokens[(u32) 2994] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 2995] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 2996] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 2997] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5395 };
    tokens[(u32) 2998] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 2999] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 3000] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3001] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5397 };
    tokens[(u32) 3002] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 3003] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3004] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3005] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5399 };
    tokens[(u32) 3006] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3007] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 3008] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5406 };
    tokens[(u32) 3009] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 3010] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3011] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 3012] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 3013] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5413 };
    tokens[(u32) 3014] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3015] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 3016] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3017] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3018] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3019] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3020] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5415 };
    tokens[(u32) 3021] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3022] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3023] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3024] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5418 };
    tokens[(u32) 3025] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3026] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5420 };
    tokens[(u32) 3027] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 3028] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5423 };
    tokens[(u32) 3029] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3030] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 3031] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3032] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3033] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3034] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3035] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 3036] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3037] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5425 };
    tokens[(u32) 3038] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5428 };
    tokens[(u32) 3039] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3040] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3041] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3042] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5430 };
    tokens[(u32) 3043] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 3044] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 3045] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3046] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5432 };
    tokens[(u32) 3047] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 3048] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3049] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3050] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5434 };
    tokens[(u32) 3051] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3052] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 3053] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5441 };
    tokens[(u32) 3054] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 3055] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3056] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 3057] = (Token){ .kind = (TokenKind) 19, .data = (u32) 0 };
    tokens[(u32) 3058] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5448 };
    tokens[(u32) 3059] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3060] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 3061] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3062] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3063] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3064] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3065] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5450 };
    tokens[(u32) 3066] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3067] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3068] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3069] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5453 };
    tokens[(u32) 3070] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3071] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5455 };
    tokens[(u32) 3072] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 3073] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5458 };
    tokens[(u32) 3074] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3075] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 3076] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3077] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3078] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3079] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3080] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 3081] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3082] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5460 };
    tokens[(u32) 3083] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5463 };
    tokens[(u32) 3084] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3085] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3086] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3087] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5465 };
    tokens[(u32) 3088] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 3089] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 3090] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3091] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5467 };
    tokens[(u32) 3092] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 3093] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3094] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3095] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5469 };
    tokens[(u32) 3096] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3097] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 3098] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5476 };
    tokens[(u32) 3099] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 3100] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5483 };
    tokens[(u32) 3101] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 3102] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3103] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3104] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3105] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3106] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5485 };
    tokens[(u32) 3107] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3108] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3109] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3110] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5488 };
    tokens[(u32) 3111] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3112] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5490 };
    tokens[(u32) 3113] = (Token){ .kind = (TokenKind) 31, .data = (u32) 0 };
    tokens[(u32) 3114] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5493 };
    tokens[(u32) 3115] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3116] = (Token){ .kind = (TokenKind) 34, .data = (u32) 0 };
    tokens[(u32) 3117] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3118] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3119] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3120] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3121] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5495 };
    tokens[(u32) 3122] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5499 };
    tokens[(u32) 3123] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3124] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3125] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3126] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 3127] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3128] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5501 };
    tokens[(u32) 3129] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5504 };
    tokens[(u32) 3130] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3131] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3132] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3133] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5506 };
    tokens[(u32) 3134] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 3135] = (Token){ .kind = (TokenKind) 64, .data = (u32) 0 };
    tokens[(u32) 3136] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5508 };
    tokens[(u32) 3137] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3138] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5515 };
    tokens[(u32) 3139] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 3140] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3141] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3142] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 3143] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3144] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5517 };
    tokens[(u32) 3145] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3146] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5524 };
    tokens[(u32) 3147] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3148] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3149] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3150] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5526 };
    tokens[(u32) 3151] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3152] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5528 };
    tokens[(u32) 3153] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3154] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5536 };
    tokens[(u32) 3155] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3156] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5538 };
    tokens[(u32) 3157] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3158] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5546 };
    tokens[(u32) 3159] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3160] = (Token){ .kind = (TokenKind) 16, .data = (u32) 31 };
    tokens[(u32) 3161] = (Token){ .kind = (TokenKind) 20, .data = (u32) 0 };
    tokens[(u32) 3162] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5548 };
    tokens[(u32) 3163] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3164] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3165] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3166] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3167] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3168] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 3169] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5550 };
    tokens[(u32) 3170] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3171] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3172] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5552 };
    tokens[(u32) 3173] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5555 };
    tokens[(u32) 3174] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3175] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5562 };
    tokens[(u32) 3176] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5566 };
    tokens[(u32) 3177] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3178] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5568 };
    tokens[(u32) 3179] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5572 };
    tokens[(u32) 3180] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3181] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3182] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 3183] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5574 };
    tokens[(u32) 3184] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3185] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5576 };
    tokens[(u32) 3186] = (Token){ .kind = (TokenKind) 27, .data = (u32) 0 };
    tokens[(u32) 3187] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5582 };
    tokens[(u32) 3188] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3189] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5584 };
    tokens[(u32) 3190] = (Token){ .kind = (TokenKind) 33, .data = (u32) 0 };
    tokens[(u32) 3191] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3192] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5590 };
    tokens[(u32) 3193] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3194] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5592 };
    tokens[(u32) 3195] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 3196] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5598 };
    tokens[(u32) 3197] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3198] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5600 };
    tokens[(u32) 3199] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 3200] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5606 };
    tokens[(u32) 3201] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3202] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5608 };
    tokens[(u32) 3203] = (Token){ .kind = (TokenKind) 27, .data = (u32) 0 };
    tokens[(u32) 3204] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5614 };
    tokens[(u32) 3205] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3206] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5616 };
    tokens[(u32) 3207] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3208] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3209] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3210] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5622 };
    tokens[(u32) 3211] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5625 };
    tokens[(u32) 3212] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3213] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5633 };
    tokens[(u32) 3214] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5637 };
    tokens[(u32) 3215] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3216] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5639 };
    tokens[(u32) 3217] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5643 };
    tokens[(u32) 3218] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3219] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3220] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 3221] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5645 };
    tokens[(u32) 3222] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3223] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5647 };
    tokens[(u32) 3224] = (Token){ .kind = (TokenKind) 27, .data = (u32) 0 };
    tokens[(u32) 3225] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5653 };
    tokens[(u32) 3226] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3227] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5655 };
    tokens[(u32) 3228] = (Token){ .kind = (TokenKind) 33, .data = (u32) 0 };
    tokens[(u32) 3229] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3230] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5661 };
    tokens[(u32) 3231] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3232] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5663 };
    tokens[(u32) 3233] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 3234] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5669 };
    tokens[(u32) 3235] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3236] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5671 };
    tokens[(u32) 3237] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 3238] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5677 };
    tokens[(u32) 3239] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3240] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5679 };
    tokens[(u32) 3241] = (Token){ .kind = (TokenKind) 29, .data = (u32) 0 };
    tokens[(u32) 3242] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5685 };
    tokens[(u32) 3243] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3244] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5687 };
    tokens[(u32) 3245] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3246] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3247] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3248] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5693 };
    tokens[(u32) 3249] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5696 };
    tokens[(u32) 3250] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3251] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5703 };
    tokens[(u32) 3252] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5707 };
    tokens[(u32) 3253] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3254] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5709 };
    tokens[(u32) 3255] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5713 };
    tokens[(u32) 3256] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3257] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3258] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 3259] = (Token){ .kind = (TokenKind) 37, .data = (u32) 0 };
    tokens[(u32) 3260] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5715 };
    tokens[(u32) 3261] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3262] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5723 };
    tokens[(u32) 3263] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3264] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5725 };
    tokens[(u32) 3265] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3266] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3267] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3268] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5727 };
    tokens[(u32) 3269] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5730 };
    tokens[(u32) 3270] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3271] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5738 };
    tokens[(u32) 3272] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5742 };
    tokens[(u32) 3273] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3274] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5744 };
    tokens[(u32) 3275] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5748 };
    tokens[(u32) 3276] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3277] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3278] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 3279] = (Token){ .kind = (TokenKind) 37, .data = (u32) 0 };
    tokens[(u32) 3280] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5750 };
    tokens[(u32) 3281] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3282] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5757 };
    tokens[(u32) 3283] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3284] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5759 };
    tokens[(u32) 3285] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3286] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3287] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3288] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5761 };
    tokens[(u32) 3289] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5764 };
    tokens[(u32) 3290] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3291] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5771 };
    tokens[(u32) 3292] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5775 };
    tokens[(u32) 3293] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3294] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5777 };
    tokens[(u32) 3295] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5781 };
    tokens[(u32) 3296] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3297] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3298] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 3299] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5783 };
    tokens[(u32) 3300] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3301] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5785 };
    tokens[(u32) 3302] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 3303] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5791 };
    tokens[(u32) 3304] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3305] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5793 };
    tokens[(u32) 3306] = (Token){ .kind = (TokenKind) 32, .data = (u32) 0 };
    tokens[(u32) 3307] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5799 };
    tokens[(u32) 3308] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3309] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5801 };
    tokens[(u32) 3310] = (Token){ .kind = (TokenKind) 24, .data = (u32) 0 };
    tokens[(u32) 3311] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5807 };
    tokens[(u32) 3312] = (Token){ .kind = (TokenKind) 49, .data = (u32) 0 };
    tokens[(u32) 3313] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5809 };
    tokens[(u32) 3314] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3315] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3316] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5815 };
    tokens[(u32) 3317] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5819 };
    tokens[(u32) 3318] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3319] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5827 };
    tokens[(u32) 3320] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5831 };
    tokens[(u32) 3321] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3322] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5833 };
    tokens[(u32) 3323] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5837 };
    tokens[(u32) 3324] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3325] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3326] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5839 };
    tokens[(u32) 3327] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5843 };
    tokens[(u32) 3328] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3329] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3330] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3331] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 3332] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3333] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5845 };
    tokens[(u32) 3334] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3335] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5852 };
    tokens[(u32) 3336] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3337] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3338] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3339] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3340] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3341] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5854 };
    tokens[(u32) 3342] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3343] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3344] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3345] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5856 };
    tokens[(u32) 3346] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3347] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3348] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3349] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3350] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 3351] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3352] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5858 };
    tokens[(u32) 3353] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3354] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5865 };
    tokens[(u32) 3355] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3356] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3357] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3358] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3359] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3360] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5867 };
    tokens[(u32) 3361] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3362] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5869 };
    tokens[(u32) 3363] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3364] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5871 };
    tokens[(u32) 3365] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3366] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3367] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3368] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3369] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5873 };
    tokens[(u32) 3370] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5877 };
    tokens[(u32) 3371] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3372] = (Token){ .kind = (TokenKind) 16, .data = (u32) 30 };
    tokens[(u32) 3373] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3374] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3375] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5884 };
    tokens[(u32) 3376] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5888 };
    tokens[(u32) 3377] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3378] = (Token){ .kind = (TokenKind) 16, .data = (u32) 30 };
    tokens[(u32) 3379] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3380] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3381] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5900 };
    tokens[(u32) 3382] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3383] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3384] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3385] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3386] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4 };
    tokens[(u32) 3387] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3388] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5907 };
    tokens[(u32) 3389] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3390] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3391] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3392] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3393] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1073741824 };
    tokens[(u32) 3394] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3395] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5919 };
    tokens[(u32) 3396] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3397] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3398] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3399] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3400] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 3401] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3402] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5926 };
    tokens[(u32) 3403] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3404] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3405] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3406] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3407] = (Token){ .kind = (TokenKind) 16, .data = (u32) 536870912 };
    tokens[(u32) 3408] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3409] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5938 };
    tokens[(u32) 3410] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3411] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2 };
    tokens[(u32) 3412] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3413] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3414] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 3415] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3416] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5945 };
    tokens[(u32) 3417] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3418] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2 };
    tokens[(u32) 3419] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3420] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3421] = (Token){ .kind = (TokenKind) 16, .data = (u32) 268435456 };
    tokens[(u32) 3422] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3423] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5957 };
    tokens[(u32) 3424] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3425] = (Token){ .kind = (TokenKind) 16, .data = (u32) 3 };
    tokens[(u32) 3426] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3427] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3428] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 3429] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3430] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5964 };
    tokens[(u32) 3431] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3432] = (Token){ .kind = (TokenKind) 16, .data = (u32) 3 };
    tokens[(u32) 3433] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3434] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3435] = (Token){ .kind = (TokenKind) 16, .data = (u32) 134217728 };
    tokens[(u32) 3436] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3437] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5976 };
    tokens[(u32) 3438] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3439] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4 };
    tokens[(u32) 3440] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3441] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3442] = (Token){ .kind = (TokenKind) 16, .data = (u32) 64 };
    tokens[(u32) 3443] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3444] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5983 };
    tokens[(u32) 3445] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3446] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4 };
    tokens[(u32) 3447] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3448] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3449] = (Token){ .kind = (TokenKind) 16, .data = (u32) 67108864 };
    tokens[(u32) 3450] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3451] = (Token){ .kind = (TokenKind) 5, .data = (u32) 5995 };
    tokens[(u32) 3452] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3453] = (Token){ .kind = (TokenKind) 16, .data = (u32) 5 };
    tokens[(u32) 3454] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3455] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3456] = (Token){ .kind = (TokenKind) 16, .data = (u32) 128 };
    tokens[(u32) 3457] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3458] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6002 };
    tokens[(u32) 3459] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3460] = (Token){ .kind = (TokenKind) 16, .data = (u32) 5 };
    tokens[(u32) 3461] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3462] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3463] = (Token){ .kind = (TokenKind) 16, .data = (u32) 33554432 };
    tokens[(u32) 3464] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3465] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6014 };
    tokens[(u32) 3466] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3467] = (Token){ .kind = (TokenKind) 16, .data = (u32) 6 };
    tokens[(u32) 3468] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3469] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3470] = (Token){ .kind = (TokenKind) 16, .data = (u32) 256 };
    tokens[(u32) 3471] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3472] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6021 };
    tokens[(u32) 3473] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3474] = (Token){ .kind = (TokenKind) 16, .data = (u32) 6 };
    tokens[(u32) 3475] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3476] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3477] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16777216 };
    tokens[(u32) 3478] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3479] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6033 };
    tokens[(u32) 3480] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3481] = (Token){ .kind = (TokenKind) 16, .data = (u32) 7 };
    tokens[(u32) 3482] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3483] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3484] = (Token){ .kind = (TokenKind) 16, .data = (u32) 512 };
    tokens[(u32) 3485] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3486] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6040 };
    tokens[(u32) 3487] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3488] = (Token){ .kind = (TokenKind) 16, .data = (u32) 7 };
    tokens[(u32) 3489] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3490] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3491] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8388608 };
    tokens[(u32) 3492] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3493] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6052 };
    tokens[(u32) 3494] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3495] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 3496] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3497] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3498] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1024 };
    tokens[(u32) 3499] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3500] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6059 };
    tokens[(u32) 3501] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3502] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 3503] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3504] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3505] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4194304 };
    tokens[(u32) 3506] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3507] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6071 };
    tokens[(u32) 3508] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3509] = (Token){ .kind = (TokenKind) 16, .data = (u32) 9 };
    tokens[(u32) 3510] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3511] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3512] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2048 };
    tokens[(u32) 3513] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3514] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6078 };
    tokens[(u32) 3515] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3516] = (Token){ .kind = (TokenKind) 16, .data = (u32) 9 };
    tokens[(u32) 3517] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3518] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3519] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2097152 };
    tokens[(u32) 3520] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3521] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6090 };
    tokens[(u32) 3522] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3523] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 3524] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3525] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3526] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4096 };
    tokens[(u32) 3527] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3528] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6097 };
    tokens[(u32) 3529] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3530] = (Token){ .kind = (TokenKind) 16, .data = (u32) 10 };
    tokens[(u32) 3531] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3532] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3533] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1048576 };
    tokens[(u32) 3534] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3535] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6109 };
    tokens[(u32) 3536] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3537] = (Token){ .kind = (TokenKind) 16, .data = (u32) 11 };
    tokens[(u32) 3538] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3539] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3540] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8192 };
    tokens[(u32) 3541] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3542] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6116 };
    tokens[(u32) 3543] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3544] = (Token){ .kind = (TokenKind) 16, .data = (u32) 11 };
    tokens[(u32) 3545] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3546] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3547] = (Token){ .kind = (TokenKind) 16, .data = (u32) 524288 };
    tokens[(u32) 3548] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3549] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6128 };
    tokens[(u32) 3550] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3551] = (Token){ .kind = (TokenKind) 16, .data = (u32) 12 };
    tokens[(u32) 3552] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3553] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3554] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16384 };
    tokens[(u32) 3555] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3556] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6135 };
    tokens[(u32) 3557] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3558] = (Token){ .kind = (TokenKind) 16, .data = (u32) 12 };
    tokens[(u32) 3559] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3560] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3561] = (Token){ .kind = (TokenKind) 16, .data = (u32) 262144 };
    tokens[(u32) 3562] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3563] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6147 };
    tokens[(u32) 3564] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3565] = (Token){ .kind = (TokenKind) 16, .data = (u32) 13 };
    tokens[(u32) 3566] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3567] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3568] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32768 };
    tokens[(u32) 3569] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3570] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6154 };
    tokens[(u32) 3571] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3572] = (Token){ .kind = (TokenKind) 16, .data = (u32) 13 };
    tokens[(u32) 3573] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3574] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3575] = (Token){ .kind = (TokenKind) 16, .data = (u32) 131072 };
    tokens[(u32) 3576] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3577] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6166 };
    tokens[(u32) 3578] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3579] = (Token){ .kind = (TokenKind) 16, .data = (u32) 14 };
    tokens[(u32) 3580] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3581] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3582] = (Token){ .kind = (TokenKind) 16, .data = (u32) 65536 };
    tokens[(u32) 3583] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3584] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6173 };
    tokens[(u32) 3585] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3586] = (Token){ .kind = (TokenKind) 16, .data = (u32) 14 };
    tokens[(u32) 3587] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3588] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3589] = (Token){ .kind = (TokenKind) 16, .data = (u32) 65536 };
    tokens[(u32) 3590] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3591] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6185 };
    tokens[(u32) 3592] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3593] = (Token){ .kind = (TokenKind) 16, .data = (u32) 15 };
    tokens[(u32) 3594] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3595] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3596] = (Token){ .kind = (TokenKind) 16, .data = (u32) 131072 };
    tokens[(u32) 3597] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3598] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6192 };
    tokens[(u32) 3599] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3600] = (Token){ .kind = (TokenKind) 16, .data = (u32) 15 };
    tokens[(u32) 3601] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3602] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3603] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32768 };
    tokens[(u32) 3604] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3605] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6204 };
    tokens[(u32) 3606] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3607] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 3608] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3609] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3610] = (Token){ .kind = (TokenKind) 16, .data = (u32) 262144 };
    tokens[(u32) 3611] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3612] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6211 };
    tokens[(u32) 3613] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3614] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 3615] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3616] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3617] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16384 };
    tokens[(u32) 3618] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3619] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6223 };
    tokens[(u32) 3620] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3621] = (Token){ .kind = (TokenKind) 16, .data = (u32) 17 };
    tokens[(u32) 3622] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3623] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3624] = (Token){ .kind = (TokenKind) 16, .data = (u32) 524288 };
    tokens[(u32) 3625] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3626] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6230 };
    tokens[(u32) 3627] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3628] = (Token){ .kind = (TokenKind) 16, .data = (u32) 17 };
    tokens[(u32) 3629] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3630] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3631] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8192 };
    tokens[(u32) 3632] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3633] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6242 };
    tokens[(u32) 3634] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3635] = (Token){ .kind = (TokenKind) 16, .data = (u32) 18 };
    tokens[(u32) 3636] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3637] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3638] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1048576 };
    tokens[(u32) 3639] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3640] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6249 };
    tokens[(u32) 3641] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3642] = (Token){ .kind = (TokenKind) 16, .data = (u32) 18 };
    tokens[(u32) 3643] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3644] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3645] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4096 };
    tokens[(u32) 3646] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3647] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6261 };
    tokens[(u32) 3648] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3649] = (Token){ .kind = (TokenKind) 16, .data = (u32) 19 };
    tokens[(u32) 3650] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3651] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3652] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2097152 };
    tokens[(u32) 3653] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3654] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6268 };
    tokens[(u32) 3655] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3656] = (Token){ .kind = (TokenKind) 16, .data = (u32) 19 };
    tokens[(u32) 3657] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3658] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3659] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2048 };
    tokens[(u32) 3660] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3661] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6280 };
    tokens[(u32) 3662] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3663] = (Token){ .kind = (TokenKind) 16, .data = (u32) 20 };
    tokens[(u32) 3664] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3665] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3666] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4194304 };
    tokens[(u32) 3667] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3668] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6287 };
    tokens[(u32) 3669] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3670] = (Token){ .kind = (TokenKind) 16, .data = (u32) 20 };
    tokens[(u32) 3671] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3672] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3673] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1024 };
    tokens[(u32) 3674] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3675] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6299 };
    tokens[(u32) 3676] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3677] = (Token){ .kind = (TokenKind) 16, .data = (u32) 21 };
    tokens[(u32) 3678] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3679] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3680] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8388608 };
    tokens[(u32) 3681] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3682] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6306 };
    tokens[(u32) 3683] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3684] = (Token){ .kind = (TokenKind) 16, .data = (u32) 21 };
    tokens[(u32) 3685] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3686] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3687] = (Token){ .kind = (TokenKind) 16, .data = (u32) 512 };
    tokens[(u32) 3688] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3689] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6318 };
    tokens[(u32) 3690] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3691] = (Token){ .kind = (TokenKind) 16, .data = (u32) 22 };
    tokens[(u32) 3692] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3693] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3694] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16777216 };
    tokens[(u32) 3695] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3696] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6325 };
    tokens[(u32) 3697] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3698] = (Token){ .kind = (TokenKind) 16, .data = (u32) 22 };
    tokens[(u32) 3699] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3700] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3701] = (Token){ .kind = (TokenKind) 16, .data = (u32) 256 };
    tokens[(u32) 3702] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3703] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6337 };
    tokens[(u32) 3704] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3705] = (Token){ .kind = (TokenKind) 16, .data = (u32) 23 };
    tokens[(u32) 3706] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3707] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3708] = (Token){ .kind = (TokenKind) 16, .data = (u32) 33554432 };
    tokens[(u32) 3709] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3710] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6344 };
    tokens[(u32) 3711] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3712] = (Token){ .kind = (TokenKind) 16, .data = (u32) 23 };
    tokens[(u32) 3713] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3714] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3715] = (Token){ .kind = (TokenKind) 16, .data = (u32) 128 };
    tokens[(u32) 3716] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3717] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6356 };
    tokens[(u32) 3718] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3719] = (Token){ .kind = (TokenKind) 16, .data = (u32) 24 };
    tokens[(u32) 3720] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3721] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3722] = (Token){ .kind = (TokenKind) 16, .data = (u32) 67108864 };
    tokens[(u32) 3723] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3724] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6363 };
    tokens[(u32) 3725] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3726] = (Token){ .kind = (TokenKind) 16, .data = (u32) 24 };
    tokens[(u32) 3727] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3728] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3729] = (Token){ .kind = (TokenKind) 16, .data = (u32) 64 };
    tokens[(u32) 3730] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3731] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6375 };
    tokens[(u32) 3732] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3733] = (Token){ .kind = (TokenKind) 16, .data = (u32) 25 };
    tokens[(u32) 3734] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3735] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3736] = (Token){ .kind = (TokenKind) 16, .data = (u32) 134217728 };
    tokens[(u32) 3737] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3738] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6382 };
    tokens[(u32) 3739] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3740] = (Token){ .kind = (TokenKind) 16, .data = (u32) 25 };
    tokens[(u32) 3741] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3742] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3743] = (Token){ .kind = (TokenKind) 16, .data = (u32) 32 };
    tokens[(u32) 3744] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3745] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6394 };
    tokens[(u32) 3746] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3747] = (Token){ .kind = (TokenKind) 16, .data = (u32) 26 };
    tokens[(u32) 3748] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3749] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3750] = (Token){ .kind = (TokenKind) 16, .data = (u32) 268435456 };
    tokens[(u32) 3751] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3752] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6401 };
    tokens[(u32) 3753] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3754] = (Token){ .kind = (TokenKind) 16, .data = (u32) 26 };
    tokens[(u32) 3755] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3756] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3757] = (Token){ .kind = (TokenKind) 16, .data = (u32) 16 };
    tokens[(u32) 3758] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3759] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6413 };
    tokens[(u32) 3760] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3761] = (Token){ .kind = (TokenKind) 16, .data = (u32) 27 };
    tokens[(u32) 3762] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3763] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3764] = (Token){ .kind = (TokenKind) 16, .data = (u32) 536870912 };
    tokens[(u32) 3765] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3766] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6420 };
    tokens[(u32) 3767] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3768] = (Token){ .kind = (TokenKind) 16, .data = (u32) 27 };
    tokens[(u32) 3769] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3770] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3771] = (Token){ .kind = (TokenKind) 16, .data = (u32) 8 };
    tokens[(u32) 3772] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3773] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6432 };
    tokens[(u32) 3774] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3775] = (Token){ .kind = (TokenKind) 16, .data = (u32) 28 };
    tokens[(u32) 3776] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3777] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3778] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1073741824 };
    tokens[(u32) 3779] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3780] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6439 };
    tokens[(u32) 3781] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3782] = (Token){ .kind = (TokenKind) 16, .data = (u32) 28 };
    tokens[(u32) 3783] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3784] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3785] = (Token){ .kind = (TokenKind) 16, .data = (u32) 4 };
    tokens[(u32) 3786] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3787] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6451 };
    tokens[(u32) 3788] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3789] = (Token){ .kind = (TokenKind) 16, .data = (u32) 29 };
    tokens[(u32) 3790] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3791] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3792] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2147483648 };
    tokens[(u32) 3793] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3794] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6458 };
    tokens[(u32) 3795] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3796] = (Token){ .kind = (TokenKind) 16, .data = (u32) 29 };
    tokens[(u32) 3797] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3798] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3799] = (Token){ .kind = (TokenKind) 16, .data = (u32) 2 };
    tokens[(u32) 3800] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3801] = (Token){ .kind = (TokenKind) 63, .data = (u32) 0 };
    tokens[(u32) 3802] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3803] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6470 };
    tokens[(u32) 3804] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6473 };
    tokens[(u32) 3805] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3806] = (Token){ .kind = (TokenKind) 16, .data = (u32) 0 };
    tokens[(u32) 3807] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3808] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6475 };
    tokens[(u32) 3809] = (Token){ .kind = (TokenKind) 26, .data = (u32) 0 };
    tokens[(u32) 3810] = (Token){ .kind = (TokenKind) 16, .data = (u32) 30 };
    tokens[(u32) 3811] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3812] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6477 };
    tokens[(u32) 3813] = (Token){ .kind = (TokenKind) 39, .data = (u32) 0 };
    tokens[(u32) 3814] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3815] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3816] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 3817] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3818] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6479 };
    tokens[(u32) 3819] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3820] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6486 };
    tokens[(u32) 3821] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3822] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6488 };
    tokens[(u32) 3823] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3824] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6495 };
    tokens[(u32) 3825] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3826] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3827] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3828] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3829] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6497 };
    tokens[(u32) 3830] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6501 };
    tokens[(u32) 3831] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3832] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6512 };
    tokens[(u32) 3833] = (Token){ .kind = (TokenKind) 12, .data = (u32) 0 };
    tokens[(u32) 3834] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6524 };
    tokens[(u32) 3835] = (Token){ .kind = (TokenKind) 13, .data = (u32) 0 };
    tokens[(u32) 3836] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3837] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6526 };
    tokens[(u32) 3838] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6530 };
    tokens[(u32) 3839] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3840] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6537 };
    tokens[(u32) 3841] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3842] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6545 };
    tokens[(u32) 3843] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3844] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6556 };
    tokens[(u32) 3845] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3846] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3847] = (Token){ .kind = (TokenKind) 43, .data = (u32) 0 };
    tokens[(u32) 3848] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3849] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6558 };
    tokens[(u32) 3850] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3851] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6566 };
    tokens[(u32) 3852] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3853] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6568 };
    tokens[(u32) 3854] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3855] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3856] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3857] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6575 };
    tokens[(u32) 3858] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3859] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6577 };
    tokens[(u32) 3860] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3861] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6585 };
    tokens[(u32) 3862] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3863] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6587 };
    tokens[(u32) 3864] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3865] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3866] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6594 };
    tokens[(u32) 3867] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3868] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6596 };
    tokens[(u32) 3869] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3870] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6604 };
    tokens[(u32) 3871] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3872] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6606 };
    tokens[(u32) 3873] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3874] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3875] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3876] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3877] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3878] = (Token){ .kind = (TokenKind) 45, .data = (u32) 0 };
    tokens[(u32) 3879] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3880] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6617 };
    tokens[(u32) 3881] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3882] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6625 };
    tokens[(u32) 3883] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3884] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6627 };
    tokens[(u32) 3885] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3886] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3887] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3888] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6629 };
    tokens[(u32) 3889] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3890] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6631 };
    tokens[(u32) 3891] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3892] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6639 };
    tokens[(u32) 3893] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3894] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6641 };
    tokens[(u32) 3895] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3896] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3897] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6643 };
    tokens[(u32) 3898] = (Token){ .kind = (TokenKind) 18, .data = (u32) 0 };
    tokens[(u32) 3899] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6645 };
    tokens[(u32) 3900] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3901] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6653 };
    tokens[(u32) 3902] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3903] = (Token){ .kind = (TokenKind) 16, .data = (u32) 1 };
    tokens[(u32) 3904] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3905] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3906] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3907] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 3908] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6655 };
    tokens[(u32) 3909] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3910] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    tokens[(u32) 3911] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6657 };
    tokens[(u32) 3912] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6661 };
    tokens[(u32) 3913] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3914] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6669 };
    tokens[(u32) 3915] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6673 };
    tokens[(u32) 3916] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3917] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6675 };
    tokens[(u32) 3918] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6679 };
    tokens[(u32) 3919] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3920] = (Token){ .kind = (TokenKind) 6, .data = (u32) 0 };
    tokens[(u32) 3921] = (Token){ .kind = (TokenKind) 60, .data = (u32) 0 };
    tokens[(u32) 3922] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6681 };
    tokens[(u32) 3923] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3924] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6689 };
    tokens[(u32) 3925] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3926] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6691 };
    tokens[(u32) 3927] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3928] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6699 };
    tokens[(u32) 3929] = (Token){ .kind = (TokenKind) 8, .data = (u32) 0 };
    tokens[(u32) 3930] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6707 };
    tokens[(u32) 3931] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3932] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6709 };
    tokens[(u32) 3933] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3934] = (Token){ .kind = (TokenKind) 17, .data = (u32) 0 };
    tokens[(u32) 3935] = (Token){ .kind = (TokenKind) 5, .data = (u32) 6711 };
    tokens[(u32) 3936] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3937] = (Token){ .kind = (TokenKind) 9, .data = (u32) 0 };
    tokens[(u32) 3938] = (Token){ .kind = (TokenKind) 11, .data = (u32) 0 };
    tokens[(u32) 3939] = (Token){ .kind = (TokenKind) 7, .data = (u32) 0 };
    num_tokens += (u32) 3940;
}


u8 code_buffer[CODE_BUFFER_CAPACITY];
u32 code_buffer_length = 0;

Token tokens[TOKENS_CAPACITY];
u32 num_tokens = 0;

u8 aux[AUX_CAPACITY];
u32 num_aux = 0;

Type types[TYPES_CAPACITY];
u32 num_types = 0;

u32 dimensions[UNIQUE_DIMENSIONS_CAPACITY][4];
u32 num_dimensions = 1; // First is reserved for all zeros

Function functions[FUNCTIONS_CAPACITY];
u32 num_functions = 0;

Expression expressions[EXPRESSIONS_CAPACITY];
u32 num_expressions = 0;

u32 statements[STATEMENTS_CAPACITY];
u32 num_statements = 0;

u32 operands[OPERANDS_CAPACITY];
u32 num_operands = 0;

Global globals[GLOBALS_CAPACITY];
u32 num_globals = 0;

TypeDef typedefs[TYPEDEFS_CAPACITY];
u32 num_typedefs = 0;

TypeAlias type_aliases[TYPE_ALIASES_CAPACITY];
u32 num_type_aliases = 0;

Define defines[DEFINES_CAPACITY];
u32 num_defines;

CloseNeeded closes_needed[CLOSES_NEEDED_CAPCAITY];
u32 num_closes_needed = 0;

u32 add_type(Type type){
    for(u32 i = 0; i < num_types; i++){
        if(type_equals(type, types[i])){
            return i;
        }
    }

    if(num_types < TYPES_CAPACITY){
        types[num_types] = type;
        return num_types++;
    }

    printf("Out of memory: Exceeded maximum number of types\n");
    return TYPES_CAPACITY;
}

u32 add_dimensions(u32 type_dimensions[4]){
    // Try to find existing slot with same value
    for(u32 i = 0; i < UNIQUE_DIMENSIONS_CAPACITY; i++){
        u1 match = memcmp(dimensions[i], type_dimensions, sizeof dimensions[i]) == 0;

        if(match){
            return i;
        }
    }

    // Insert if not found
    if(num_dimensions + 1 >= UNIQUE_DIMENSIONS_CAPACITY){
        return UNIQUE_DIMENSIONS_CAPACITY;
    }

    for(u32 i = 0; i < 4; i++){
        dimensions[num_dimensions][i] = type_dimensions[i];
    }

    return num_dimensions++;
}


u32 add_function(Function function){
    if(num_functions >= FUNCTIONS_CAPACITY){
        printf("Out of memory: Exceeded maximum number of functions\n");
        return FUNCTIONS_CAPACITY;
    }

    functions[num_functions] = function;
    return num_functions++;
}

u32 find_function(u32 name){
    for(u32 i = 0; i < num_functions; i++){
        if(aux_cstr_equals(functions[i].name, name)){
            return i;
        }
    }

    return FUNCTIONS_CAPACITY;
}

u32 find_function_return_type(u32 name){
    u32 function_index = find_function(name);

    if(function_index >= FUNCTIONS_CAPACITY){
        return TYPES_CAPACITY;
    } else {
        return functions[function_index].return_type;
    }
}

u32 add_expression(Expression expression){
    if(num_expressions < EXPRESSIONS_CAPACITY){
        expressions[num_expressions] = expression;
        return num_expressions++;
    } else {
        printf("Out of memory: Exceeded maximum number of total expressions\n");
        return EXPRESSIONS_CAPACITY;
    }
}

u32 add_statement_from_existing(u32 expression_index){
    if(num_statements < STATEMENTS_CAPACITY){
        statements[num_statements] = expression_index;
        return num_statements++;
    } else {
        printf("Out of memory: Exceeded maximum number of total statements\n");
        return STATEMENTS_CAPACITY;
    }
}

u32 add_statement_from_new(Expression expression){
    u32 expression_index = add_expression(expression);

    if(expression_index < EXPRESSIONS_CAPACITY){
        return add_statement_from_existing(expression_index);
    } else {
        return STATEMENTS_CAPACITY;
    }
}

u32 add_operand(u32 a){
    if(num_operands < OPERANDS_CAPACITY){
        operands[num_operands] = a;
        return num_operands++;
    } else {
        printf("Out of memory: Exceeded maximum number of total expression operands\n");
        return OPERANDS_CAPACITY;
    }
}

u32 add_operands2(u32 a, u32 b){
    if(num_operands < OPERANDS_CAPACITY - 1){
        u32 result = num_operands;
        operands[num_operands] = a;
        operands[num_operands + 1] = b;
        num_operands += 2;
        return result;
    } else {
        printf("Out of memory: Exceeded maximum number of total expression operands\n");
        return OPERANDS_CAPACITY;
    }
}

u32 add_operands3(u32 a, u32 b, u32 c){
    if(num_operands < OPERANDS_CAPACITY - 2){
        u32 result = num_operands;
        operands[num_operands] = a;
        operands[num_operands + 1] = b;
        operands[num_operands + 2] = c;
        num_operands += 3;
        return result;
    } else {
        printf("Out of memory: Exceeded maximum number of total expression operands\n");
        return OPERANDS_CAPACITY;
    }
}

u32 add_operands5(u32 a, u32 b, u32 c, u32 d, u32 e){
    if(num_operands < OPERANDS_CAPACITY - 4){
        u32 result = num_operands;
        operands[num_operands] = a;
        operands[num_operands + 1] = b;
        operands[num_operands + 2] = c;
        operands[num_operands + 3] = d;
        operands[num_operands + 4] = e;
        num_operands += 5;
        return result;
    } else {
        printf("Out of memory: Exceeded maximum number of total expression operands\n");
        return OPERANDS_CAPACITY;
    }
}

u32 add_global(Global global){
    if(num_globals < GLOBALS_CAPACITY){
        globals[num_globals] = global;
        return num_globals++;
    }

    printf("Out of memory: Exceeded maximum number of global variables\n");
    return GLOBALS_CAPACITY;
}

u32 add_typedef(TypeDef def){
    if(num_typedefs < TYPEDEFS_CAPACITY){
        typedefs[num_typedefs] = def;
        return num_typedefs++;
    }

    printf("Out of memory: Exceeded maximum number of type definitions\n");
    return TYPEDEFS_CAPACITY;
}

u32 find_typedef(u32 name){
    for(u32 i = 0; i < num_typedefs; i++){
        if(aux_cstr_equals(typedefs[i].name, name)){
            return i;
        }
    }
    return TYPEDEFS_CAPACITY;
}

u32 add_type_alias(TypeAlias alias){
    if(num_type_aliases < TYPE_ALIASES_CAPACITY){
        type_aliases[num_type_aliases] = alias;
        return num_type_aliases++;
    }

    printf("Out of memory: Exceeded maximum number of type aliases\n");
    return TYPE_ALIASES_CAPACITY;
}

u32 try_resolve_type_alias(u32 name){
    for(u32 i = 0; i < num_type_aliases; i++){
        if(aux_cstr_equals(type_aliases[i].name, name)){
            return type_aliases[i].rewritten_type;
        }
    }
    
    return TYPES_CAPACITY;
}

u32 add_define(Define define){
    if(num_defines < DEFINES_CAPACITY){
        defines[num_defines] = define;
        return num_defines++;
    }

    printf("Out of memory: Exceeded maximum number of #define's\n");
    return DEFINES_CAPACITY;
}

u32 try_resolve_define(u32 name, u1 use_preferred_type){
    for(u32 i = 0; i < num_defines; i++){
        if(aux_cstr_equals(defines[i].name, name)){
            return defines[i].expression;
        }
    }

    return EXPRESSIONS_CAPACITY;
}

u32 aux_cstr_alloc(u8 null_terminated_name[32]){
    u8 length = 0;

    while(length < 32 && (u1) null_terminated_name[length]){
        length++;
    }

    if(num_aux + (u32) length + 1 >= AUX_CAPACITY){
        printf("Out of memory: Auxiliary memory used up\n");
        return AUX_CAPACITY;
    }

    u32 name = num_aux;
    for(u8 i = 0; i < length; i++){
        aux[num_aux++] = null_terminated_name[i];
    }

    aux[num_aux++] = '\0';
    return name;
}

u1 aux_cstr_equals(u32 a, u32 b){
    for(u32 i = 0; aux[a + i] == aux[b + i]; i++){
        if(aux[a + i] == '\0'){
            return true;
        }
    }
    return false;
}

u1 aux_cstr_equals_string(u32 a, u8 string[32]){
    for(u32 i = 0; i < 32 && aux[a + i] == string[i]; i++){
        if(aux[a + i] == '\0'){
            return true;
        }
    }
    return false;
}

u1 aux_cstr_equals_print(u32 a){
    return a + 5 < AUX_CAPACITY
        && aux[a    ] == 'p'
        && aux[a + 1] == 'r'
        && aux[a + 2] == 'i'
        && aux[a + 3] == 'n'
        && aux[a + 4] == 't'
        && aux[a + 5] == '\0';
}

u1 aux_cstr_equals_main(u32 a){
    return a + 4 < AUX_CAPACITY
        && aux[a    ] == 'm'
        && aux[a + 1] == 'a'
        && aux[a + 2] == 'i'
        && aux[a + 3] == 'n'
        && aux[a + 4] == '\0';
}

u1 aux_cstr_equals_put(u32 a){
    return a + 3 < AUX_CAPACITY
        && aux[a    ] == 'p'
        && aux[a + 1] == 'u'
        && aux[a + 2] == 't'
        && aux[a + 3] == '\0';
}

u1 aux_cstr_equals_u0(u32 a){
    return a + 2 < AUX_CAPACITY
        && aux[a    ] == 'u'
        && aux[a + 1] == '0'
        && aux[a + 2] == '\0';
}

u1 aux_cstr_equals_u1(u32 a){
    return a + 2 < AUX_CAPACITY
        && aux[a    ] == 'u'
        && aux[a + 1] == '1'
        && aux[a + 2] == '\0';
}

u1 aux_cstr_equals_u8(u32 a){
    return a + 2 < AUX_CAPACITY
        && aux[a    ] == 'u'
        && aux[a + 1] == '8'
        && aux[a + 2] == '\0';
}

u1 aux_cstr_equals_u16(u32 a){
    return a + 3 < AUX_CAPACITY
        && aux[a    ] == 'u'
        && aux[a + 1] == '1'
        && aux[a + 2] == '6'
        && aux[a + 3] == '\0';
}

u32 aux_cstr_len(u32 str){
    u32 len = 0;

    while(aux[str + len] != 0){
        len++;
    }

    return len;
}

u1 aux_cstr_equals_u32(u32 a){
    return a + 3 < AUX_CAPACITY
        && aux[a    ] == 'u'
        && aux[a + 1] == '3'
        && aux[a + 2] == '2'
        && aux[a + 3] == '\0';
}

u1 aux_cstr_equals_void(u32 a){
    return a + 4 < AUX_CAPACITY
        && aux[a    ] == 'v'
        && aux[a + 1] == 'o'
        && aux[a + 2] == 'i'
        && aux[a + 3] == 'd'
        && aux[a + 4] == '\0';
}

u1 aux_cstr_equals_bool(u32 a){
    return a + 4 < AUX_CAPACITY
        && aux[a    ] == 'b'
        && aux[a + 1] == 'o'
        && aux[a + 2] == 'o'
        && aux[a + 3] == 'l'
        && aux[a + 4] == '\0';
}

u1 aux_cstr_equals_char(u32 a){
    return a + 4 < AUX_CAPACITY
        && aux[a    ] == 'c'
        && aux[a + 1] == 'h'
        && aux[a + 2] == 'a'
        && aux[a + 3] == 'r'
        && aux[a + 4] == '\0';
}

u1 aux_cstr_equals_short(u32 a){
    return a + 5 < AUX_CAPACITY
        && aux[a    ] == 's'
        && aux[a + 1] == 'h'
        && aux[a + 2] == 'o'
        && aux[a + 3] == 'r'
        && aux[a + 4] == 't'
        && aux[a + 5] == '\0';
}

u1 aux_cstr_equals_int(u32 a){
    return a + 3 < AUX_CAPACITY
        && aux[a    ] == 'i'
        && aux[a + 1] == 'n'
        && aux[a + 2] == 't'
        && aux[a + 3] == '\0';
}

u1 aux_cstr_equals_long(u32 a){
    return a + 4 < AUX_CAPACITY
        && aux[a    ] == 'l'
        && aux[a + 1] == 'o'
        && aux[a + 2] == 'n'
        && aux[a + 3] == 'g'
        && aux[a + 4] == '\0';
}

u1 aux_cstr_equals_panicloop(u32 a){
    return a + 9 < AUX_CAPACITY
        && aux[a    ] == 'p'
        && aux[a + 1] == 'a'
        && aux[a + 2] == 'n'
        && aux[a + 3] == 'i'
        && aux[a + 4] == 'c'
        && aux[a + 5] == 'l'
        && aux[a + 6] == 'o'
        && aux[a + 7] == 'o'
        && aux[a + 8] == 'p'
        && aux[a + 9] == '\0';
}

u1 aux_cstr_equals_define(u32 a){
    return a + 6 < AUX_CAPACITY
        && aux[a    ] == 'd'
        && aux[a + 1] == 'e'
        && aux[a + 2] == 'f'
        && aux[a + 3] == 'i'
        && aux[a + 4] == 'n'
        && aux[a + 5] == 'e'
        && aux[a + 6] == '\0';
}

u1 aux_cstr_equals_printf(u32 a){
    return a + 6 < AUX_CAPACITY
        && aux[a    ] == 'p'
        && aux[a + 1] == 'r'
        && aux[a + 2] == 'i'
        && aux[a + 3] == 'n'
        && aux[a + 4] == 't'
        && aux[a + 5] == 'f'
        && aux[a + 6] == '\0';
}

u1 aux_cstr_equals_memcmp(u32 a){
    return a + 6 < AUX_CAPACITY
        && aux[a    ] == 'm'
        && aux[a + 1] == 'e'
        && aux[a + 2] == 'm'
        && aux[a + 3] == 'c'
        && aux[a + 4] == 'm'
        && aux[a + 5] == 'p'
        && aux[a + 6] == '\0';
}

u1 aux_cstr_equals_memcpy(u32 a){
    return a + 6 < AUX_CAPACITY
        && aux[a    ] == 'm'
        && aux[a + 1] == 'e'
        && aux[a + 2] == 'm'
        && aux[a + 3] == 'c'
        && aux[a + 4] == 'p'
        && aux[a + 5] == 'y'
        && aux[a + 6] == '\0';
}

u0 print_aux_cstr(u32 index){
    for(u32 i = index; (u1) aux[i]; i++){
        put(aux[i]);
    }
}

u0 print_aux_cstr_escaped(u32 index){
    for(u32 i = index; (u1) aux[i]; i++){
        u8 c = aux[i];
        if(c == '\n'){
            printf("\\n");
        } else if(c == '\\'){
            printf("\\\\");
        } else if(c == '\t'){
            printf("\\t");
        } else if(c == '\0'){
            printf("\\0");
        } else {
            put(aux[i]);
        }
    }
}

u32 find_enum_from_type(u32 type_index){
    Type type = types[type_index];

    if(type.dimensions != 0){
        return TYPEDEFS_CAPACITY;
    }

    for(u32 i = 0; i < num_typedefs; i++){
        TypeDef def = typedefs[i];

        if(def.kind == TYPEDEF_ENUM && aux_cstr_equals(def.name, type.name)){
            return i;
        }
    }

    return TYPEDEFS_CAPACITY;
}

u1 in_range_inclusive(u8 value, u8 min_inclusive, u8 max_inclusive){
    return value >= min_inclusive && value <= max_inclusive;
}



u0 token_print(Token token, u1 safe){
    if(safe){
        printf("token: ");
    }

    switch(token.kind){
    case TOKEN_NONE:
        printf("<none>");
        break;
    case TOKEN_DONE:
        printf("<done>");
        break;
    case TOKEN_ERROR:
        printf("<error>");
        break;
    case TOKEN_WORD:
        printf("word: ");
        print_aux_cstr(token.data);
        break;
    case TOKEN_BEGIN:
        printf("{");
        break;
    case TOKEN_END:
        printf("}");
        break;
    case TOKEN_OPEN:
        printf("(");
        break;
    case TOKEN_CLOSE:
        printf(")");
        break;
    case TOKEN_STRING:
        printf("\"");
        print_aux_cstr(token.data);
        printf("\"");
        break;
    case TOKEN_SEMICOLON:
        printf(";");
        break;
    case TOKEN_OPEN_BRACKET:
        printf("[");
        break;
    case TOKEN_CLOSE_BRACKET:
        printf("]");
        break;
    case TOKEN_TRUE:
        printf("true");
        break;
    case TOKEN_FALSE:
        printf("false");
        break;
    case TOKEN_INT:
        printf("%d", token.data);
        break;
    case TOKEN_NEXT:
        printf(",");
        break;
    case TOKEN_ASSIGN:
        printf("=");
        break;
    case TOKEN_ADD:
        printf("+");
        break;
    case TOKEN_SUBTRACT:
        printf("-");
        break;
    case TOKEN_MULTIPLY:
        printf("*");
        break;
    case TOKEN_DIVIDE:
        printf("/");
        break;
    case TOKEN_MOD:
        printf("%%");
        break;
    case TOKEN_EQUALS:
        printf("==");
        break;
    case TOKEN_NOT_EQUALS:
        printf("!=");
        break;
    case TOKEN_LESS_THAN:
        printf("<");
        break;
    case TOKEN_GREATER_THAN:
        printf(">");
        break;
    case TOKEN_LESS_THAN_OR_EQUAL:
        printf("<=");
        break;
    case TOKEN_GREATER_THAN_OR_EQUAL:
        printf(">=");
        break;
    case TOKEN_LSHIFT:
        printf("<<");
        break;
    case TOKEN_RSHIFT:
        printf(">>");
        break;
    case TOKEN_AND:
        printf("&&");
        break;
    case TOKEN_OR:
        printf("||");
        break;
    case TOKEN_BIT_AND:
        printf("&");
        break;
    case TOKEN_BIT_OR:
        printf("|");
        break;
    case TOKEN_BIT_XOR:
        printf("^");
        break;
    case TOKEN_NOT:
        printf("!");
        break;
    case TOKEN_BIT_COMPLEMENT:
        printf("~");
        break;
    case TOKEN_INCREMENT:
        printf("++");
        break;
    case TOKEN_DECREMENT:
        printf("--");
        break;
    case TOKEN_TERNARY:
        printf("?");
        break;
    case TOKEN_COLON:
        printf(":");
        break;
    case TOKEN_IF:
        printf("if");
        break;
    case TOKEN_ELSE:
        printf("else");
        break;
    case TOKEN_WHILE:
        printf("while");
        break;
    case TOKEN_DO:
        printf("do");
        break;
    case TOKEN_TYPEDEF:
        printf("typedef");
        break;
    case TOKEN_STRUCT:
        printf("struct");
        break;
    case TOKEN_MEMBER:
        printf(".");
        break;
    case TOKEN_ADD_ASSIGN:
        printf("+=");
        break;
    case TOKEN_SUBTRACT_ASSIGN:
        printf("-=");
        break;
    case TOKEN_MULTIPLY_ASSIGN:
        printf("*=");
        break;
    case TOKEN_DIVIDE_ASSIGN:
        printf("/=");
        break;
    case TOKEN_MOD_ASSIGN:
        printf("%%=");
        break;
    case TOKEN_LSHIFT_ASSIGN:
        printf("<<=");
        break;
    case TOKEN_RSHIFT_ASSIGN:
        printf(">>=");
        break;
    case TOKEN_BIT_AND_ASSIGN:
        printf("&=");
        break;
    case TOKEN_BIT_OR_ASSIGN:
        printf("|=");
        break;
    case TOKEN_BIT_XOR_ASSIGN:
        printf("^=");
        break;
    case TOKEN_RETURN:
        printf("return");
        break;
    case TOKEN_BREAK:
        printf("break");
        break;
    case TOKEN_CONTINUE:
        printf("continue");
        break;
    case TOKEN_FOR:
        printf("for");
        break;
    case TOKEN_SIZEOF:
        printf("sizeof");
        break;
    case TOKEN_SWITCH:
        printf("switch");
        break;
    case TOKEN_CASE:
        printf("case");
        break;
    case TOKEN_DEFAULT:
        printf("default");
        break;
    case TOKEN_ENUM:
        printf("enum");
        break;
    case TOKEN_HASH:
        printf("#");
        break;
    default:
        printf("<unknown %d>", (u32) token.kind);
    }
}



u0 type_does_not_exist(Type type, u24 line){
    printf("\nerror on line %d: Type '", u24_unpack(line));
    type_print(type);
    printf("' does not exist\n");
}



u32 type_sizeof_or_max(u32 type_index, u24 line_on_error){
    u32 name = types[type_index].name;
    u32 size;

    if(aux_cstr_equals_u0(name)){
        size = 0;
    } else if(aux_cstr_equals_u8(name) || aux_cstr_equals_u1(name)){
        size = 1;
    } else if(aux_cstr_equals_u16(name)){
        size = 2;
    } else if(aux_cstr_equals_u32(name)){
        size = 4;
    } else {
        u32 found_typedef = find_typedef(name);
        if(found_typedef >= TYPEDEFS_CAPACITY){
            type_does_not_exist(types[type_index], line_on_error);
            return -1;
        }

        size = typedefs[found_typedef].computed_size;

        if(size == -1){
            printf("\nerror on line %d: Type '", u24_unpack(line_on_error));
            type_print(types[type_index]);
            printf("' doesn't have its size computed yet\n");
            return -1;
        }
    }

    u32 dims[4];
    memcpy(dims, dimensions[types[type_index].dimensions], sizeof dims);

    for(u8 i = 0; i < 4 && dims[i] != 0; i++){
        size *= dims[i];
    }

    return size;
}



u1 type_equals(Type a, Type b){
    return a.dimensions == b.dimensions && aux_cstr_equals(a.name, b.name);
}



u0 type_print(Type type){
    print_aux_cstr(type.name);

    for(u32 i = 0; i < 4; i++){
        u32 dim = dimensions[type.dimensions][i];
        if(dim == 0) break;

        printf("[%d]", dim);
    }
}



u0 typedef_struct_print(TypeDef def){
    printf("typedef struct {\n");

    for(u32 i = 0; i < def.num_fields; i++){
        printf("    ");
        expression_print(expressions[statements[def.begin + i]]);
        printf(";\n");
    }

    printf("} ");
    print_aux_cstr(def.name);
    printf(";");
}

u0 typedef_print(TypeDef def){
    switch(def.kind){
    case TYPEDEF_STRUCT:
        typedef_struct_print(def);
        break;
    default:
        printf("<unknown typdef>");
    }
}

u0 type_alias_print(TypeAlias alias){
    printf("typedef ");
    type_print(types[alias.rewritten_type]);
    printf(" ");
    print_aux_cstr(alias.name);
    printf(";");
}



u24 u24_pack(u32 value){
    u24 result;
    result.bytes[0] = value._0;
    result.bytes[1] = value._1;
    result.bytes[2] = value._2;
    return result;
}

u32 u24_unpack(u24 value){
    u32 result;
    result._0 = value.bytes[0];
    result._1 = value.bytes[1];
    result._2 = value.bytes[2];
    return result;
}



typedef struct {
    u32 self_statement;
    u32 start_statement;
    u32 stop_statement;
    u32 secondary_start_statement;
    u32 secondary_stop_statement;
} Container;

Container get_parent_container(u32 statement_index){
    // Returns Conainer with start_statement >= STATEMENTS_CAPACITY when not parent container exists

    if(statement_index >= STATEMENTS_CAPACITY || emit_context.function >= FUNCTIONS_CAPACITY){
        // No parent container exists
        return (Container){
            .self_statement = STATEMENTS_CAPACITY,
            .start_statement = STATEMENTS_CAPACITY,
            .stop_statement = STATEMENTS_CAPACITY,
            .secondary_start_statement = STATEMENTS_CAPACITY,
            .secondary_stop_statement = STATEMENTS_CAPACITY,
        };
    }

    Function function = functions[emit_context.function];

    u1 allow_case = expressions[statements[statement_index]].kind != EXPRESSION_CASE;

    for(u32 i = statement_index - 1; i != function.begin - 1; i--){
        Expression expression = expressions[statements[i]];

        switch(expression.kind){
        case EXPRESSION_NONE:
        case EXPRESSION_RETURN:
        case EXPRESSION_DECLARE:
        case EXPRESSION_PRINT_LITERAL:
        case EXPRESSION_PRINT_ARRAY:
        case EXPRESSION_PRINTF:
        case EXPRESSION_MEMCMP:
        case EXPRESSION_MEMCPY:
        case EXPRESSION_CALL:
        case EXPRESSION_IMPLEMENT_PUT:
        case EXPRESSION_IMPLEMENT_PRINTU1:
        case EXPRESSION_IMPLEMENT_PRINTU8:
        case EXPRESSION_IMPLEMENT_GET:
        case EXPRESSION_IMPLEMENT_READU8:
        case EXPRESSION_U1:
        case EXPRESSION_U8:
        case EXPRESSION_U16:
        case EXPRESSION_U24:
        case EXPRESSION_U32:
        case EXPRESSION_INT:
        case EXPRESSION_VARIABLE:
        case EXPRESSION_CAST:
        case EXPRESSION_ASSIGN:
        case EXPRESSION_ADD:
        case EXPRESSION_SUBTRACT:
        case EXPRESSION_MULTIPLY:
        case EXPRESSION_DIVIDE:
        case EXPRESSION_MOD:
        case EXPRESSION_EQUALS:
        case EXPRESSION_NOT_EQUALS:
        case EXPRESSION_LESS_THAN:
        case EXPRESSION_GREATER_THAN:
        case EXPRESSION_LESS_THAN_OR_EQUAL:
        case EXPRESSION_GREATER_THAN_OR_EQUAL:
        case EXPRESSION_LSHIFT:
        case EXPRESSION_RSHIFT:
        case EXPRESSION_AND:
        case EXPRESSION_OR:
        case EXPRESSION_BIT_AND:
        case EXPRESSION_BIT_OR:
        case EXPRESSION_BIT_XOR:
        case EXPRESSION_NEGATE:
        case EXPRESSION_NOT:
        case EXPRESSION_BIT_COMPLEMENT:
        case EXPRESSION_INDEX:
        case EXPRESSION_PRE_INCREMENT:
        case EXPRESSION_PRE_DECREMENT:
        case EXPRESSION_POST_INCREMENT:
        case EXPRESSION_POST_DECREMENT:
        case EXPRESSION_NO_RESULT_INCREMENT:
        case EXPRESSION_NO_RESULT_DECREMENT:
        case EXPRESSION_TERNARY:
        case EXPRESSION_MEMBER:
        case EXPRESSION_STRING:
        case EXPRESSION_BREAK:
        case EXPRESSION_CONTINUE:
        case EXPRESSION_SIZEOF_TYPE:
        case EXPRESSION_SIZEOF_TYPE_U8:
        case EXPRESSION_SIZEOF_TYPE_U16:
        case EXPRESSION_SIZEOF_TYPE_U24:
        case EXPRESSION_SIZEOF_TYPE_U32:
        case EXPRESSION_SIZEOF_VALUE:
        case EXPRESSION_SIZEOF_VALUE_U8:
        case EXPRESSION_SIZEOF_VALUE_U16:
        case EXPRESSION_SIZEOF_VALUE_U24:
        case EXPRESSION_SIZEOF_VALUE_U32:
        case EXPRESSION_ARRAY_INITIALIZER:
        case EXPRESSION_STRUCT_INITIALIZER:
        case EXPRESSION_FIELD_INITIALIZER:
        case EXPRESSION_ENUM_VARIANT:
        case EXPRESSION_PANICLOOP:
            break;

        case EXPRESSION_IF:
        case EXPRESSION_WHILE:
        case EXPRESSION_DO_WHILE: {
                u32 num_statements = operands[expression.ops + 1];

                if(i + num_statements >= statement_index){
                    return (Container){
                        .self_statement = i,
                        .start_statement = i + 1,
                        .stop_statement = i + num_statements + 1,
                        .secondary_start_statement = STATEMENTS_CAPACITY,
                        .secondary_stop_statement = STATEMENTS_CAPACITY,
                    };
                }
            }
            break;
        case EXPRESSION_SWITCH: {
                u32 num_statements = operands[expression.ops + 1];

                if(i + num_statements >= statement_index){
                    return (Container){
                        .self_statement = i,
                        .start_statement = i + 1,
                        .stop_statement = i + 1,
                        .secondary_start_statement = STATEMENTS_CAPACITY,
                        .secondary_stop_statement = STATEMENTS_CAPACITY,
                    };
                }
            }
            break;
        case EXPRESSION_IF_ELSE: {
                u32 num_then = operands[expression.ops + 1];
                u32 num_else = operands[expression.ops + 2];

                if(i + num_then >= statement_index){
                    return (Container){
                        .self_statement = i,
                        .start_statement = i + 1,
                        .stop_statement = i + num_then + 1,
                        .secondary_start_statement = STATEMENTS_CAPACITY,
                        .secondary_stop_statement = STATEMENTS_CAPACITY,
                    };
                }

                if(i + num_then + num_else >= statement_index){
                    return (Container){
                        .self_statement = i,
                        .start_statement = i + num_then + 1,
                        .stop_statement = i + num_then + num_else + 1,
                        .secondary_start_statement = STATEMENTS_CAPACITY,
                        .secondary_stop_statement = STATEMENTS_CAPACITY,
                    };
                }
            }
            break;
        case EXPRESSION_CONDITIONLESS_BLOCK: {
                u32 num_statements = expression.ops;

                if(i + num_statements >= statement_index){
                    return (Container){
                        .self_statement = i,
                        .start_statement = i + 1,
                        .stop_statement = i + num_statements + 1,
                        .secondary_start_statement = STATEMENTS_CAPACITY,
                        .secondary_stop_statement = STATEMENTS_CAPACITY,
                    };
                }
            }
            break;
        case EXPRESSION_FOR: {
                u32 num_pre = operands[expression.ops];
                u32 num_post = operands[expression.ops + 2];
                u32 num_inside = operands[expression.ops + 3];

                // Check if in pre-statements
                if(i + num_pre >= statement_index){
                    return (Container){
                        .self_statement = i,
                        .start_statement = i + 1,
                        .stop_statement = i + num_pre + 1,
                        .secondary_start_statement = STATEMENTS_CAPACITY,
                        .secondary_stop_statement = STATEMENTS_CAPACITY,
                    };
                }

                // Check if in post-statements
                if(i + num_pre >= statement_index){
                    return (Container){
                        .self_statement = i,
                        .start_statement = i + num_pre + 1,
                        .stop_statement = i + num_pre + num_post + 1,
                        .secondary_start_statement = STATEMENTS_CAPACITY,
                        .secondary_stop_statement = STATEMENTS_CAPACITY,
                    };
                }

                // Check if in main body
                if(i + num_pre + num_post + num_inside >= statement_index){
                    return (Container){
                        .self_statement = i,
                        .start_statement = i + num_pre + num_post + 1,
                        .stop_statement = i + num_pre + num_post + num_inside + 1,
                        .secondary_start_statement = i + 1,
                        .secondary_stop_statement = i + num_pre + 1,
                    };
                }
            }
            break;
        case EXPRESSION_CASE: {
                u32 num_statements = operands[expression.ops + 1];

                if(allow_case && i + num_statements >= statement_index){
                    return (Container){
                        .self_statement = i,
                        .start_statement = i + 1,
                        .stop_statement = i + num_statements + 1,
                        .secondary_start_statement = STATEMENTS_CAPACITY,
                        .secondary_stop_statement = STATEMENTS_CAPACITY,
                    };
                }
            }
            break;
        }
    }

    // Function "container"
    return (Container){
        .self_statement = STATEMENTS_CAPACITY,
        .start_statement = function.begin,
        .stop_statement = function.begin + function.num_stmts + 1,
        .secondary_start_statement = STATEMENTS_CAPACITY,
        .secondary_stop_statement = STATEMENTS_CAPACITY,
    };
}

u32 find_declaration(u32 start_statement, u32 stop_statement, u32 name){
    // Returns STATEMENTS_CAPACITY when cannot find

    for(u32 i = start_statement; i < stop_statement; i++){
        Expression expression = expressions[statements[i]];

        switch(expression.kind){
        case EXPRESSION_NONE:
        case EXPRESSION_RETURN:
        case EXPRESSION_PRINT_LITERAL:
        case EXPRESSION_PRINT_ARRAY:
        case EXPRESSION_PRINTF:
        case EXPRESSION_MEMCMP:
        case EXPRESSION_MEMCPY:
        case EXPRESSION_CALL:
        case EXPRESSION_IMPLEMENT_PUT:
        case EXPRESSION_IMPLEMENT_PRINTU1:
        case EXPRESSION_IMPLEMENT_PRINTU8:
        case EXPRESSION_IMPLEMENT_GET:
        case EXPRESSION_IMPLEMENT_READU8:
        case EXPRESSION_U1:
        case EXPRESSION_U8:
        case EXPRESSION_U16:
        case EXPRESSION_U24:
        case EXPRESSION_U32:
        case EXPRESSION_INT:
        case EXPRESSION_VARIABLE:
        case EXPRESSION_CAST:
        case EXPRESSION_ASSIGN:
        case EXPRESSION_ADD:
        case EXPRESSION_SUBTRACT:
        case EXPRESSION_MULTIPLY:
        case EXPRESSION_DIVIDE:
        case EXPRESSION_MOD:
        case EXPRESSION_EQUALS:
        case EXPRESSION_NOT_EQUALS:
        case EXPRESSION_LESS_THAN:
        case EXPRESSION_GREATER_THAN:
        case EXPRESSION_LESS_THAN_OR_EQUAL:
        case EXPRESSION_GREATER_THAN_OR_EQUAL:
        case EXPRESSION_LSHIFT:
        case EXPRESSION_RSHIFT:
        case EXPRESSION_AND:
        case EXPRESSION_OR:
        case EXPRESSION_BIT_AND:
        case EXPRESSION_BIT_OR:
        case EXPRESSION_BIT_XOR:
        case EXPRESSION_NEGATE:
        case EXPRESSION_NOT:
        case EXPRESSION_BIT_COMPLEMENT:
        case EXPRESSION_INDEX:
        case EXPRESSION_PRE_INCREMENT:
        case EXPRESSION_PRE_DECREMENT:
        case EXPRESSION_POST_INCREMENT:
        case EXPRESSION_POST_DECREMENT:
        case EXPRESSION_NO_RESULT_INCREMENT:
        case EXPRESSION_NO_RESULT_DECREMENT:
        case EXPRESSION_TERNARY:
        case EXPRESSION_MEMBER:
        case EXPRESSION_STRING:
        case EXPRESSION_BREAK:
        case EXPRESSION_CONTINUE:
        case EXPRESSION_SIZEOF_TYPE:
        case EXPRESSION_SIZEOF_TYPE_U8:
        case EXPRESSION_SIZEOF_TYPE_U16:
        case EXPRESSION_SIZEOF_TYPE_U24:
        case EXPRESSION_SIZEOF_TYPE_U32:
        case EXPRESSION_SIZEOF_VALUE:
        case EXPRESSION_SIZEOF_VALUE_U8:
        case EXPRESSION_SIZEOF_VALUE_U16:
        case EXPRESSION_SIZEOF_VALUE_U24:
        case EXPRESSION_SIZEOF_VALUE_U32:
        case EXPRESSION_CASE:
        case EXPRESSION_ARRAY_INITIALIZER:
        case EXPRESSION_STRUCT_INITIALIZER:
        case EXPRESSION_FIELD_INITIALIZER:
        case EXPRESSION_ENUM_VARIANT:
        case EXPRESSION_PANICLOOP:
            break;

        case EXPRESSION_IF:
        case EXPRESSION_WHILE:
        case EXPRESSION_DO_WHILE:
        case EXPRESSION_SWITCH:
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_IF_ELSE:
            i += operands[expression.ops + 1] + operands[expression.ops + 2];
            break;
        case EXPRESSION_CONDITIONLESS_BLOCK:
            i += expression.ops;
            break;
        case EXPRESSION_FOR:
            i += operands[expression.ops] + operands[expression.ops + 2] + operands[expression.ops + 3];
            break;
        case EXPRESSION_DECLARE:
            if(aux_cstr_equals(operands[expression.ops + 1], name)){
                return i;
            }
            break;
        }
    }

    return STATEMENTS_CAPACITY;
}

typedef struct {
    u32 delta_i;
    u32 delta_depth;
    u32 delta_offset;
} HoneInfo;

HoneInfo hone_switch_case_or_skip(u32 current_statement, u32 target_statement, u32 num_statements){
    for(u32 i = current_statement + 1; i < current_statement + num_statements + 1; i++){
        Expression expression = expressions[statements[i]];

        switch(expression.kind){
        case EXPRESSION_NONE:
        case EXPRESSION_RETURN:
        case EXPRESSION_DECLARE:
        case EXPRESSION_PRINT_LITERAL:
        case EXPRESSION_PRINT_ARRAY:
        case EXPRESSION_PRINTF:
        case EXPRESSION_MEMCMP:
        case EXPRESSION_MEMCPY:
        case EXPRESSION_CALL:
        case EXPRESSION_IMPLEMENT_PUT:
        case EXPRESSION_IMPLEMENT_PRINTU1:
        case EXPRESSION_IMPLEMENT_PRINTU8:
        case EXPRESSION_IMPLEMENT_GET:
        case EXPRESSION_IMPLEMENT_READU8:
        case EXPRESSION_U1:
        case EXPRESSION_U8:
        case EXPRESSION_U16:
        case EXPRESSION_U24:
        case EXPRESSION_U32:
        case EXPRESSION_INT:
        case EXPRESSION_VARIABLE:
        case EXPRESSION_CAST:
        case EXPRESSION_ASSIGN:
        case EXPRESSION_ADD:
        case EXPRESSION_SUBTRACT:
        case EXPRESSION_MULTIPLY:
        case EXPRESSION_DIVIDE:
        case EXPRESSION_MOD:
        case EXPRESSION_EQUALS:
        case EXPRESSION_NOT_EQUALS:
        case EXPRESSION_LESS_THAN:
        case EXPRESSION_GREATER_THAN:
        case EXPRESSION_LESS_THAN_OR_EQUAL:
        case EXPRESSION_GREATER_THAN_OR_EQUAL:
        case EXPRESSION_LSHIFT:
        case EXPRESSION_RSHIFT:
        case EXPRESSION_AND:
        case EXPRESSION_OR:
        case EXPRESSION_BIT_AND:
        case EXPRESSION_BIT_OR:
        case EXPRESSION_BIT_XOR:
        case EXPRESSION_NEGATE:
        case EXPRESSION_NOT:
        case EXPRESSION_BIT_COMPLEMENT:
        case EXPRESSION_INDEX:
        case EXPRESSION_PRE_INCREMENT:
        case EXPRESSION_PRE_DECREMENT:
        case EXPRESSION_POST_INCREMENT:
        case EXPRESSION_POST_DECREMENT:
        case EXPRESSION_NO_RESULT_INCREMENT:
        case EXPRESSION_NO_RESULT_DECREMENT:
        case EXPRESSION_TERNARY:
        case EXPRESSION_MEMBER:
        case EXPRESSION_STRING:
        case EXPRESSION_BREAK:
        case EXPRESSION_CONTINUE:
        case EXPRESSION_SIZEOF_TYPE:
        case EXPRESSION_SIZEOF_TYPE_U8:
        case EXPRESSION_SIZEOF_TYPE_U16:
        case EXPRESSION_SIZEOF_TYPE_U24:
        case EXPRESSION_SIZEOF_TYPE_U32:
        case EXPRESSION_SIZEOF_VALUE:
        case EXPRESSION_SIZEOF_VALUE_U8:
        case EXPRESSION_SIZEOF_VALUE_U16:
        case EXPRESSION_SIZEOF_VALUE_U24:
        case EXPRESSION_SIZEOF_VALUE_U32:
        case EXPRESSION_ARRAY_INITIALIZER:
        case EXPRESSION_STRUCT_INITIALIZER:
        case EXPRESSION_FIELD_INITIALIZER:
        case EXPRESSION_ENUM_VARIANT:
        case EXPRESSION_PANICLOOP:
            break;

        case EXPRESSION_IF:
        case EXPRESSION_WHILE:
        case EXPRESSION_DO_WHILE:
        case EXPRESSION_SWITCH:
            i += operands[expression.ops + 1];
            break;
        case EXPRESSION_IF_ELSE:
            i += operands[expression.ops + 1] + operands[expression.ops + 2];
            break;
        case EXPRESSION_CONDITIONLESS_BLOCK:
            i += expression.ops;
            break;
        case EXPRESSION_FOR:
            i += operands[expression.ops] + operands[expression.ops + 2] + operands[expression.ops + 3];
            break;
        case EXPRESSION_CASE: {
                u32 num_case_statements = operands[expression.ops + 1];

                if(target_statement <= i + num_case_statements){
                    u32 delta_offset = emit_context.in_recursive_function ? 0 : 2;
                    return (HoneInfo){ .delta_i = i - (current_statement + 1), .delta_depth = 1, .delta_offset = delta_offset };
                }
            }
            break;
        }
    }

    return (HoneInfo){ .delta_i = num_statements, .delta_depth = 0, .delta_offset = 0 };
}

HoneInfo hone_statement(u32 current_statement, u32 target_statement);

HoneInfo hone_for_body_or_skip(u32 current_statement, u32 target_statement, u32 num_pre, u32 num_post, u32 len, u32 inner_variable_offset){
    u32 pre_offset = 0;

    for(u32 i = current_statement + 1; i < current_statement + 1 + num_pre; i++){
        Expression expression = expressions[statements[i]];

        if(expression.kind == EXPRESSION_DECLARE){
            u32 type_size = type_sizeof_or_max(operands[expression.ops], expression.line);

            if(type_size != -1){
                pre_offset += type_size;
            }
        } else {
            // Skip over constructs
            HoneInfo hone_info = hone_statement(i, target_statement);
            i += hone_info.delta_i;
            pre_offset += hone_info.delta_offset;
        }
    }

    return (HoneInfo){ .delta_i = num_pre + num_post, .delta_depth = 1, .delta_offset = pre_offset + inner_variable_offset };
}

HoneInfo hone_statement(u32 current_statement, u32 target_statement){
    Expression expression = expressions[statements[current_statement]];

    switch(expression.kind){
    case EXPRESSION_NONE:
    case EXPRESSION_RETURN:
    case EXPRESSION_DECLARE:
    case EXPRESSION_PRINT_LITERAL:
    case EXPRESSION_PRINT_ARRAY:
    case EXPRESSION_PRINTF:
    case EXPRESSION_MEMCMP:
    case EXPRESSION_MEMCPY:
    case EXPRESSION_CALL:
    case EXPRESSION_IMPLEMENT_PUT:
    case EXPRESSION_IMPLEMENT_PRINTU1:
    case EXPRESSION_IMPLEMENT_PRINTU8:
    case EXPRESSION_IMPLEMENT_GET:
    case EXPRESSION_IMPLEMENT_READU8:
    case EXPRESSION_U1:
    case EXPRESSION_U8:
    case EXPRESSION_U16:
    case EXPRESSION_U24:
    case EXPRESSION_U32:
    case EXPRESSION_INT:
    case EXPRESSION_VARIABLE:
    case EXPRESSION_CAST:
    case EXPRESSION_ASSIGN:
    case EXPRESSION_ADD:
    case EXPRESSION_SUBTRACT:
    case EXPRESSION_MULTIPLY:
    case EXPRESSION_DIVIDE:
    case EXPRESSION_MOD:
    case EXPRESSION_EQUALS:
    case EXPRESSION_NOT_EQUALS:
    case EXPRESSION_LESS_THAN:
    case EXPRESSION_GREATER_THAN:
    case EXPRESSION_LESS_THAN_OR_EQUAL:
    case EXPRESSION_GREATER_THAN_OR_EQUAL:
    case EXPRESSION_LSHIFT:
    case EXPRESSION_RSHIFT:
    case EXPRESSION_AND:
    case EXPRESSION_OR:
    case EXPRESSION_BIT_AND:
    case EXPRESSION_BIT_OR:
    case EXPRESSION_BIT_XOR:
    case EXPRESSION_NEGATE:
    case EXPRESSION_NOT:
    case EXPRESSION_BIT_COMPLEMENT:
    case EXPRESSION_INDEX:
    case EXPRESSION_PRE_INCREMENT:
    case EXPRESSION_PRE_DECREMENT:
    case EXPRESSION_POST_INCREMENT:
    case EXPRESSION_POST_DECREMENT:
    case EXPRESSION_NO_RESULT_INCREMENT:
    case EXPRESSION_NO_RESULT_DECREMENT:
    case EXPRESSION_TERNARY:
    case EXPRESSION_MEMBER:
    case EXPRESSION_STRING:
    case EXPRESSION_BREAK:
    case EXPRESSION_CONTINUE:
    case EXPRESSION_SIZEOF_TYPE:
    case EXPRESSION_SIZEOF_TYPE_U8:
    case EXPRESSION_SIZEOF_TYPE_U16:
    case EXPRESSION_SIZEOF_TYPE_U24:
    case EXPRESSION_SIZEOF_TYPE_U32:
    case EXPRESSION_SIZEOF_VALUE:
    case EXPRESSION_SIZEOF_VALUE_U8:
    case EXPRESSION_SIZEOF_VALUE_U16:
    case EXPRESSION_SIZEOF_VALUE_U24:
    case EXPRESSION_SIZEOF_VALUE_U32:
    case EXPRESSION_CASE:
    case EXPRESSION_ARRAY_INITIALIZER:
    case EXPRESSION_STRUCT_INITIALIZER:
    case EXPRESSION_FIELD_INITIALIZER:
    case EXPRESSION_ENUM_VARIANT:
    case EXPRESSION_PANICLOOP:
        break;

    case EXPRESSION_IF: {
            u32 num_statements = operands[expression.ops + 1];

            if(target_statement <= current_statement + num_statements){
                return (HoneInfo){ .delta_i = 0, .delta_depth = 1, .delta_offset = 0 };
            } else {
                return (HoneInfo){ .delta_i = num_statements, .delta_depth = 0, .delta_offset = 0 };
            }
        }
        break;
    case EXPRESSION_IF_ELSE: {
            u32 num_then = operands[expression.ops + 1];
            u32 num_else = operands[expression.ops + 2];

            if(target_statement <= current_statement + num_then){
                return (HoneInfo){ .delta_i = 0, .delta_depth = 1, .delta_offset = 0 };
            } else if(target_statement <= current_statement + num_then + num_else){
                return (HoneInfo){ .delta_i = num_then, .delta_depth = 1, .delta_offset = 0 };
            } else {
                return (HoneInfo){ .delta_i = num_then + num_else, .delta_depth = 0, .delta_offset = 0 };
            }
        }
        break;
    case EXPRESSION_WHILE:
    case EXPRESSION_DO_WHILE: {
            u32 num_statements = operands[expression.ops + 1];
            u32 inner_variable_offset = emit_context.in_recursive_function ? 0 : operands[expression.ops + 2];

            if(target_statement <= current_statement + num_statements){
                return (HoneInfo){ .delta_i = 0, .delta_depth = 1, .delta_offset = inner_variable_offset };
            } else {
                return (HoneInfo){ .delta_i = num_statements, .delta_depth = 0, .delta_offset = 0 };
            }
        }
        break;
    case EXPRESSION_CONDITIONLESS_BLOCK: {
            u32 num_statements = expression.ops;

            if(target_statement <= current_statement + num_statements){
                return (HoneInfo){ .delta_i = 0, .delta_depth = 1, .delta_offset = 0 };
            } else {
                return (HoneInfo){ .delta_i = num_statements, .delta_depth = 0, .delta_offset = 0 };
            }
        }
        break;
    case EXPRESSION_FOR: {
            u32 num_pre = operands[expression.ops];
            u32 num_post = operands[expression.ops + 2];
            u32 len = operands[expression.ops + 3];
            u32 inner_variable_offset = emit_context.in_recursive_function ? 0 : operands[expression.ops + 4];

            if(target_statement <= current_statement + num_pre){
                return (HoneInfo){ .delta_i = 0, .delta_depth = 1, .delta_offset = 0 };
            } else if(target_statement <= current_statement + num_pre + num_post){
                // NOTE: Should never happen since referencing these variables is not allowed under normal circumstances
                return (HoneInfo){ .delta_i = num_pre, .delta_depth = 1, .delta_offset = inner_variable_offset };
            } else if(target_statement <= current_statement + num_pre + num_post + len){
                return hone_for_body_or_skip(current_statement, target_statement, num_pre, num_post, len, inner_variable_offset);
            } else {
                return (HoneInfo){ .delta_i = num_pre + num_post + len, .delta_depth = 0, .delta_offset = 0 };
            }
        }
        break;
    case EXPRESSION_SWITCH: {
            u32 num_statements = operands[expression.ops + 1];

            // Find which case
            return hone_switch_case_or_skip(current_statement, target_statement, num_statements);
        }
        break;
    }

    return (HoneInfo){ .delta_i = 0, .delta_depth = 0, .delta_offset = 0 };
}

Variable get_variable_location_from_declaration_statement(u32 statement_index){
    Expression expression = expressions[statements[statement_index]];

    u32 depth = 1;
    u32 offset = 0;
    u32 function_begin = functions[emit_context.function].begin;
    u32 function_arity = functions[emit_context.function].arity;

    for(u32 i = function_begin; i < statement_index; i++){
        Expression expression = expressions[statements[i]];

        if(emit_context.can_function_early_return && i == function_begin + function_arity){
            offset++;
        }

        if(expression.kind == EXPRESSION_DECLARE){
            u32 type_size = type_sizeof_or_max(operands[expression.ops], expression.line);

            if(type_size != -1){
                offset += type_size;
            }
        } else {
            HoneInfo hone_info = hone_statement(i, statement_index);
            i += hone_info.delta_i;
            depth += hone_info.delta_depth;
            offset += hone_info.delta_offset;
        }
    }

    return (Variable){
        .name = operands[expression.ops + 1],
        .type = operands[expression.ops + 0],
        .defined = true,
        .depth = depth,
        .location = (VariableLocation){
            .kind = VARIABLE_LOCATION_ON_TAPE,
            .location = emit_context.function_cell_index + offset,
        },
    };
}

u32 u32_min2(u32 a, u32 b){
    return a <= b ? a : b;
}

Variable variable_find(u32 name){
    for(
        Container container = get_parent_container(emit_context.current_statement);
        container.start_statement < STATEMENTS_CAPACITY;
        container = get_parent_container(container.self_statement)
    ){
        u32 declaration = find_declaration(container.start_statement, u32_min2(container.stop_statement, emit_context.current_statement), name);

        if(declaration < STATEMENTS_CAPACITY){
            return get_variable_location_from_declaration_statement(declaration);
        }

        if(container.secondary_start_statement < STATEMENTS_CAPACITY){
            declaration = find_declaration(container.secondary_start_statement, u32_min2(container.secondary_stop_statement, emit_context.current_statement), name);

            if(declaration < STATEMENTS_CAPACITY){
                return get_variable_location_from_declaration_statement(declaration);
            }
        }
    }

    // Search global
    u32 global_variable_cell_offset = 0;
    for(u32 global_i = 0; global_i < num_globals; global_i++){
        Global global = globals[global_i];

        if(aux_cstr_equals(global.name, name)){
            return (Variable){
                .name = name,
                .type = global.type,
                .defined = true,
                .depth = 0,
                .location = (VariableLocation){
                    .kind = VARIABLE_LOCATION_ON_TAPE,
                    .location = global_variable_cell_offset,
                },
            };
        }

        u32 size = type_sizeof_or_max(global.type, global.line);
        if(size == -1) return (Variable){ .defined = false };

        global_variable_cell_offset += size;
    }

    // Search for enum variant
    for(u32 typedef_i = 0; typedef_i < num_typedefs; typedef_i++){
        TypeDef def = typedefs[typedef_i];

        if(def.kind != TYPEDEF_ENUM) continue;

        for(u32 i = 0; i < def.num_fields; i++){
            Expression variant = expressions[statements[def.begin + i]];
            if(variant.kind != EXPRESSION_ENUM_VARIANT) continue;

            if(aux_cstr_equals(variant.ops, name)){
                u32 enum_type = add_type((Type){
                    .name = def.name,
                    .dimensions = 0
                });

                if(enum_type == TYPES_CAPACITY){
                    return (Variable){ .defined = false };
                }

                u32 variant_value = i;

                return (Variable){
                    .name = name,
                    .defined = true,
                    .type = enum_type,
                    .depth = 0,
                    .location = (VariableLocation){
                        .kind = VARIABLE_LOCATION_IMMUTABLE,
                        .location = variant_value,
                    }
                };
            }
        }
    }

    // Not found
    return (Variable){ .defined = false };
}

